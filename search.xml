<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>八大排序算法实现与讲解</title>
    <url>/posts/8-sort.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：八大排序的C和Python实现，缓慢更新中…学到哪更新到哪（脑袋瓜笨啊~）</p>
<a id="more"></a>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序作为C语言for循环讲解的启蒙例子，相信大家对他都很熟悉</p>
<p>主要思路：</p>
<ol>
<li>比较相邻的元素，根据规则选择是否交换这两个数</li>
<li>从开始第一对到结尾最后一对</li>
<li>针对多个元素重复以上操作（除了最后一个）</li>
</ol>
<ul>
<li>时间复杂度：平均O(n^2)    最好：O(n)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：稳定</li>
</ul>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/algorithm_1_0.gif" alt></p>
<p>C：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,tmp;</span><br><span class="line">    <span class="keyword">int</span> swap = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; len<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j&lt; len <span class="number">-1</span> -i; j++)</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                swap = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(swap)	<span class="comment">//如果没进行交换直接退出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(arr:[int])</span>-&gt; [int]:</span></span><br><span class="line">    swap = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(arr)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,len(arr)<span class="number">-1</span>-i):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">                arr[j],arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>],arr[j]</span><br><span class="line">                swap = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> swap:</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>主要思路：每趟从待排序的记录中选出关键字最小的记录，顺序放在已排序的记录序列末尾，直到全部排序结束为止。</p>
<ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/algorithm_5_0.gif" alt></p>
<p>C:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,tmp;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span>(j=i + <span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[min])</span><br><span class="line">                min = j;</span><br><span class="line">        tmp = arr[i];</span><br><span class="line">        arr[i]=arr[min];</span><br><span class="line">        arr[min] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(arr:[int])</span>-&gt; [int]:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(arr)):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(arr)):</span><br><span class="line">            <span class="keyword">if</span> arr[min_index] &gt; arr[j]:</span><br><span class="line">                min_index = j</span><br><span class="line">        arr[min_index],arr[i] = arr[i],arr[min_index]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>主要思路：每一趟将一个待排序的记录，按照其关键字的大小插入到有序队列的合适位置里，直到全部插入完成。 </p>
<ul>
<li>时间复杂度：平均:O(n^2)    最好:O(n)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：稳定</li>
</ul>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/algorithm_2_1.gif" alt></p>
<p>C:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt; len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp  = arr[i];</span><br><span class="line">        <span class="keyword">for</span>(j = i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; tmp)</span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(arr:[int])</span>-&gt; [int]:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(arr)):</span><br><span class="line">        tmp = arr[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; tmp:</span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        arr[j+<span class="number">1</span>] = tmp</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔(Shell)排序又称为<strong>缩小增量排序</strong>，它是一种<strong>插入排序</strong>。它<strong>是直接插入排序算法的一种改进版</strong>。希尔排序的比较次数和移动次数都要比直接插入排序少，当N越大时，效果越明显。</p>
<p>算法思想：</p>
<p>我们举个例子来描述算法流程（以下摘自<a href="https://zh.wikipedia.org/wiki/希尔排序" target="_blank" rel="noopener">维基百科</a>）：</p>
<p>假设有这样一组数 {13, 14, 94, 33, 82, 25, 59, 94, 65, 23, 45, 27, 73, 25, 39, 10}，如果我们以步长为 5 开始进行排序：</p>
<table>
<thead>
<tr>
<th>排序前</th>
<th>排序后</th>
</tr>
</thead>
<tbody><tr>
<td>13 14 94 33 82<br>25 59 94 65 23<br>45 27 73 25 39<br>10</td>
<td>10 14 73 25 23<br>13 27 94 33 39<br>25 59 94 65 82<br>45</td>
</tr>
</tbody></table>
<p>将上述四行数字，依序接在一起时我们得到：{10, 14, 73, 25, 23, 13, 27, 94, 33, 39, 25, 59, 94, 65, 82, 45}，然后再以 3 为步长：</p>
<table>
<thead>
<tr>
<th>排序前</th>
<th>排序后</th>
</tr>
</thead>
<tbody><tr>
<td>10 14 73<br>25 23 13<br>27 94 33<br>39 25 59<br>94 65 82<br>45</td>
<td>10 14 13<br>25 23 33<br>27 25 59<br>39 65 73<br>45 94 82<br>94</td>
</tr>
</tbody></table>
<p>最后以 1 为步长进行排序（此时就是简单的插入排序了）。</p>
<p>可想而知，步长的选择是希尔排序的重要部分。算法最开始以一定的步长进行排序，然后会继续以更小的步长进行排序，最终算法以步长为 1 进行排序。当步长为 1 时，算法变为直接插入排序，这就保证了数据一定会被全部排序。</p>
<ul>
<li>时间复杂度：平均:O(nlogn)    最坏:O(n^2)</li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<p>C:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len,<span class="keyword">int</span> gap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i = gap; i&lt;len; i = i+gap)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = arr[i];</span><br><span class="line">        <span class="keyword">for</span>(j = i -gap;j&gt;=<span class="number">0</span>;j=j-gap)</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; tmp)</span><br><span class="line">                arr[j+gap] = arr[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        arr[j+gap] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shell</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap[] = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;    <span class="comment">//可以分为步长的一半，这里就自定义好了</span></span><br><span class="line">    <span class="keyword">int</span> len_gap = <span class="keyword">sizeof</span>(gap)/<span class="keyword">sizeof</span>(gap[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len_gap;++i)</span><br><span class="line">        shell_sort(arr,len,gap[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(arr:[int])</span>-&gt;[int]:</span></span><br><span class="line">    g = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> gap <span class="keyword">in</span> g:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap,len(arr)):</span><br><span class="line">            tmp = arr[i]</span><br><span class="line">            j = i-gap</span><br><span class="line">            <span class="keyword">while</span> j&gt;=<span class="number">0</span> <span class="keyword">and</span> arr[j] &gt; tmp:</span><br><span class="line">                arr[j+gap] = arr[j]</span><br><span class="line">                j = j - gap</span><br><span class="line">            arr[j+gap] = tmp</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的基本思想是：通过一趟排序将要排序的数据<strong>分割</strong>成独立的两部分：<strong>分割点左边都是比它小的数，右边都是比它大的数。</strong></p>
<ul>
<li>时间复杂度：平均:O(nlogn)    最坏:O(n^2)</li>
<li>空间复杂度：O(logn)</li>
<li>稳定性：不稳定</li>
</ul>
<p>然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/algorithm_4_0.gif" alt></p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200820230548.png" alt></p>
<p>C:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">division</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//每次取基准数为最左边的那个数</span></span><br><span class="line">    <span class="keyword">int</span> base = arr[left];</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从右端开始，向左寻找，找到小于基准数的值时将元素放最左边</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[right] &gt;= base)</span><br><span class="line">            --right;</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        <span class="comment">//同理，当找到时转为左边开始向右找，将大于基准数的值放元素右边</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[left] &lt;= base)</span><br><span class="line">            ++left;</span><br><span class="line">        arr[right] = arr[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后将base放到left位置。此时，left位置的左侧数值应该都比left小；</span></span><br><span class="line">    <span class="comment">// 而left位置的右侧数值应该都比left大</span></span><br><span class="line">    arr[left] = base;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//左下标要小于右下标，否则会越界</span></span><br><span class="line">    <span class="keyword">if</span>( left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//按照基准数对数组进行分割</span></span><br><span class="line">        <span class="keyword">int</span> base = division(arr,left,right);</span><br><span class="line">        <span class="comment">//分别对左右两边进行递归</span></span><br><span class="line">        quick_sort(arr,left,base<span class="number">-1</span>);</span><br><span class="line">        quick_sort(arr,base+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(arr:[int],left:int,right:int)</span>-&gt;[int]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">division</span><span class="params">(arr:[int],left:int,right:int)</span>:</span></span><br><span class="line">        base = arr[left]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[right] &gt;= base:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            arr[left] = arr[right]</span><br><span class="line">            <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[left] &lt;= base:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            arr[right] = arr[left]</span><br><span class="line">        arr[left] = base</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left&lt;right):</span><br><span class="line">        base = division(arr,left,right)</span><br><span class="line">        quick_sort(arr,left,base<span class="number">-1</span>)</span><br><span class="line">        quick_sort(arr,base+<span class="number">1</span>,right)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是一种<strong>选择排序。</strong></p>
<p><strong>堆</strong>是一棵<strong>顺序存储</strong>的<strong>完全二叉树</strong>。</p>
<ul>
<li>其中每个结点的关键字都<strong>不大于</strong>其孩子结点的关键字，这样的堆称为<strong>小根堆</strong>。</li>
<li>其中每个结点的关键字都<strong>不小于</strong>其孩子结点的关键字，这样的堆称为<strong>大**</strong>根堆**。</li>
</ul>
<p>举例来说，对于n个元素的序列{R0, R1, … , Rn}当且仅当满足下列关系之一时，称之为堆：</p>
<ul>
<li>Ri &lt;= R2i+1 且 Ri &lt;= R2i+2 (小根堆)</li>
<li>Ri &gt;= R2i+1 且 Ri &gt;= R2i+2 (大根堆)</li>
</ul>
<p>其中i=1,2,…,n/2向下取整；</p>
<ul>
<li>时间复杂度：O(nlogn)    </li>
<li>空间复杂度：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>该算法采用经典的<strong>分治</strong>（divide-and-conquer）策略（分治法将问题<strong>分</strong>(divide)成一些小的问题然后递归求解，而<strong>治(conquer)</strong>的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p>
<ul>
<li>时间复杂度：O(nlog2n)    </li>
<li>空间复杂度：O(n)</li>
<li>稳定性：稳定</li>
</ul>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/algorithm_7_0.gif" alt></p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基本思想：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。</p>
<p>算法步骤：</p>
<ul>
<li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。</li>
<li>从最低位开始，依次进行一次排序。</li>
<li>这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</li>
</ul>
<p>基数排序的方式可以采用 LSD（Least significant digital）或 MSD（Most significant digital），LSD 的排序方式由键值的最右边开始，而 MSD 则相反，由键值的最左边开始。</p>
<p>不妨通过一个具体的实例来展示一下基数排序是如何进行的。 设有一个初始序列为: R {50, 123, 543, 187, 49, 30, 0, 2, 11, 100}。</p>
<p>我们知道，任何一个阿拉伯数，它的各个位数上的基数都是以 0<del>9 来表示的，所以我们不妨把 0</del>9 视为 10 个桶。</p>
<p>我们先根据序列的个位数的数字来进行分类，将其分到指定的桶中。例如：R[0] = 50，个位数上是 0，将这个数存入编号为 0 的桶中。</p>
<p>分类后，我们在从各个桶中，将这些数按照从编号 0 到编号 9 的顺序依次将所有数取出来。这时，得到的序列就是个位数上呈递增趋势的序列。</p>
<p>按照个位数排序： {50, 30, 0, 100, 11, 2, 123, 543, 187, 49}。</p>
<p>接下来，可以对十位数、百位数也按照这种方法进行排序，最后就能得到排序完成的序列。</p>
<ul>
<li>时间复杂度：O(dn)    </li>
<li>空间复杂度：O(n)</li>
<li>稳定性：稳定</li>
</ul>
<p><a href="https://cuijiahua.com/wp-content/uploads/2018/01/algorithm_8_1.png" target="_blank" rel="noopener"></a></p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/algorithm_8_2.gif" alt></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>ADB和APPIUM的基本知识</title>
    <url>/posts/30468.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：记录了测试中adb的基本命令以及appium的使用步骤。</p>
<a id="more"></a>

<h2 id="adb调试工具"><a href="#adb调试工具" class="headerlink" title="adb调试工具"></a>adb调试工具</h2><h3 id="adb的概念"><a href="#adb的概念" class="headerlink" title="adb的概念"></a>adb的概念</h3><ul>
<li>开发安卓应用的程序员必须要掌握</li>
<li>测试工程师在做测试时会用到</li>
</ul>
<h3 id="adb的构成和工作原理"><a href="#adb的构成和工作原理" class="headerlink" title="adb的构成和工作原理"></a>adb的构成和工作原理</h3><p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200608113936800.png" alt="image-20200608113936800"></p>
<h3 id="adb的常用命令"><a href="#adb的常用命令" class="headerlink" title="adb的常用命令"></a>adb的常用命令</h3><ul>
<li><p>获取包名和界面名</p>
<p>1.包名和界面名的概念</p>
<p>包名（package）：决定文件的唯一性</p>
<p>界面名（activity）：一个界面对应一个一个界面名</p>
<p>2.获取包名和界面名</p>
<blockquote>
<p>1.打开测试的应用程序</p>
<p>2.输入adb命令</p>
</blockquote>
<p>命令格式：</p>
<ul>
<li><p>Mac/Linux:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys window windows | grep mFocusedApp</span><br></pre></td></tr></table></figure>
</li>
<li><p>Windows:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys window windows | findstr mFocusedApp</span><br></pre></td></tr></table></figure>

<p>会显示：</p>
<blockquote>
<p> mFocusedApp=AppWindowToken{29920155 token=Token{26b8340c ActivityRecord{1f97333f u0 com.android.settings/.Settings t2}}}</p>
<p>包名：com.android..settings   </p>
<p>界面名：.Settings</p>
</blockquote>
</li>
</ul>
</li>
<li><p>文件传输</p>
<p>1.发生文件到手机</p>
<p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb push 电脑的文件路径 手机的文件夹路径</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<blockquote>
<p>adb push C:\Users\hcy81\Desktop\33.txt /sdcard</p>
</blockquote>
<p>2.从手机拉取文件</p>
<p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb pull 手机的文件夹路径 电脑的文件路径</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<blockquote>
<p>adb pull /sdcard/33.txt C:\Users\hcy81\Desktop</p>
</blockquote>
</li>
<li><p>获取app启动时间</p>
<p>应用场景：</p>
<p>1.对启动时间有要求</p>
<p>2.测试标准：参照同类软件，启动时间不能超过一倍即可</p>
<p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell am start -W 包名/启动名</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<blockquote>
<p>作用：启动com.android.settings 程序进入界面（.Settings）</p>
<p>adb shell am start -W com.android.settings/.Settings</p>
</blockquote>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200608135029472.png" alt="image-20200608135029472"></p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200608135110433.png" alt="image-20200608135110433"></p>
</li>
<li><p>获取手机日志</p>
<p>应用场景：</p>
<p>将bug的日志文件发送给开发，便于定位bug</p>
<p>使用步骤：</p>
<p>1.打开需要测试的应用</p>
<p>2.找到触发的bug位置</p>
<p>3.使用查看日志的命令</p>
<p>4.触发bug</p>
<p>5.获取日志信息</p>
<p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb logcat</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他命令</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200608140431938.png" alt="image-20200608140431938"></p>
</li>
</ul>
<h2 id="appium"><a href="#appium" class="headerlink" title="appium"></a>appium</h2><h3 id="快速体验（启动参数）"><a href="#快速体验（启动参数）" class="headerlink" title="快速体验（启动参数）"></a>快速体验（启动参数）</h3><ol>
<li>打开手机模拟器</li>
<li>打开appium工具</li>
<li>创建py文件</li>
<li>将以下代码复制并运行即可</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">desired_caps = dict()</span><br><span class="line">desired_caps[<span class="string">'platformName'</span>] = <span class="string">'Android'</span></span><br><span class="line">desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'5.1'</span></span><br><span class="line">desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'192.168.79.102:5555'</span></span><br><span class="line">desired_caps[<span class="string">'appPackage'</span>] = <span class="string">'com.android.settings'</span></span><br><span class="line">desired_caps[<span class="string">'appActivity'</span>] = <span class="string">'.Settings'</span></span><br><span class="line">driver = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>,desired_caps)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200608141606092.png" alt="image-20200608141606092"></p>
<p>启动过程：</p>
<ol>
<li>appium的启动实际.上是在本机使用了4723端口开启了一个服务</li>
<li>我们写的python代码会访问本机的appium服务器，并获取driver对象</li>
<li>appium 会将我们的driver对象调用的方法转化成post请求，提交给appium服务器</li>
<li>appium 通过接收到的post请求发送给手机，再由手机进行执行</li>
</ol>
<h3 id="appium基础操作API"><a href="#appium基础操作API" class="headerlink" title="appium基础操作API"></a>appium基础操作API</h3><ol>
<li>能够使用appium在脚本内启动其他app</li>
<li>能够使用appium获取包名和界面名</li>
<li>能够使用appium关闭app和驱动对象</li>
<li>能够使用appium安装和卸輯app</li>
<li>能够使用appium将应用置于后台</li>
</ol>
<h4 id="在脚本内启动其他app"><a href="#在脚本内启动其他app" class="headerlink" title="在脚本内启动其他app"></a>在脚本内启动其他app</h4><p>应用场景：</p>
<p>如果一个应用需要跳转到另外-一个应用，就可以使用这个api进行应用的跳转，就像我们通过外卖应用下订单之后会跳转到支付应用一样。</p>
<p>方法名和参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#脚本启动其他app</span><br><span class="line">#参数：</span><br><span class="line">#	appPackage:要打开的包名</span><br><span class="line">#	appActivity:要打开的界面名</span><br><span class="line">driver.start_activity(appPackage,appActivity)</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<blockquote>
<p>打开设置5s后跳转到短信</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">desired_caps = dict()</span><br><span class="line">desired_caps[<span class="string">'platformName'</span>] = <span class="string">'Android'</span></span><br><span class="line">desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'5.1'</span></span><br><span class="line">desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'192.168.79.102:5555'</span></span><br><span class="line">desired_caps[<span class="string">'appPackage'</span>] = <span class="string">'com.android.settings'</span></span><br><span class="line">desired_caps[<span class="string">'appActivity'</span>] = <span class="string">'.Settings'</span></span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>,desired_caps)</span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">driver.start_activity(<span class="string">'com.android.mms'</span>,<span class="string">'.ui.ConversationList'</span>)</span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h3 id="获取app的包名和界面名"><a href="#获取app的包名和界面名" class="headerlink" title="获取app的包名和界面名"></a>获取app的包名和界面名</h3><p>应用场景：</p>
<p>当我们从一个应用跳转到另外-个应用的时候，想输出其包名、界面名或者想在报告中展现对应信息，我们就可以调用这个属性来进行获取。</p>
<p>属性名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取包名：</span><br><span class="line">driver.current_package</span><br><span class="line">#获取界面名：</span><br><span class="line">driver.current_activity</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<blockquote>
<p>打开设置后输出当前包名和应用名</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">desired_caps = dict()</span><br><span class="line">desired_caps[<span class="string">'platformName'</span>] = <span class="string">'Android'</span></span><br><span class="line">desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'5.1'</span></span><br><span class="line">desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'192.168.79.102:5555'</span></span><br><span class="line">desired_caps[<span class="string">'appPackage'</span>] = <span class="string">'com.android.settings'</span></span><br><span class="line">desired_caps[<span class="string">'appActivity'</span>] = <span class="string">'.Settings'</span></span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>,desired_caps)</span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(driver.current_package)</span><br><span class="line">print(driver.current_activity)</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h3 id="关闭app和驱动对象"><a href="#关闭app和驱动对象" class="headerlink" title="关闭app和驱动对象"></a>关闭app和驱动对象</h3><p>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#关闭当前的app，不会关闭驱动对象</span><br><span class="line">driver.close_app()</span><br><span class="line">#关闭驱动对象，同时关闭所以关联的app</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<blockquote>
<p>打开设置, 使用close. app()方法关闭，再尝试使用quit()方法，最后打印当前程序的包名，观察区别</p>
</blockquote>
<p>close_app:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from appium import webdriver</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">desired_caps = dict()</span><br><span class="line">desired_caps[&apos;platformName&apos;] = &apos;Android&apos;</span><br><span class="line">desired_caps[&apos;platformVersion&apos;] = &apos;5.1&apos;</span><br><span class="line">desired_caps[&apos;deviceName&apos;] = &apos;192.168.79.102:5555&apos;</span><br><span class="line">desired_caps[&apos;appPackage&apos;] = &apos;com.android.settings&apos;</span><br><span class="line">desired_caps[&apos;appActivity&apos;] = &apos;.Settings&apos;</span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(&apos;http://localhost:4723/wd/hub&apos;,desired_caps)</span><br><span class="line">time.sleep(3)</span><br><span class="line"></span><br><span class="line">driver.close_app()</span><br><span class="line">print(driver.current_package)</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200608145340436.png" alt="image-20200608145340436"></p>
<p>quit:(报错是因为driver对象消失)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from appium import webdriver</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">desired_caps = dict()</span><br><span class="line">desired_caps[&apos;platformName&apos;] = &apos;Android&apos;</span><br><span class="line">desired_caps[&apos;platformVersion&apos;] = &apos;5.1&apos;</span><br><span class="line">desired_caps[&apos;deviceName&apos;] = &apos;192.168.79.102:5555&apos;</span><br><span class="line">desired_caps[&apos;appPackage&apos;] = &apos;com.android.settings&apos;</span><br><span class="line">desired_caps[&apos;appActivity&apos;] = &apos;.Settings&apos;</span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(&apos;http://localhost:4723/wd/hub&apos;,desired_caps)</span><br><span class="line">time.sleep(3)</span><br><span class="line"></span><br><span class="line">driver.quit()</span><br><span class="line">print(driver.current_package)</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200608145514813.png" alt="image-20200608145514813"></p>
<h3 id="安装卸载以及确认是否安装app"><a href="#安装卸载以及确认是否安装app" class="headerlink" title="安装卸载以及确认是否安装app"></a>安装卸载以及确认是否安装app</h3><p>参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#安装app</span><br><span class="line">#参数：</span><br><span class="line">#	app_path:apk路径</span><br><span class="line">driver.install_app(app_path)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#卸载app</span><br><span class="line">#参数：</span><br><span class="line">#	app_id:app的包名</span><br><span class="line">driver.remove_app(app_id)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#判断是否安装app</span><br><span class="line">#参数：</span><br><span class="line">#	app_id:app的包名</span><br><span class="line">#返回值：</span><br><span class="line">#布尔值：true/false</span><br><span class="line">driver.is_app_installed(app_id)</span><br></pre></td></tr></table></figure>

<h3 id="将应用置于后台"><a href="#将应用置于后台" class="headerlink" title="将应用置于后台"></a>将应用置于后台</h3><p>应用场景：</p>
<p>银行类app会在进入后台一定时间后， 如果再回到前台也页面会重新输入密码，如果需要自动化测试这种功能,可以使用这个api进行测试。</p>
<p>参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#app放置到后台一定时间后再回到前台，模拟热启动(会自动返回前台)</span><br><span class="line">#参数：</span><br><span class="line">#seconds：后台停留时间</span><br><span class="line">driver.background_app(seconds)</span><br></pre></td></tr></table></figure>

<p>注意到：</p>
<blockquote>
<p> 热启动：表示进入后台回到前台，关机再开这种断电行为叫”冷启动“</p>
</blockquote>
<h2 id="UIAutomatorViewer"><a href="#UIAutomatorViewer" class="headerlink" title="UIAutomatorViewer"></a>UIAutomatorViewer</h2><p>能够使用UIAutomatorViewer获取元素的特征信息</p>
<h3 id="UIAutomatorViewer使用"><a href="#UIAutomatorViewer使用" class="headerlink" title="UIAutomatorViewer使用"></a>UIAutomatorViewer使用</h3><p>应用场景：</p>
<p>定位元素时必须根据元素的相关特征进行定位，而UIAutomatorViewer就是获取元素特征。</p>
<p>简介：</p>
<p>UIAutomatorViewer用来扫描和分析Android的UI控件的工具。</p>
<p>使用步骤：</p>
<ol>
<li>进入sdk目录下的目录</li>
<li>mac在tools/bin下，打开UIAutomatorViewer</li>
<li>Windows在tools/bin下，打开UIAutomatorViewer.bat</li>
<li>电脑连接真机或者模拟器</li>
<li>启动待测app</li>
<li>点击UIAutomatorViewer的左上角Device Screenshot</li>
<li>点击控件</li>
<li>查看右下角Node Detail相关信息</li>
</ol>
<p>示例：</p>
<p>查看《设置》应用程序右，上角“放大镜”按钮的”resource-id”</p>
<p>1.打开uiautomatorviewer</p>
<p>2.打开android模拟器</p>
<p>3.启动《设置》应用程序</p>
<p>4.点击Device Screenshot按钮</p>
<p>5.点击”放大镜”按钮</p>
<p>6.查看Node Detail中的”resource-id”信息</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200608153720261.png" alt="image-20200608153720261"></p>
<h3 id="元素定位操作API"><a href="#元素定位操作API" class="headerlink" title="元素定位操作API"></a>元素定位操作API</h3><p>应用场景：</p>
<p>计算机需要元素定位才能知道点击哪个位置。</p>
<p>步骤：</p>
<ol>
<li>打开uiautomatorviewer</li>
<li>打开模拟器</li>
<li>通过uiautomatorviewer获取node detail</li>
<li>通过元素定位api进行定位</li>
<li>进行元素的操作</li>
</ol>
<h4 id="定位一个元素"><a href="#定位一个元素" class="headerlink" title="定位一个元素"></a>定位一个元素</h4><p>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#通过id定位一个元素</span><br><span class="line">#参数</span><br><span class="line">#	id_value:元素的resource-id属性值</span><br><span class="line">#返回值：</span><br><span class="line">#	定位到单个元素</span><br><span class="line">driver.find_element_by_id(id_value)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#通过class_value定位一个元素</span><br><span class="line">#参数</span><br><span class="line">#	class_value:元素的class属性值</span><br><span class="line">#返回值：</span><br><span class="line">#	定位到单个元素</span><br><span class="line">driver.find_element_by_class_name(class_value)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#通过xpath_value定位一个元素</span><br><span class="line">#参数</span><br><span class="line">#	xpath_value:定位元素的xpath表达式</span><br><span class="line">#返回值：</span><br><span class="line">#	定位到单个元素</span><br><span class="line">driver.find_element_by_xpath(xpath_value)</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<blockquote>
<p>通过id定位“放大镜“，并点击</p>
<p>通过class定位输入框，输入”hello”</p>
<p>通过xpath定位“返回”，并点击</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">desired_caps = dict()</span><br><span class="line">desired_caps[<span class="string">'platformName'</span>] = <span class="string">'Android'</span></span><br><span class="line">desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'5.1'</span></span><br><span class="line">desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'192.168.79.102:5555'</span></span><br><span class="line">desired_caps[<span class="string">'appPackage'</span>] = <span class="string">'com.android.settings'</span></span><br><span class="line">desired_caps[<span class="string">'appActivity'</span>] = <span class="string">'.Settings'</span></span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>,desired_caps)</span><br><span class="line"></span><br><span class="line"><span class="comment">#id定位放大镜，点击</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"com.android.settings:id/search"</span>).click()</span><br><span class="line"><span class="comment">#class定位输入框，输入</span></span><br><span class="line">driver.find_element_by_class_name(<span class="string">"android.widget.EditText"</span>).send_keys(<span class="string">"hello"</span>)</span><br><span class="line"><span class="comment">#xpath定位返回，点击</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//*[@content-desc='收起']"</span>).click()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<p>tips:</p>
<blockquote>
<p>如果很多元素的“特征”相同的，使用find. element. .by. xx的方法会找到第一个</p>
</blockquote>
<h4 id="定位一组元素"><a href="#定位一组元素" class="headerlink" title="定位一组元素"></a>定位一组元素</h4><p>应用场景：</p>
<p>批量操作某个相同特征的元素，使用定位一组的方式更方便</p>
<p>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#通过id定位一组元素</span><br><span class="line">#参数</span><br><span class="line">#	id_value:元素的resource-id的属性值</span><br><span class="line">#返回值：</span><br><span class="line">#	列表，定位到的所以符合的元素</span><br><span class="line">driver.find_elements_by_id(id_value)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#通过class定位一组元素</span><br><span class="line">#参数</span><br><span class="line">#	class_value:元素的class的属性值</span><br><span class="line">#返回值：</span><br><span class="line">#	列表，定位到的所以符合的元素</span><br><span class="line">driver.find_elements_by_class_name(class_value)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#通过xpath定位一组元素</span><br><span class="line">#参数</span><br><span class="line">#	xpath_value:元素的xpath的属性值</span><br><span class="line">#返回值：</span><br><span class="line">#	列表，定位到的所以符合的元素</span><br><span class="line">driver.find_elements_by_xpath(xpath_value)</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<blockquote>
<p>通过id的形式，获取所有resource-id 为”com.android.settings:id/title”的元素，并打印其文字内容</p>
<p>通过class_ name的形式，获取所有class 为”android.widget.TextView”的元素，并打印其文字内容</p>
<p>通过xpath的形式，获取所有包含”设”的元素，并打印其文字内容</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">desired_caps = dict()</span><br><span class="line">desired_caps[<span class="string">'platformName'</span>] = <span class="string">'Android'</span></span><br><span class="line">desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'5.1'</span></span><br><span class="line">desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'192.168.79.102:5555'</span></span><br><span class="line">desired_caps[<span class="string">'appPackage'</span>] = <span class="string">'com.android.settings'</span></span><br><span class="line">desired_caps[<span class="string">'appActivity'</span>] = <span class="string">'.Settings'</span></span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>,desired_caps)</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过id的形式，获取所有resource-id 为"com.android.settings:id/title"的元素，并打印其文字内容</span></span><br><span class="line">titles = driver.find_elements_by_id(<span class="string">"com.android.settings:id/title"</span>)</span><br><span class="line">print(len(titles))</span><br><span class="line"><span class="keyword">for</span> title <span class="keyword">in</span> titles:</span><br><span class="line">    print(title.text)</span><br><span class="line"><span class="comment">#通过class_ name的形式，获取所有class 为"android.widget.TextView"的元素，并打印其文字内容</span></span><br><span class="line">text_views = driver.find_elements_by_class_name(<span class="string">"android.widget.TextView"</span>)</span><br><span class="line">print(len(text_views))</span><br><span class="line"><span class="keyword">for</span> text_view <span class="keyword">in</span> text_views:</span><br><span class="line">    print(text_view.text)</span><br><span class="line"><span class="comment">#通过xpath的形式，获取所有包含”设”的元素，并打印其文字内容</span></span><br><span class="line">words = driver.find_elements_by_xpath(<span class="string">"//*[contains(@text,'设')]"</span>)</span><br><span class="line">print(len(words))</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    print(word.text)</span><br><span class="line">    </span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h4 id="定位元素的注意点"><a href="#定位元素的注意点" class="headerlink" title="定位元素的注意点"></a>定位元素的注意点</h4><p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200608163409158.png" alt="image-20200608163409158"></p>
<h3 id="元素等待"><a href="#元素等待" class="headerlink" title="元素等待"></a>元素等待</h3><p>应用场景：</p>
<p>可能由于一些原因，我们想找到的元素并没有出来，会报错。</p>
<ol>
<li>网速原因</li>
<li>服务器处理的请求原因</li>
<li>电脑配置的原因</li>
</ol>
<p>概念：</p>
<p>webdriver定位页面元素如果未找到，会在指定时间内等待</p>
<blockquote>
<p>元素等待分为：</p>
<p>1.显示等待</p>
<p>2.隐式等待</p>
</blockquote>
<h4 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h4><p>应用场景：</p>
<p>针对所有的定位元素的超时时间设置为同一个值的时候</p>
<p>概念：</p>
<p>等待元素加载指定的时长，超出的时长抛出NoSuchElementException异常</p>
<p>步骤：</p>
<p>获取driver对象后，使用driver调用implicitly_wait 方法即可</p>
<p>参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from selenium.webdriver.support.wait import webDriverwait</span><br><span class="line">#seconds:等待秒数</span><br><span class="line">driver.implicitly_wait(seconds)</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<blockquote>
<p>20s内，在设置中找返回按钮，找到点击，没找到报错</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from appium import webdriver</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">desired_caps = dict()</span><br><span class="line">desired_caps[&apos;platformName&apos;] = &apos;Android&apos;</span><br><span class="line">desired_caps[&apos;platformVersion&apos;] = &apos;5.1&apos;</span><br><span class="line">desired_caps[&apos;deviceName&apos;] = &apos;192.168.79.102:5555&apos;</span><br><span class="line">desired_caps[&apos;appPackage&apos;] = &apos;com.android.settings&apos;</span><br><span class="line">desired_caps[&apos;appActivity&apos;] = &apos;.Settings&apos;</span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(&apos;http://localhost:4723/wd/hub&apos;,desired_caps)</span><br><span class="line"></span><br><span class="line">driver.implicitly_wait(20)</span><br><span class="line"></span><br><span class="line">print(&quot;--准备找返回--&quot;)</span><br><span class="line">driver.find_element_by_xpath(&quot;//*[@content-desc=&apos;收起&apos;]&quot;).click()</span><br><span class="line">print(&quot;--点完了--&quot;)</span><br><span class="line"></span><br><span class="line">time.sleep(3)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<p>如果找到，之间进行后续操作</p>
<p>规定时间内没找到则报错</p>
<h4 id="显示等待"><a href="#显示等待" class="headerlink" title="显示等待"></a>显示等待</h4><p>应用场景：</p>
<p>针对所有的定位元素的超时时间设置为不同的时候</p>
<p>概念：</p>
<p>等待元素加载指定的时长，超出的时长抛出NoSuchElementException异常</p>
<p>步骤：</p>
<p>1.导包</p>
<p>2.创建WebDriverWait对象</p>
<p>3.调用WebDriverWait对象的until方法</p>
<p>示例：</p>
<blockquote>
<p>5s内，每1秒在设置中找返回按钮，找到点击，没找到报错</p>
</blockquote>
<p>核心代码：</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200608170547645.png" alt="image-20200608170547645"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">desired_caps = dict()</span><br><span class="line">desired_caps[<span class="string">'platformName'</span>] = <span class="string">'Android'</span></span><br><span class="line">desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'5.1'</span></span><br><span class="line">desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'192.168.79.102:5555'</span></span><br><span class="line">desired_caps[<span class="string">'appPackage'</span>] = <span class="string">'com.android.settings'</span></span><br><span class="line">desired_caps[<span class="string">'appActivity'</span>] = <span class="string">'.Settings'</span></span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>,desired_caps)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">"--准备找返回--"</span>)</span><br><span class="line">wait = WebDriverWait(driver,<span class="number">5</span>,poll_frequency=<span class="number">1</span>)</span><br><span class="line">click_button = wait.until(<span class="keyword">lambda</span> x :x.find_element_by_xpath(<span class="string">"//*[@content-desc='收起']"</span>))</span><br><span class="line">click_button.click()</span><br><span class="line">print(<span class="string">"--点完了--"</span>)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h4 id="隐式等待和显示等待的选择"><a href="#隐式等待和显示等待的选择" class="headerlink" title="隐式等待和显示等待的选择"></a>隐式等待和显示等待的选择</h4><p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200608172521989.png" alt="image-20200608172521989"></p>
<h3 id="元素操作API"><a href="#元素操作API" class="headerlink" title="元素操作API"></a>元素操作API</h3><h4 id="点击元素"><a href="#点击元素" class="headerlink" title="点击元素"></a>点击元素</h4><p>方法名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#对element按钮进行点击操作</span><br><span class="line">element.click()</span><br></pre></td></tr></table></figure>

<h4 id="输入和清空输入框"><a href="#输入和清空输入框" class="headerlink" title="输入和清空输入框"></a>输入和清空输入框</h4><p>方法名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#对element输入框进行输入操作</span><br><span class="line">#参数：</span><br><span class="line">#value:输入的内容</span><br><span class="line">element.send_keys(value)</span><br><span class="line">#对element输入框进行清空操作</span><br><span class="line">element.clear()</span><br></pre></td></tr></table></figure>

<p>tips:</p>
<blockquote>
<p>默认输入中文是无效的，但不会报错，需要在前置代码增加两个参数</p>
<p>desired_caps [‘ unicodeKeyboard’] = True</p>
<p>desired_ caps [‘resetKeyboard’] = True</p>
</blockquote>
<h4 id="获取元素的文本内容"><a href="#获取元素的文本内容" class="headerlink" title="获取元素的文本内容"></a>获取元素的文本内容</h4><p>方法名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取element的文本内容</span><br><span class="line">#返回值</span><br><span class="line">#	控件的文本内容</span><br><span class="line">element.text</span><br></pre></td></tr></table></figure>

<h4 id="获取元素的位置和大小"><a href="#获取元素的位置和大小" class="headerlink" title="获取元素的位置和大小"></a>获取元素的位置和大小</h4><p>方法名：</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200608173738176.png" alt="image-20200608173738176"></p>
<h4 id="获取元素的属性值"><a href="#获取元素的属性值" class="headerlink" title="获取元素的属性值"></a>获取元素的属性值</h4><p>方法名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#对element进行点击操作</span><br><span class="line">#参数：</span><br><span class="line">#	value：要获取的属性名</span><br><span class="line">#返回值：</span><br><span class="line">#	根据属性名得到属性值</span><br><span class="line">element.get_attribute(value)#value:元素的属性</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">desired_caps = dict()</span><br><span class="line">desired_caps[<span class="string">'platformName'</span>] = <span class="string">'Android'</span></span><br><span class="line">desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'5.1'</span></span><br><span class="line">desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'192.168.79.102:5555'</span></span><br><span class="line">desired_caps[<span class="string">'appPackage'</span>] = <span class="string">'com.android.settings'</span></span><br><span class="line">desired_caps[<span class="string">'appActivity'</span>] = <span class="string">'.Settings'</span></span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>,desired_caps)</span><br><span class="line"></span><br><span class="line">eles = driver.find_elements_by_id(<span class="string">"com.android.settings:id/title"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> eles:</span><br><span class="line">    print(i.get_attribute(<span class="string">"enabled"</span>))</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<p>tips：</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200608175016380.png" alt="image-20200608175016380"></p>
<h3 id="滑动和拖拽事件"><a href="#滑动和拖拽事件" class="headerlink" title="滑动和拖拽事件"></a>滑动和拖拽事件</h3><p>应用场景：</p>
<p>我们在做自动化测试的时候，有些按钮是需要滑动几次屏幕后才会出现，此时，我们需要使用代码来模拟手指的滑动，也就是我们将要学习的滑动和拖拽事件。</p>
<h4 id="swipe滑动事件"><a href="#swipe滑动事件" class="headerlink" title="swipe滑动事件"></a>swipe滑动事件</h4><p>概念：</p>
<p>从一个坐标滑动到另外一个坐标位置，只能是两个点之间的滑动。</p>
<p>方法名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#参数：</span><br><span class="line">#	start_x:起点x</span><br><span class="line">#	start_y:起点y</span><br><span class="line">#	end_x:终点x</span><br><span class="line">#	end_y:终点y</span><br><span class="line">#	duration:滑动操作的持续时间，单位：ms</span><br><span class="line">driver.swipe(start_x,start_y,end_x,end_y,duration=None)</span><br></pre></td></tr></table></figure>

<p>tips:</p>
<blockquote>
<p>距离相等时，持续时间越短，惯性越大</p>
<p>持续时间相等时，滑动距离越大，实际滑动距离也越大</p>
</blockquote>
<h4 id="scroll滑动事件"><a href="#scroll滑动事件" class="headerlink" title="scroll滑动事件"></a>scroll滑动事件</h4><p>概念：</p>
<p>从一个元素滑动到另一个元素，直到页面自动停止</p>
<p>方法名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#参数：</span><br><span class="line">#	origin_el:	滑动开始的元素</span><br><span class="line">#	destination:	滑动解释的元素</span><br><span class="line">driver.scroll(origin_el,destination_el)</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save_button = driver.find_element_by_xpath(&quot;//*[@text=&apos;存储&apos;]&quot;)</span><br><span class="line">more_button = driver.find_element_by_xpath(&quot;//*[@text=&apos;更多&apos;]&quot;)</span><br><span class="line">driver.scroll(save_button,more_button)</span><br></pre></td></tr></table></figure>

<p>tips:</p>
<blockquote>
<p>不能设置持续事件，惯性大</p>
</blockquote>
<h4 id="drag-and-drop拖拽事件"><a href="#drag-and-drop拖拽事件" class="headerlink" title="drag_and_drop拖拽事件"></a>drag_and_drop拖拽事件</h4><p>概念：</p>
<p>从一个元素滑动到另一个元素，第二个元素替代第一个元素原本屏幕上的位置</p>
<p>方法名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#参数：</span><br><span class="line">#	origin_el:	滑动开始的元素</span><br><span class="line">#	destination:	滑动解释的元素</span><br><span class="line">driver.drag_and_drop(origin_el,destination_el)</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save_button = driver.find_element_by_xpath(&quot;//*[@text=&apos;存储&apos;]&quot;)</span><br><span class="line">more_button = driver.find_element_by_xpath(&quot;//*[@text=&apos;更多&apos;]&quot;)</span><br><span class="line">driver.drag_and_drop(save_button,more_button)</span><br></pre></td></tr></table></figure>

<p>tips:</p>
<blockquote>
<p>不能设置持续时间，没有惯性</p>
</blockquote>
<h4 id="滑动和拖拽事件的选择"><a href="#滑动和拖拽事件的选择" class="headerlink" title="滑动和拖拽事件的选择"></a>滑动和拖拽事件的选择</h4><p>滑动和拖拽无非就是考虑是否有惯性，以及传递的参数是‘元素’还是‘坐标’</p>
<p>分为以下四种情况：</p>
<ul>
<li><p>有惯性，传入元素</p>
<p>scroll</p>
</li>
<li><p>无惯性，传入元素</p>
<p>drag_and_drop</p>
</li>
<li><p>有惯性，传入坐标</p>
<p>swipe,并设置较短duration时间</p>
</li>
<li><p>无惯性，传入坐标</p>
<p>swipe,并设置较长duration时间</p>
</li>
</ul>
<h3 id="高级手势TouchAction"><a href="#高级手势TouchAction" class="headerlink" title="高级手势TouchAction"></a>高级手势TouchAction</h3><p>应用场景：</p>
<p>TouchAction可以实现一些针对手势的操作,比如滑动、长按、拖动等。我们可以将这些基本手势组合成-一个相对复杂的手势。比如，我们解锁手机或者一些应用软件都有手势解锁的这种方式。</p>
<p>使用步骤：</p>
<ol>
<li>创建TouchAction对象</li>
<li>通过对象调用想执行的手势</li>
<li>通过perform()执行动作</li>
</ol>
<h4 id="手指轻巧操作"><a href="#手指轻巧操作" class="headerlink" title="手指轻巧操作"></a>手指轻巧操作</h4><p>应用场景：</p>
<p>模拟手指对某个元素或坐标按下并快速抬起。比如，固定点击(100, 100)的位置。</p>
<p>方法名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#参数</span><br><span class="line">#	element：元素</span><br><span class="line">#	x:x坐标</span><br><span class="line">#	y:y坐标</span><br><span class="line">TouchAction(driver).tap(element=None,X=None,Y=None，count=1).perform()</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from appium import webdriver</span><br><span class="line">import time</span><br><span class="line">from appium.webdriver.common.touch_action import TouchAction</span><br><span class="line">desired_caps = dict()</span><br><span class="line">desired_caps[&apos;platformName&apos;] = &apos;Android&apos;</span><br><span class="line">desired_caps[&apos;platformVersion&apos;] = &apos;5.1&apos;</span><br><span class="line">desired_caps[&apos;deviceName&apos;] = &apos;192.168.79.102:5555&apos;</span><br><span class="line">desired_caps[&apos;appPackage&apos;] = &apos;com.android.settings&apos;</span><br><span class="line">desired_caps[&apos;appActivity&apos;] = &apos;.Settings&apos;</span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(&apos;http://localhost:4723/wd/hub&apos;,desired_caps)</span><br><span class="line"></span><br><span class="line">wlan_button = driver.find_element_by_xpath(&quot;//*[@text=&apos;WLAN&apos;]&quot;)</span><br><span class="line">TouchAction(driver).tap(wlan_button).perform()</span><br><span class="line"></span><br><span class="line">time.sleep(3)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h4 id="按下和抬起的操作"><a href="#按下和抬起的操作" class="headerlink" title="按下和抬起的操作"></a>按下和抬起的操作</h4><p>应用场景：</p>
<p>模拟手指一直按下，模拟手指抬起。可以模拟轻巧和长按操作</p>
<p>方法名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#按下</span><br><span class="line">#参数</span><br><span class="line">#	element：元素</span><br><span class="line">#	x:x坐标</span><br><span class="line">#	y:y坐标</span><br><span class="line">TouchAction(driver).press(element=None,X=None,Y=None，count=1).perform()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#抬起</span><br><span class="line">TouchAction(driver).release().perform()</span><br></pre></td></tr></table></figure>

<h4 id="等待操作"><a href="#等待操作" class="headerlink" title="等待操作"></a>等待操作</h4><p>方法名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#模拟手指暂停的操作</span><br><span class="line">#参数：</span><br><span class="line">#ms:毫秒</span><br><span class="line">TouchAction(driver).wait(ms=0).perform()</span><br></pre></td></tr></table></figure>

<h4 id="长按操作"><a href="#长按操作" class="headerlink" title="长按操作"></a>长按操作</h4><p>方法名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#参数</span><br><span class="line">#	element：元素</span><br><span class="line">#	x:x坐标</span><br><span class="line">#	y:y坐标</span><br><span class="line">#	duration:	长按时长，毫秒</span><br><span class="line">TouchAction(driver).long_press(element=None,X=None,Y=None，duration=0).perform()</span><br></pre></td></tr></table></figure>

<h4 id="移动操作"><a href="#移动操作" class="headerlink" title="移动操作"></a>移动操作</h4><p>方法名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#参数</span><br><span class="line">#	element：元素</span><br><span class="line">#	x:x坐标</span><br><span class="line">#	y:y坐标</span><br><span class="line">TouchAction(driver).move_to(element=None,x=None,y=None).perform()</span><br></pre></td></tr></table></figure>

<h3 id="手机操作API"><a href="#手机操作API" class="headerlink" title="手机操作API"></a>手机操作API</h3><h4 id="获取手机的分辨率"><a href="#获取手机的分辨率" class="headerlink" title="获取手机的分辨率"></a>获取手机的分辨率</h4><p>应用场景：</p>
<p>自动化测试可能会需要根据当前设备的屏幕分辨率来计算一些点击或者滑动的坐标。</p>
<p>方法名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取手机分辨率</span><br><span class="line">#返回值：字典&#123;&apos;height&apos;:800,&apos;width&apos;480&#125;</span><br><span class="line">driver.get_window_size()</span><br></pre></td></tr></table></figure>

<h4 id="手机截图"><a href="#手机截图" class="headerlink" title="手机截图"></a>手机截图</h4><p>方法名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#截图</span><br><span class="line">#参数：</span><br><span class="line">#	filename：指定路径，指定格式</span><br><span class="line">get_screenshot_as_file(filename)</span><br></pre></td></tr></table></figure>

<p>示例</p>
<blockquote>
<p>1.打开设置页面</p>
<p>2.截图保村screenshot.jpg</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#截图</span><br><span class="line">driver.get_screenshot_as_file(&quot;screenshot.jpg&quot;)</span><br></pre></td></tr></table></figure>

<h4 id="获取和设置手机网络"><a href="#获取和设置手机网络" class="headerlink" title="获取和设置手机网络"></a>获取和设置手机网络</h4><h5 id="获取手机网络"><a href="#获取手机网络" class="headerlink" title="获取手机网络"></a>获取手机网络</h5><p>方法名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#获取手机网络</span><br><span class="line">driver.network_connection</span><br></pre></td></tr></table></figure>

<p>对照表：</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200608202840720.png" alt="image-20200608202840720"></p>
<h5 id="设置手机网络"><a href="#设置手机网络" class="headerlink" title="设置手机网络"></a>设置手机网络</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#设置手机网络</span><br><span class="line">driver.set_network_connection(connectionType)</span><br></pre></td></tr></table></figure>

<p>tips:</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200608203303230.png" alt="image-20200608203303230"></p>
<h4 id="发送键到设备"><a href="#发送键到设备" class="headerlink" title="发送键到设备"></a>发送键到设备</h4><p>应用场景：</p>
<p>模拟按“返回键””home键”等等操作，比如，很多应用有按两次返回键退出应用的功能，如果这个功能需要我们做自动化，那么一定会用到这个方法。</p>
<p>方法名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#参数</span><br><span class="line">#	keycode:发送给设备的关键代码</span><br><span class="line">#	metastate:关于被发送代码的元信息，一般默认</span><br><span class="line">driver.press_keycode(keycode,metastate=None)</span><br></pre></td></tr></table></figure>

<p>tips:</p>
<blockquote>
<p>按键对应编码</p>
<p><a href="https://blog.csdn.net/feizhixuan46789/article/details/16801429" target="_blank" rel="noopener">https://blog.csdn.net/feizhixuan46789/article/details/16801429</a></p>
</blockquote>
<h4 id="操作手机的通知栏"><a href="#操作手机的通知栏" class="headerlink" title="操作手机的通知栏"></a>操作手机的通知栏</h4><p>应用场景：</p>
<p>测试即时通信类软件的时候，如果A给B发送一条消息，B的通知栏肯定会显示对应的消息。我们想通过通知栏来判断B是否收到消息，一定要先操作手机的通知栏。</p>
<p>方法名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#打开通知栏</span><br><span class="line">driver.open_notifications()</span><br></pre></td></tr></table></figure>

<p>tips:</p>
<blockquote>
<p>appium官方并没有为我们提供关闭通知的api,那么现实生活中怎么关闭，就怎样操作就行，比如，手指从下往上滑动，或者，按返回键</p>
</blockquote>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#打开通知栏，按下返回键</span><br><span class="line">driver.open_notifications()</span><br><span class="line">time.sleep(3)</span><br><span class="line">driver.press_keycode(4)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
        <tag>adb</tag>
        <tag>appium</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言模拟实现文件复制的操作</title>
    <url>/posts/c-file-copy.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：此为在Linux中采取程序设计来模拟实现系统中文件复制的操作，进一步了解Linux系统中的操作。</p>
<a id="more"></a>

<p>编写要求：</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200318215453.png" alt></p>
<p>接着我们直接上代码吧！直接在里面解释</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 512</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//以下为创建所需要使用的变量，fd为句柄，return为返回值，buf为缓冲区，tips用来存储输入。</span></span><br><span class="line">	<span class="keyword">int</span> read_fd = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> write_fd = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> read_return = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> write_return = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> tips[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> access_return = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> stat_return = <span class="number">-1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">bs</span>;</span>	<span class="comment">//创建stat结构体</span></span><br><span class="line">	</span><br><span class="line">	access_return = access(argv[<span class="number">1</span>],F_OK | R_OK);  <span class="comment">//使用access函数来获取文件权限和存在状态。</span></span><br><span class="line">	<span class="keyword">if</span>(access_return == <span class="number">0</span>)</span><br><span class="line">		read_fd = open(argv[<span class="number">1</span>],O_RDONLY);   <span class="comment">//当返回值为0时执行读文件</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Open file error.\n"</span>);	<span class="comment">//否则提示错误并退出</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(&amp;bs, <span class="number">0</span> , <span class="keyword">sizeof</span>(bs));	<span class="comment">//清空结构体</span></span><br><span class="line">	</span><br><span class="line">	stat_return = stat(argv[<span class="number">1</span>],&amp;bs);	<span class="comment">//利用stat获取文件信息</span></span><br><span class="line">	access_return = access(argv[<span class="number">2</span>],F_OK);	<span class="comment">//利用access获取第二个文件是否存在</span></span><br><span class="line">	<span class="keyword">if</span>(access_return &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;	<span class="comment">//不存在则创建新文件</span></span><br><span class="line">		write_fd = open(argv[<span class="number">2</span>],O_CREAT |O_RDWR,bs.st_mode);	</span><br><span class="line">		<span class="keyword">if</span>(write_fd &lt; <span class="number">0</span>)</span><br><span class="line">		&#123;	<span class="comment">//如果创建失败则退出</span></span><br><span class="line">			close(read_fd);</span><br><span class="line">			close(access_return);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Create file error.\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;	<span class="comment">//如果存在则询问是否重写</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Warning!Overwrite this file? yes/no?\n"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">" &gt; "</span>);</span><br><span class="line">		gets(tips);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strcmp</span>(tips,<span class="string">"yes"</span>) == <span class="number">0</span>)	<span class="comment">//输入存入tips，如果为tips则重新</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"reading...\n"</span>);</span><br><span class="line">			write_fd = open(argv[<span class="number">2</span>],O_RDWR);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;	<span class="comment">//如果输入不为tips则退出</span></span><br><span class="line">			close(read_fd);</span><br><span class="line">			close(access_return);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Good bye!See you next time.\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	read_return = read(read_fd, buf, <span class="keyword">sizeof</span>(buf));	<span class="comment">//使用read读取文件内容</span></span><br><span class="line">	<span class="keyword">while</span>( read_return &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		write_return = write(write_fd, buf, read_return);	<span class="comment">//使用write写入文件</span></span><br><span class="line">		<span class="keyword">if</span> (write_return &lt; read_return)		<span class="comment">//判断写入的字节是否小于读取的字节，小于则退出并提示写入失败</span></span><br><span class="line">		&#123;</span><br><span class="line">			close(read_fd);</span><br><span class="line">			close(write_fd);</span><br><span class="line">			close(access_return);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Write file error.\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(buf, <span class="number">0</span> ,<span class="keyword">sizeof</span>(buf));	<span class="comment">//清空buf缓冲区</span></span><br><span class="line">		read_return = read(read_fd, buf, <span class="keyword">sizeof</span>(buf));	<span class="comment">//再一次读取文件</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//输出文件的大小</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"It has been copied.This file size is %lld bytes.\n"</span>,bs.st_size);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//关闭各个句柄</span></span><br><span class="line">	close(access_return);</span><br><span class="line">	close(read_fd);</span><br><span class="line">	close(write_fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>大家可以参考<a href="https://hongcyu.cn/posts/Linux-file-readandwrite.html">Linux下文件读写的操作</a>里面的函数解释~</p>
</blockquote>
]]></content>
      <categories>
        <category>C语言</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>Linux</tag>
        <tag>程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Fedora下yum命令的学习</title>
    <url>/posts/Fedora_yum.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：在这里介绍一下yum命令的使用，并进行基本的操作。</p>
<a id="more"></a>

<ol>
<li><p><strong>查看操作</strong>：输入yum list 可以查看仓库中所有的包文件列表。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200229144438.png" alt></p>
</li>
<li><p><strong>移除操作</strong>： 输入sudo yum remove &lt;包名&gt;</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200229144704.png" alt></p>
</li>
<li><p><strong>安装操作</strong>：sudo yum install  &lt;包名&gt;</p>
</li>
<li><p><strong>更新操作</strong>：yum update &lt;包名&gt;</p>
</li>
<li><p><strong>检测更新</strong>：yum check-update &lt;包名&gt;</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Fedora</category>
      </categories>
      <tags>
        <tag>Fedora</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title>Fedora安装后的配置</title>
    <url>/posts/fedora-2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：在Fedora系统安装后还需要一些配置才能正常使用。</p>
<a id="more"></a>

<h2 id="添加sudo用户"><a href="#添加sudo用户" class="headerlink" title="添加sudo用户"></a>添加sudo用户</h2><p>现在操作系统里面，我们不允许管理员作为普通用户进行登入。但是有很多操作需要管理员授权，所以Linux给出了一种解决方法就是sudo用户来做。</p>
<p>sudo: superuser do(超级用户在做)</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[hongcyu@localhost 桌面] $ sudo passwd</span><br></pre></td></tr></table></figure>

<p>这样做的好处就是不要使用管理员的口令，大大增加了系统的安全性。</p>
<p>在ubantu系统中默认sudo用户是可用的，而fedora却默认是不可用的，一般按下面的操作</p>
<p>先进入管理员做最初的设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ su</span><br><span class="line">密码： </span><br><span class="line">[root@localhost 桌面]#</span><br></pre></td></tr></table></figure>

<p>可以看到区别：$  变成了  #</p>
<p>接着我们执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#visudo</span><br></pre></td></tr></table></figure>

<p>此时会打开一个文件，只能看不能改，但是visudo才能修改</p>
<p>接着我们找到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">root    ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure>

<p>下root下方添加自己的用户名</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hongcyu ALL=(ALL)       ALL</span><br></pre></td></tr></table></figure>

<p>按ESC输入   :w  进行保存</p>
<h2 id="手动修改软件源"><a href="#手动修改软件源" class="headerlink" title="手动修改软件源"></a>手动修改软件源</h2><p>进入/etc 目录</p>
<p>etc目录一个很重要的目录，许多系统配置是在这个目录下的，找到图中圈出的文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/Linux-1.jpg" alt></p>
<p>进入这个目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd yum.repos.d</span><br></pre></td></tr></table></figure>

<p>输入ls -l即可看见配置文件，默认的后缀是repo</p>
<p>我们先打开一个文件进行查看 可以看到如图所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vi fedora.repo</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/Linux-2.jpg" alt></p>
<p>第三行的baseurl是非常重要的，因为以后下载都会从这个网址进行查找后下载。</p>
<ol>
<li>复制以下到<code>/etc/yum.repos.d/fedora.repo</code> 文件：</li>
</ol>
<p>​       遇到不可保存的情况可以使用  <strong>$ sudo vi fedora.repo</strong>  来进行编辑，之后类似。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[fedora]</span><br><span class="line">name=Fedora $releasever - $basearch</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=https://mirrors.ustc.edu.cn/fedora/releases/$releasever/Everything/$basearch/os/</span><br><span class="line">#metalink=https://mirrors.fedoraproject.org/metalink?repo=fedora-$releasever&amp;arch=$basearch</span><br><span class="line">enabled=1</span><br><span class="line">metadata_expire=7d</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">type=rpm</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$releasever-$basearch</span><br><span class="line">skip_if_unavailable=False</span><br><span class="line"></span><br><span class="line">[fedora-debuginfo]</span><br><span class="line">name=Fedora $releasever - $basearch - Debug</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=https://mirrors.ustc.edu.cn/fedora/releases/$releasever/Everything/$basearch/debug/tree/</span><br><span class="line">#metalink=https://mirrors.fedoraproject.org/metalink?repo=fedora-debug-$releasever&amp;arch=$basearch</span><br><span class="line">enabled=0</span><br><span class="line">metadata_expire=7d</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">type=rpm</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$releasever-$basearch</span><br><span class="line">skip_if_unavailable=False</span><br><span class="line"></span><br><span class="line">[fedora-source]</span><br><span class="line">name=Fedora $releasever - Source</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=https://mirrors.ustc.edu.cn/fedora/releases/$releasever/Everything/source/tree/</span><br><span class="line">#metalink=https://mirrors.fedoraproject.org/metalink?repo=fedora-source-$releasever&amp;arch=$basearch</span><br><span class="line">enabled=0</span><br><span class="line">metadata_expire=7d</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">type=rpm</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$releasever-$basearch</span><br><span class="line">skip_if_unavailable=False</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>/etc/yum.repos.d/fedora-updates.repo</code> 文件：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[updates]</span><br><span class="line">name=Fedora $releasever - $basearch - Updates</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=https://mirrors.ustc.edu.cn/fedora/updates/$releasever/Everything/$basearch/</span><br><span class="line">#metalink=https://mirrors.fedoraproject.org/metalink?repo=updates-released-f$releasever&amp;arch=$basearch</span><br><span class="line">enabled=1</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">type=rpm</span><br><span class="line">gpgcheck=1</span><br><span class="line">metadata_expire=6h</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$releasever-$basearch</span><br><span class="line">skip_if_unavailable=False</span><br><span class="line"></span><br><span class="line">[updates-debuginfo]</span><br><span class="line">name=Fedora $releasever - $basearch - Updates - Debug</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=https://mirrors.ustc.edu.cn/fedora/updates/$releasever/Everything/$basearch/debug/</span><br><span class="line">#metalink=https://mirrors.fedoraproject.org/metalink?repo=updates-released-debug-f$releasever&amp;arch=$basearch</span><br><span class="line">enabled=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">type=rpm</span><br><span class="line">gpgcheck=1</span><br><span class="line">metadata_expire=6h</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$releasever-$basearch</span><br><span class="line">skip_if_unavailable=False</span><br><span class="line"></span><br><span class="line">[updates-source]</span><br><span class="line">name=Fedora $releasever - Updates Source</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=https://mirrors.ustc.edu.cn/fedora/updates/$releasever/Everything/SRPMS/</span><br><span class="line">#metalink=https://mirrors.fedoraproject.org/metalink?repo=updates-released-source-f$releasever&amp;arch=$basearch</span><br><span class="line">enabled=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">type=rpm</span><br><span class="line">gpgcheck=1</span><br><span class="line">metadata_expire=6h</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$releasever-$basearch</span><br><span class="line">skip_if_unavailable=False</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>/etc/yum.repos.d/fedora-modular.repo</code> 文件：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[fedora-modular]</span><br><span class="line">name=Fedora Modular $releasever - $basearch</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=https://mirrors.ustc.edu.cn/fedora/releases/$releasever/Modular/$basearch/os/</span><br><span class="line">#metalink=https://mirrors.fedoraproject.org/metalink?repo=fedora-modular-$releasever&amp;arch=$basearch</span><br><span class="line">enabled=1</span><br><span class="line">#metadata_expire=7d</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">type=rpm</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$releasever-$basearch</span><br><span class="line">skip_if_unavailable=False</span><br><span class="line"></span><br><span class="line">[fedora-modular-debuginfo]</span><br><span class="line">name=Fedora Modular $releasever - $basearch - Debug</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=https://mirrors.ustc.edu.cn/fedora/releases/$releasever/Modular/$basearch/debug/tree/</span><br><span class="line">#metalink=https://mirrors.fedoraproject.org/metalink?repo=fedora-modular-debug-$releasever&amp;arch=$basearch</span><br><span class="line">enabled=0</span><br><span class="line">metadata_expire=7d</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">type=rpm</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$releasever-$basearch</span><br><span class="line">skip_if_unavailable=False</span><br><span class="line"></span><br><span class="line">[fedora-modular-source]</span><br><span class="line">name=Fedora Modular $releasever - Source</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=https://mirrors.ustc.edu.cn/fedora/releases/$releasever/Modular/source/tree/</span><br><span class="line">#metalink=https://mirrors.fedoraproject.org/metalink?repo=fedora-modular-source-$releasever&amp;arch=$basearch</span><br><span class="line">enabled=0</span><br><span class="line">metadata_expire=7d</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">type=rpm</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$releasever-$basearch</span><br><span class="line">skip_if_unavailable=False</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>/etc/yum.repos.d/fedora-updates-modular.repo</code> 文件：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[updates-modular]</span><br><span class="line">name=Fedora Modular $releasever - $basearch - Updates</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=https://mirrors.ustc.edu.cn/fedora/updates/$releasever/Modular/$basearch/</span><br><span class="line">#metalink=https://mirrors.fedoraproject.org/metalink?repo=updates-released-modular-f$releasever&amp;arch=$basearch</span><br><span class="line">enabled=1</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">type=rpm</span><br><span class="line">gpgcheck=1</span><br><span class="line">metadata_expire=6h</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$releasever-$basearch</span><br><span class="line">skip_if_unavailable=False</span><br><span class="line"></span><br><span class="line">[updates-modular-debuginfo]</span><br><span class="line">name=Fedora Modular $releasever - $basearch - Updates - Debug</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=https://mirrors.ustc.edu.cn/fedora/updates/$releasever/Modular/$basearch/debug/</span><br><span class="line">#metalink=https://mirrors.fedoraproject.org/metalink?repo=updates-released-modular-debug-f$releasever&amp;arch=$basearch</span><br><span class="line">enabled=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">type=rpm</span><br><span class="line">gpgcheck=1</span><br><span class="line">metadata_expire=6h</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$releasever-$basearch</span><br><span class="line">skip_if_unavailable=False</span><br><span class="line"></span><br><span class="line">[updates-modular-source]</span><br><span class="line">name=Fedora Modular $releasever - Updates Source</span><br><span class="line">failovermethod=priority</span><br><span class="line">baseurl=https://mirrors.ustc.edu.cn/fedora/updates/$releasever/Modular/SRPMS/</span><br><span class="line">#metalink=https://mirrors.fedoraproject.org/metalink?repo=updates-released-modular-source-f$releasever&amp;arch=$basearch</span><br><span class="line">enabled=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">type=rpm</span><br><span class="line">gpgcheck=1</span><br><span class="line">metadata_expire=6h</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$releasever-$basearch</span><br><span class="line">skip_if_unavailable=False</span><br></pre></td></tr></table></figure>

<p>最后运行 <code>sudo dnf makecache</code> 生成缓存。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/Linux-3.jpg" alt></p>
<h2 id="自动修改软件源"><a href="#自动修改软件源" class="headerlink" title="自动修改软件源"></a>自动修改软件源</h2><p>用以下命令替换 <code>/etc/yum.repos.d</code> 下的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo sed -e &apos;s|^metalink=|#metalink=|g&apos; \</span><br><span class="line">         -e &apos;s|^#baseurl=http://download.fedoraproject.org/pub/fedora/linux|baseurl=https://mirrors.ustc.edu.cn/fedora|g&apos; \</span><br><span class="line">         -i.bak \</span><br><span class="line">         /etc/yum.repos.d/fedora.repo \</span><br><span class="line">         /etc/yum.repos.d/fedora-modular.repo \</span><br><span class="line">         /etc/yum.repos.d/fedora-updates.repo \</span><br><span class="line">         /etc/yum.repos.d/fedora-updates-modular.repo</span><br></pre></td></tr></table></figure>

<p>参考网址： <a href="http://mirrors.ustc.edu.cn/help/fedora.html" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/help/fedora.html</a></p>
]]></content>
      <categories>
        <category>Fedora</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Fedora</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客引用B站视频并自动适配</title>
    <url>/posts/hexo-bilibili.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：此次研究的是hexo博客next主题下的B站视频适配问题，其他主题的博客也可参考此教程进行操作。</p>
<a id="more"></a>

<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在进行引用B站用iframe方式引入视频时发现，通过默认的方式导入会使得屏幕很小</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200307095024.png" alt></p>
<iframe src="//player.bilibili.com/player.html?aid=81148317&cid=138878361&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>


<p>一般我们都是自己改width和height来修改大小，但是换成不同的设备就无法正常的显示了。如下</p>
<p>默认：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"//player.bilibili.com/player.html?aid=81148317&amp;cid=138878361&amp;page=1"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">framespacing</span>=<span class="string">"0"</span> <span class="attr">allowfullscreen</span>=<span class="string">"true"</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改后：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"//player.bilibili.com/player.html?aid=81148317&amp;cid=138878361&amp;page=1"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">framespacing</span>=<span class="string">"0"</span> <span class="attr">allowfullscreen</span>=<span class="string">"true"</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"720"</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>即可较好的适配大屏幕，但是到手机上就不太好用了，不能自动适配，怎么办呢，看下面的两种办法：</p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>外面包裹一个div标签，div标签自适应与屏幕的大小，包裹内iframe以100%顶边撑开。</p>
<p>以next主题为例子：在<code>next\source\css\_custom\custom.styl</code>下底部添加以下css代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*哔哩哔哩视频适配*/</span></span><br><span class="line"><span class="selector-class">.bilibili</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;              <span class="comment">/*高度设置这里无效，设置为0，用padding撑开div*/</span></span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">75%</span>;    <span class="comment">/*68%到80%都可以*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bilibili</span> <span class="selector-tag">iframe</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入时写成如下形式即可：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bilibili"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"//player.bilibili.com/player.html?aid=81148317&amp;cid=138878361&amp;page=1"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">framespacing</span>=<span class="string">"0"</span> <span class="attr">allowfullscreen</span>=<span class="string">"true"</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<div class="video">
<iframe src="//player.bilibili.com/player.html?aid=81148317&cid=138878361&page=1&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"> </iframe>
</div>



<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>使用@media属性，对不同屏幕大小的设备，设置宽度和高度。</p>
<p>@media可以查询到设备的以下属性</p>
<ol>
<li>设备屏幕的高度</li>
<li>设备的方向（如移动设备横屏）</li>
<li>可视窗口的宽高</li>
<li>屏幕解析度</li>
</ol>
<p>和上面一样，在指定位置插入css代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*哔哩哔哩视频适配*/</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.bilibili</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> only screen and (max-width: <span class="number">767px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.bilibili</span> &#123;<span class="attribute">height</span>: <span class="number">15em</span>;<span class="attribute">max-width</span>: <span class="number">25em</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> only screen and (min-width: <span class="number">768px</span>) and (max-width: <span class="number">991px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.bilibili</span> &#123;<span class="attribute">height</span>: <span class="number">20em</span>;<span class="attribute">max-width</span>: <span class="number">30em</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> only screen and (min-width: <span class="number">992px</span>) and (max-width: <span class="number">1199px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.bilibili</span> &#123;<span class="attribute">height</span>: <span class="number">30em</span>;<span class="attribute">max-width</span>: <span class="number">40em</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> only screen and (min-width: <span class="number">1200px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.bilibili</span> &#123;<span class="attribute">height</span>: <span class="number">40em</span>;<span class="attribute">max-width</span>: <span class="number">50em</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后直接引用B站的iframe代码加上<code>class=&quot;bilibili&quot;</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">class</span>=<span class="string">"bilibili"</span> <span class="attr">src</span>=<span class="string">"//player.bilibili.com/player.html?aid=81148317&amp;cid=138878361&amp;page=1"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">framespacing</span>=<span class="string">"0"</span> <span class="attr">allowfullscreen</span>=<span class="string">"true"</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<iframe class="bilibili" src="//player.bilibili.com/player.html?aid=81148317&cid=138878361&page=1&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"> </iframe>


<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><h3 id="B站链接的参数"><a href="#B站链接的参数" class="headerlink" title="B站链接的参数"></a>B站链接的参数</h3><p>player.bilibili.com/player.html?aid=81148317&amp;cid=138878361&amp;page=1</p>
<table>
<thead>
<tr>
<th align="center">key</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">aid</td>
<td align="center">视频ID 就是B站的av号</td>
</tr>
<tr>
<td align="center">cid</td>
<td align="center">应该是客户端的id,clientid的缩写（推测） 测试表示不填也不会有什么问题</td>
</tr>
<tr>
<td align="center">page</td>
<td align="center">第几个视频 也就是分P的 默认是1</td>
</tr>
<tr>
<td align="center">as_wide</td>
<td align="center">是否宽屏 1：宽屏  0：小屏</td>
</tr>
<tr>
<td align="center">high_quality</td>
<td align="center">视频质量 1：最高视频质量  0：最低视频质量</td>
</tr>
<tr>
<td align="center">danmaku</td>
<td align="center">是否开启弹幕 1：开启（默认）  0：关闭</td>
</tr>
</tbody></table>
<h3 id="阻止跳转B站"><a href="#阻止跳转B站" class="headerlink" title="阻止跳转B站"></a>阻止跳转B站</h3><p>在网页上, 用户选择清晰度, 或者点击视频上面的一些图标, 会跳转到B站. 这个可通过设置 iframe 的 sandbox 属性去禁止<br><code>sandbox=&quot;allow-top-navigation allow-same-origin allow-forms allow-scripts&quot;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"//player.bilibili.com/player.html?aid=81148317&amp;cid=138878361&amp;page=1"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">framespacing</span>=<span class="string">"0"</span> <span class="attr">allowfullscreen</span>=<span class="string">"true"</span> <span class="attr">sandbox</span>=<span class="string">“allow-top-navigation</span> <span class="attr">allow-same-origin</span> <span class="attr">allow-forms</span> <span class="attr">allow-scripts</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="修改默认视频质量"><a href="#修改默认视频质量" class="headerlink" title="修改默认视频质量"></a>修改默认视频质量</h3><p>B站默认视频质量是最低的，可以通过在src链接后面添加<code>&amp;high_quality=1</code>来设置</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"//player.bilibili.com/player.html?aid=81148317&amp;cid=138878361&amp;page=1&amp;high_quality=1"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">framespacing</span>=<span class="string">"0"</span> <span class="attr">allowfullscreen</span>=<span class="string">"true"</span> <span class="attr">sandbox</span>=<span class="string">“allow-top-navigation</span> <span class="attr">allow-same-origin</span> <span class="attr">allow-forms</span> <span class="attr">allow-scripts</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：<a href="https://www.phenxso.com/archives/87.html" target="_blank" rel="noopener">https://www.phenxso.com/archives/87.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客文章链接优化</title>
    <url>/posts/hexo-link.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：将Hexo博客的文章链接进行优化，使其不再是日期+标题，而改成随机数字或自定义。</p>
<a id="more"></a>

<p>URL 地址对于 SEO 中挺重要的，那么如何对链接进行个性化，并在后面加上 <code>.html</code> 显得更加正式呢。</p>
<p>Hexo 版本：3.x</p>
<h2 id="博客网址链接-URL-唯一且永久化"><a href="#博客网址链接-URL-唯一且永久化" class="headerlink" title="博客网址链接 URL 唯一且永久化"></a>博客网址链接 URL 唯一且永久化</h2><p>使用插件  <a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">https://github.com/rozbo/hexo-abbrlink</a>  可以做到自定义文章链接，安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>

<p>然后在 Hexo 的<strong>根目录</strong>的配置文件<code>_config.yml</code> 中修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#我的配置，post为固定链接后面带&quot;:&quot;的为变量</span><br><span class="line">permalink: posts/:abbrlink.html</span><br><span class="line"></span><br><span class="line">#abbrlinks</span><br><span class="line">abbrink:</span><br><span class="line">  alg: crc32</span><br><span class="line">  rep: dec</span><br></pre></td></tr></table></figure>

<p>之后再在 md 文件开头中加入以下信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">abbrlink: seourl</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>如果文章中未指定 <code>abbrlink: xxx</code>，将会根据算法随机生成数字</p>
<p>tips：可以将scaffolds目录下的post.md中修改为我这样就可以每次打开默认模板：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">abbrlink: </span><br><span class="line">tags: &#123;&#123; tags &#125;&#125;</span><br><span class="line">categories:&#123;&#123; categories &#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="官方配置信息"><a href="#官方配置信息" class="headerlink" title="官方配置信息"></a>官方配置信息</h2><p>最后附上官方配置</p>
<p>除了下列变量外，您还可使用 Front-matter 中的所有属性。</p>
<table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>:year</code></td>
<td align="left">文章的发表年份（4 位数）</td>
</tr>
<tr>
<td align="left"><code>:month</code></td>
<td align="left">文章的发表月份（2 位数）</td>
</tr>
<tr>
<td align="left"><code>:i_month</code></td>
<td align="left">文章的发表月份（去掉开头的零）</td>
</tr>
<tr>
<td align="left"><code>:day</code></td>
<td align="left">文章的发表日期 (2 位数)</td>
</tr>
<tr>
<td align="left"><code>:i_day</code></td>
<td align="left">文章的发表日期（去掉开头的零）</td>
</tr>
<tr>
<td align="left"><code>:title</code></td>
<td align="left">文件名称</td>
</tr>
<tr>
<td align="left"><code>:id</code></td>
<td align="left">文章 ID</td>
</tr>
<tr>
<td align="left"><code>:category</code></td>
<td align="left">分类。如果文章没有分类，则是 <code>default_category</code> 配置信息。</td>
</tr>
</tbody></table>
<p>您可在 <code>permalink_defaults</code> 参数下调整永久链接中各变量的默认值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">permalink_defaults:  lang: en</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客添加相册页面</title>
    <url>/posts/23551.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：Hexo 博客并没有自带的相册功能，所以我们需要自己动手来创建一个相册，其中修改了一些原作者的问题。</p>
<a id="more"></a>

<p>我的<a href="https://hongcyu.coding.me/photos/" target="_blank" rel="noopener">个人相册</a>目前不适配低分辨率，建议在 1920*1080 及以上访问效果最好哦，需要自己进行适配的，可以在我的代码基础上自行进行修改~</p>
<h2 id="创建腾讯云存储桶（cos）"><a href="#创建腾讯云存储桶（cos）" class="headerlink" title="创建腾讯云存储桶（cos）"></a>创建腾讯云存储桶（cos）</h2><p>跳转：「<a href="https://cloud.tencent.com/" target="_blank" rel="noopener">腾讯云</a>」–&gt;产品（左上角）–&gt;存储–&gt;对象存储</p>
<p>我们先新建一个专门存放相册图片的存储桶，在<font color="red">对象存储</font>页面左边点击存储桶列表 -&gt; 新建存储桶</p>
<p>然后在存储桶页面，名称可以自己任意填写，需要选择下图中标注的<font color="red">公有读私有写</font>，然后点击确定。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/AF-2.png" alt></p>
<hr>
<p>然后我们点击这个存储桶，选择左侧的基础配置 -&gt; 跨域访问CORS设置 -&gt; 添加规则</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/AF-3.png" alt></p>
<p>然后按下图所示进行填写</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/AF-4.png" alt></p>
<p><strong>域名以 http://或 https:// 开头，每行一个，一行最多一个通配符 *</strong></p>
<p><strong>如果填写域名后遇到跨域问题，可以将 origin 这里填写为 * 就可以解决</strong></p>
<hr>
<p>点击权限管理–&gt;Policy权限设置–&gt;添加策略</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/AF-6.png" alt></p>
<p>按照下面图片进行设置</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/AF-1.png" alt></p>
<hr>
<p>然后记住基础配置中的<font color="red">访问域名</font>，这里就是我们动态生成相册，获取链接时需要用到的<font color="red">xml链接</font>，下面要用到。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/AF-5.png" alt></p>
<h2 id="新建相册页面"><a href="#新建相册页面" class="headerlink" title="新建相册页面"></a>新建相册页面</h2><p>首先在 hexo 博客本地新建一个页面（菜单栏）：</p>
<p>hexo博客根站点目录下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;photos&quot;</span><br></pre></td></tr></table></figure>

<p>然后在<code>hexo/source/photos/index.md</code>中编辑页面如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 光影流年</span><br><span class="line">date: 2019-12-05 13:00:00</span><br><span class="line">type: &quot;photos&quot;</span><br><span class="line">---</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">	.posts-expand .post-body img&#123;</span><br><span class="line">		padding: 1px;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.footer&#123;</span><br><span class="line">		display: none !important;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> 	/*不展示底部*/</span><br><span class="line"> 	.footer-inner&#123;</span><br><span class="line"> 		display: none !important;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line">	.v * &#123;</span><br><span class="line">    	color: #f4f4f4 !important;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.v .vwrap .vmark .valert .vcode &#123;</span><br><span class="line">    	background: #00050b !important;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> 	/*不展示侧栏*/</span><br><span class="line"> 	.sidebar-toggle&#123;</span><br><span class="line"> 		display: none !important;</span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line">    /*修改相册页面内容宽度为全屏*/</span><br><span class="line">	.main-inner&#123;</span><br><span class="line">		width: 100%;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*修改主体页面样式*/</span><br><span class="line">	.main &#123;</span><br><span class="line">    	padding-bottom: 150px;</span><br><span class="line">    	margin-top: 0px;</span><br><span class="line">    	background: #121212;</span><br><span class="line">	&#125;</span><br><span class="line">	.main-inner&#123;</span><br><span class="line">		margin-top: unset;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*body体样式*/</span><br><span class="line">	body &#123;</span><br><span class="line">		background-image: unset;</span><br><span class="line">		background-attachment: unset;</span><br><span class="line">		background-size: 100%;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.header&#123;</span><br><span class="line">		background: rgba(28, 25, 25, 0.6);</span><br><span class="line">		border-bottom: unset;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.menu .menu-item a&#123;</span><br><span class="line">		font-weight: 300;</span><br><span class="line">   		color: #222;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    .imgbox&#123;</span><br><span class="line">	  width: 100%;</span><br><span class="line">	  overflow: hidden;</span><br><span class="line">	  border-right: 0px solid #bcbcbc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	.box&#123;</span><br><span class="line">		visibility: visible;</span><br><span class="line">		overflow: auto; </span><br><span class="line">		zoom: 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.box li&#123;</span><br><span class="line">		float: left;</span><br><span class="line">    	width: 25%;  /*每个框占25%*/</span><br><span class="line">    	position: relative;</span><br><span class="line">    	overflow: hidden;</span><br><span class="line">    	text-align: center;</span><br><span class="line">    	list-style: none;</span><br><span class="line">    	margin: 0;</span><br><span class="line">    	/*display: inline;*/</span><br><span class="line">    	padding: 0;</span><br><span class="line">    	height: 400px;   /*固定高度*/</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.box li span&#123;</span><br><span class="line">		display: block;</span><br><span class="line">    	padding: 4% 7% 10% 7%;</span><br><span class="line">    	min-height: 80px;</span><br><span class="line">    	background: #fff;</span><br><span class="line">    	color: #fff;</span><br><span class="line">    	font-size: 16px;</span><br><span class="line">    	background: #121212;</span><br><span class="line">    	font-weight: 600;</span><br><span class="line">    	line-height: 26px;</span><br><span class="line">    	-webkit-box-sizing: border-box;</span><br><span class="line">    	box-sizing: border-box;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    img.imgitem&#123;</span><br><span class="line">		padding: unset;</span><br><span class="line">		padding: unset;</span><br><span class="line">		border: unset;</span><br><span class="line">		position: relative;</span><br><span class="line">		padding: 0px;</span><br><span class="line">		width: 100%;</span><br><span class="line">		height: 350px;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	div#comments.comments.v &#123;</span><br><span class="line">    	border: 0px;</span><br><span class="line">    	margin: auto !important;</span><br><span class="line">    	margin-top: unset;</span><br><span class="line">    	margin-left: unset;</span><br><span class="line">    	margin-right: unset;</span><br><span class="line">    	width: 60%;</span><br><span class="line">    	padding-top: 50px;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	div#posts.posts-expand &#123;</span><br><span class="line">    	border: unset;</span><br><span class="line">    	padding: unset;</span><br><span class="line">    	margin-bottom: 10px;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.valine .vlist .vcard .vcomment-body .vhead .vname&#123;</span><br><span class="line">		color: #fff;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.valine .vlist .vcard .vcomment-body .text-wrapper .vcomment p&#123;</span><br><span class="line">		color: #fff;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.box p&#123;</span><br><span class="line">		display: block;</span><br><span class="line">    	background: #121212;</span><br><span class="line">    	color: #fff;</span><br><span class="line">    	font-size: 12px;</span><br><span class="line">    	font-family: &apos;SwisMedium&apos;;</span><br><span class="line">    	text-align: center;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.box span strong&#123;</span><br><span class="line">		background: rgba(0,0,0,0.4);</span><br><span class="line">		padding: 20px;</span><br><span class="line">		font-family: serif, sans-serif;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.posts-expand .post-title &#123;</span><br><span class="line">		display: none;</span><br><span class="line">	&#125;</span><br><span class="line">	.title&#123;</span><br><span class="line">    	display: inline-block;</span><br><span class="line">    	vertical-align: middle;</span><br><span class="line">    	font: 85px/250px &apos;ChaletComprimeMilanSixty&apos;;</span><br><span class="line">    	background-position: left bottom !important;</span><br><span class="line">    	color: #fff;</span><br><span class="line">    	background-size: 100% auto !important; </span><br><span class="line">		-webkit-background-size: cover; </span><br><span class="line">		-moz-background-size: cover;</span><br><span class="line">		-o-background-size: cover;</span><br><span class="line">    	width: 100%;</span><br><span class="line">    	text-align: center;</span><br><span class="line">    	border: unset;</span><br><span class="line">    	height: 580px;</span><br><span class="line">    	cursor: unset !important;</span><br><span class="line">    	-webkit-box-sizing: border-box;</span><br><span class="line">    	box-sizing: border-box;</span><br><span class="line">	&#125;</span><br><span class="line">	.btn-more-posts&#123;</span><br><span class="line">		display: inline-block;</span><br><span class="line">    	vertical-align: middle;</span><br><span class="line">    	font: 85px/250px &apos;ChaletComprimeMilanSixty&apos;;</span><br><span class="line">    	color: #000;</span><br><span class="line">    	width: 100%;</span><br><span class="line">    	text-align: center;</span><br><span class="line">    	border: unset;</span><br><span class="line">    	height: 400px;</span><br><span class="line">    	background-color: #121212;</span><br><span class="line">    	/*-webkit-box-sizing: border-box;*/</span><br><span class="line">    	/*box-sizing: border-box;*/</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">@media (max-width: 767px)&#123;</span><br><span class="line">	.box li &#123;</span><br><span class="line">    	width: 100%;</span><br><span class="line">    	height: auto;</span><br><span class="line">	&#125;</span><br><span class="line">	.title &#123;</span><br><span class="line">    	height: 200px;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.posts-expand .post-body img&#123;</span><br><span class="line">		box-sizing: none;</span><br><span class="line">		padding: 0px !important;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.box span &#123;</span><br><span class="line">    	min-height: 80px;</span><br><span class="line">    	border-right: unset;</span><br><span class="line">    	font-size: 17px;</span><br><span class="line">	&#125;</span><br><span class="line">	.box p&#123;</span><br><span class="line">    	border-right: unset;</span><br><span class="line">    	font-size: 12px;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.posts-expand &#123;</span><br><span class="line">    	margin: unset;</span><br><span class="line">	&#125;</span><br><span class="line">	div#comments.comments.v &#123;</span><br><span class="line">    	width: 96%;</span><br><span class="line">    	padding-top: 50px;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media (min-width: 1300px)&#123;</span><br><span class="line">	.container .main-inner&#123;</span><br><span class="line">		width: 100%;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 主体部分 --&gt;</span><br><span class="line">&lt;div id=&quot;box&quot; class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">function loadXMLDoc(xmlUrl) </span><br><span class="line">&#123;</span><br><span class="line">	try //Internet Explorer</span><br><span class="line">	&#123;</span><br><span class="line">		xmlDoc=new ActiveXObject(&quot;Microsoft.XMLDOM&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	catch(e)</span><br><span class="line">	&#123;</span><br><span class="line">	  try //Firefox, Mozilla, Opera, etc.</span><br><span class="line">	    &#123;</span><br><span class="line">		  xmlDoc=document.implementation.createDocument(&quot;&quot;,&quot;&quot;,null);</span><br><span class="line">	    &#125;</span><br><span class="line">	  catch(e) &#123;alert(e.message)&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	try </span><br><span class="line">	&#123;</span><br><span class="line">		  xmlDoc.async=false;</span><br><span class="line">		  xmlDoc.load(xmlUrl);</span><br><span class="line">	&#125;</span><br><span class="line">	catch(e) &#123;</span><br><span class="line">		try //Google Chrome  </span><br><span class="line">		  &#123;  </span><br><span class="line">			var chromeXml = new XMLHttpRequest();</span><br><span class="line">			chromeXml.open(&quot;GET&quot;, xmlUrl, false);</span><br><span class="line">			chromeXml.send(null);</span><br><span class="line">			xmlDoc = chromeXml.responseXML.documentElement; 				</span><br><span class="line">			//alert(xmlDoc.childNodes[0].nodeName);</span><br><span class="line">			//return xmlDoc;    </span><br><span class="line">		  &#125;  </span><br><span class="line">		  catch(e)  </span><br><span class="line">		  &#123;  </span><br><span class="line">			  alert(e.message)  </span><br><span class="line">		  &#125;  		  	</span><br><span class="line">	&#125;</span><br><span class="line">	return xmlDoc; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var xmllink=&quot;填写你的xml地址&quot;</span><br><span class="line">//访问域名链接就是我上面提到的那个访问域名xml链接</span><br><span class="line"></span><br><span class="line">xmlDoc=loadXMLDoc(xmllink);</span><br><span class="line">var urls = xmlDoc.getElementsByTagName(&apos;Key&apos;);</span><br><span class="line">var date = xmlDoc.getElementsByTagName(&apos;LastModified&apos;);</span><br><span class="line">var wid = 350;</span><br><span class="line">var showNum = 13; //每个相册一次展示多少照片，为4的倍数+1</span><br><span class="line">if ((window.innerWidth) &gt; 1200) &#123; wid = (window.innerWidth * 3) / 18;&#125;</span><br><span class="line">var box = document.getElementById(&apos;box&apos;);</span><br><span class="line">var i = 0;</span><br><span class="line"></span><br><span class="line">var content = new Array();</span><br><span class="line">var tmp=0;</span><br><span class="line">var kkk=-1;</span><br><span class="line">for (var t = 0; t &lt; urls.length ; t++) &#123;</span><br><span class="line">	var bucket=urls[t].innerHTML;</span><br><span class="line">	var length=bucket.indexOf(&apos;/&apos;);</span><br><span class="line">	if(length===bucket.length-1)&#123;</span><br><span class="line">		kkk++;</span><br><span class="line">		content[kkk]=new Array();</span><br><span class="line">		content[kkk][0]=&#123;&apos;url&apos;:bucket,&apos;date&apos;:date[t].innerHTML.substring(0,10)&#125;;</span><br><span class="line">		tmp=1;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		content[kkk][tmp++]=&#123;&apos;url&apos;:bucket.substring(length+1),&apos;date&apos;:date[t].innerHTML.substring(0,10)&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; content.length; i++) &#123;</span><br><span class="line">	var conBox=document.createElement(&quot;div&quot;);</span><br><span class="line">	conBox.id=&apos;conBox&apos;+i;</span><br><span class="line">	box.appendChild(conBox);</span><br><span class="line">	var item=document.createElement(&quot;div&quot;);</span><br><span class="line">	var title=content[i][0].url;</span><br><span class="line">	item.innerHTML=&quot;&lt;button class=title style=background:url(&quot;+xmllink+&apos;/&apos; + title + &quot;surface.jpg&quot;+&quot;);background-repeat:no-repeat;&gt;&lt;span style=display:inline;&gt;&lt;strong style=color:#f0f3f6; &gt;&quot; + title.substring(0,title.length - 1) + &quot;&lt;/strong&gt;&lt;/span&gt;&lt;/button&gt;&quot;;</span><br><span class="line">	conBox.appendChild(item);</span><br><span class="line"></span><br><span class="line">        for (var j = 1; j &lt; content[i].length &amp;&amp; j &lt; showNum+1; j++) &#123;</span><br><span class="line">	        var con=content[i][j].url;</span><br><span class="line">		var item=document.createElement(&quot;li&quot;);</span><br><span class="line">		if(con.substring(0,con.length-4) != &quot;surface&quot;)&#123;</span><br><span class="line">			item.innerHTML=&quot;&lt;div class=imgbox id=imgbox style=height:&quot;+wid+&quot;px;&gt;&lt;img class=imgitem src=&quot;+xmllink+&apos;/&apos; + title + con +&quot; alt=&quot; + con + &quot;&gt;&lt;/div&gt;&lt;span&gt;&quot; + con.substring(0,con.length-4);</span><br><span class="line">			conBox.appendChild(item);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(content[i].length &gt; showNum)&#123;</span><br><span class="line">		var moreItem=document.createElement(&quot;button&quot;);</span><br><span class="line">		moreItem.className = &quot;btn-more-posts&quot;;</span><br><span class="line">		moreItem.id = &quot;more&quot; + i;</span><br><span class="line">		moreItem.value = showNum + 1;</span><br><span class="line">		let cur = i;</span><br><span class="line">		moreItem.onclick = function ()&#123;</span><br><span class="line">			moreClick(this,cur,content[cur],content[cur][0].url);</span><br><span class="line">		&#125;</span><br><span class="line">		moreItem.innerHTML=&quot;&lt;span style=display:inline;&gt;&lt;strong style=color:#f0f3f6;&gt;加载更多&lt;/strong&gt;&lt;/span&gt;&quot;;</span><br><span class="line">		conBox.appendChild(moreItem);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function moreClick(obj,cur,cont,title)&#123;</span><br><span class="line">	var parent = obj.parentNode;</span><br><span class="line">	parent.removeChild(obj);</span><br><span class="line">	var j=obj.value;</span><br><span class="line">	var begin=j;</span><br><span class="line">	for ( ; j &lt; cont.length &amp;&amp; j &lt; Number(showNum) + Number(begin); j++) &#123;</span><br><span class="line">		var con=cont[j].url;</span><br><span class="line">		var item=document.createElement(&quot;li&quot;);</span><br><span class="line">		item.innerHTML=&quot;&lt;div class=imgbox id=imgbox style=height:&quot;+wid+&quot;px;&gt;&lt;img class=imgitem src=&quot;+xmllink+&apos;/&apos;+title+con+&quot; alt=&quot;+con+&quot;&gt;&lt;/div&gt;&lt;span&gt;&quot;+con.substring(0,con.length-4);</span><br><span class="line">		parent.appendChild(item);</span><br><span class="line">		var v=item.getElementsByTagName(&apos;img&apos;);</span><br><span class="line">		v[0].id=imgid;</span><br><span class="line">		imgid++;</span><br><span class="line">	&#125;</span><br><span class="line">	if(cont.length &gt; j)&#123;</span><br><span class="line">		obj.value=j;</span><br><span class="line">		parent.appendChild(obj);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>其中我们只需要修改 xmllink 的值，就是上文提到的访问域名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xmllink=&quot;填写你的xml地址&quot;</span><br></pre></td></tr></table></figure>

<h2 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h2><p>上传图片推荐使用「<a href="https://cloud.tencent.com/document/product/436/11366" target="_blank" rel="noopener">使用腾讯云存储客户端</a>」文中推荐的客户端软件哦，其中需要注意的地方如下：</p>
<p>①上传图片前，需要先在存储桶中建立一个文件夹，文件夹名字就是相册名字，当然可以建立多个文件夹</p>
<p>②文件夹里不能再建文件夹，不然会出 BUG</p>
<p>③每个文件夹中需要一张名为<font color="red">surface</font> 的图片，它会自动作为该文件夹相册的的封面</p>
<p>④确保存储桶的 xml 域名能在浏览器上访问</p>
<p>⑤尽量自己修改样式以满足自己的需求</p>
<p>⑥CSS 样式直接写在 md 文件中，不用写在全局 custom.styl 文件中</p>
<hr>
<p>然后就 ok 了！可以使用<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code>重新渲染页面查看一下相册！如果有 BUG 也欢迎在评论区中留言，我尽量解决！</p>
<hr>
<p>参考：</p>
<p>Sanarous：「<a href="https://bestzuo.cn/posts/3923764626.html" target="_blank" rel="noopener">hexo博客添加相册页面</a>」</p>
<p>小鸡：「<a href="https://me.idealli.com/post/73ad4183" target="_blank" rel="noopener">给hexo静态博客添加动态相册功能</a>」</p>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>相册</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo的简单命令</title>
    <url>/posts/34490.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：介绍了Hexo的一些简单命令。</p>
<a id="more"></a>
<h2 id="hexo-s"><a href="#hexo-s" class="headerlink" title="hexo s"></a>hexo s</h2><p>启动本地服务器，用于预览主题。默认地址： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a><br>hexo s 是 hexo server 的缩写，命令效果一致；<br>预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；<br>对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果。</p>
<hr>
<h2 id="hexo-new-“学习笔记”"><a href="#hexo-new-“学习笔记”" class="headerlink" title="hexo new “学习笔记”"></a>hexo new “学习笔记”</h2><p>新建一篇标题为 学习笔记 的文章，因为标题里有空格，所以加上了引号。<br>文章标题可以在对应 md 文件里改，新建时标题可以写的简单些。</p>
<hr>
<h2 id="hexo-d"><a href="#hexo-d" class="headerlink" title="hexo d"></a>hexo d</h2><p>自动生成网站静态文件，并部署到设定的仓库。<br>hexo d 是 hexo deploy 的缩写，命令效果一致。</p>
<hr>
<h2 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a>hexo clean</h2><p>清除缓存文件 db.json 和已生成的静态文件 public 。<br>网站显示异常时可以执行这条命令试试。</p>
<hr>
<h2 id="hexo-g"><a href="#hexo-g" class="headerlink" title="hexo g"></a>hexo g</h2><p>生成网站静态文件到默认设置的 public 文件夹。<br>便于查看网站生成的静态文件或者手动部署网站；<br>如果使用自动部署，不需要先执行该命令；<br>hexo g 是 hexo generate 的缩写，命令效果一致。</p>
<hr>
<h2 id="hexo-new-page-aboutme"><a href="#hexo-new-page-aboutme" class="headerlink" title="hexo new page aboutme"></a>hexo new page aboutme</h2><p>新建一个标题为 aboutme 的页面，默认链接地址为 主页地址/aboutme/<br>标题可以为中文，但一般习惯用英文；<br>页面标题和文章一样可以随意修改；<br>页面不会出现在首页文章列表和归档中，也不支持设置分类和标签。</p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.bilibili.com/video/av44544186" target="_blank" rel="noopener">https://www.bilibili.com/video/av44544186</a><br><a href="https://blog.csdn.net/dxxzst/article/details/76135935" target="_blank" rel="noopener">https://blog.csdn.net/dxxzst/article/details/76135935</a></p>
]]></content>
      <categories>
        <category>命令格式</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-Fedora系统的安装</title>
    <url>/posts/fedora-1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：这是一次在Linux课程上的安装尝试，安装的是Fedora系统。在下一篇我会更新手动换源和一键换源的步骤。</p>
<a id="more"></a>

<h2 id="下载镜像文件"><a href="#下载镜像文件" class="headerlink" title="下载镜像文件"></a>下载镜像文件</h2><ol>
<li><p>首先我们先去<a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">mirrors.ustc.edu.cn</a>下载fedora的镜像文件</p>
</li>
<li><p>点击右侧的<font color="red"><strong>获取安装镜像</strong></font>在发行版的下拉列表中找到到Fedora</p>
</li>
<li><p>选择发行版本中会列出最新的版本号以及各版本号所对应的不同选项。版本一致的情况下内核和功能都是一样的，区别在于<strong>图形界面</strong>，这里我选择31（×86-64Cinnamon）这个版本。</p>
<p>①workstation就是标准的图形界面。</p>
<p>②Xfce是极简界面，一般用于比较老或者性能不佳的机器。</p>
<p>③KDE更倾向于Windows的界面。</p>
<p>④Cinnamon则比较流行的图像界面。</p>
</li>
</ol>
<h2 id="VM虚拟机安装Linux系统"><a href="#VM虚拟机安装Linux系统" class="headerlink" title="VM虚拟机安装Linux系统"></a>VM虚拟机安装Linux系统</h2><ol>
<li>选择新建虚拟机，选择自定义，在硬件兼容性的选项中选择最高版本即可，因为高版本默认是兼容低版本的虚拟机的，但是低版本不能兼容高版本，所以选择较高的即可。</li>
<li>安装客户机OS时选择稍后安装，我们先把虚拟机配置好再进行系统安装。</li>
<li>客户机操作系统选择Linux ，根据下载的版本选择Fedora 是32位还是64位即可。（ps：如果你安装的虚拟机版本不在这上面可以使用最下面的内核版本来进行安装）</li>
<li>选择虚拟机文件存放的安装目录。</li>
<li>选择2核4线程即可</li>
<li>指定虚拟机内存，因为是64位虚拟机至少2G内存才不会太卡顿，若内存富裕可以选择4GB内存。</li>
<li>网络连接方式其中有四个选项，一般情况下我们选择NAT模式或者仅主机模式。其中，NAT模式的特点是虚拟机可以同步使用主机IP地址来访问互联网，但是虚拟机和主机是不可以通信的。反之，在仅主机模式中虚拟机是不能访问互联网的，但是客户机和主机是可以进行通信的，一般在进行虚拟网络测试时选择的是仅主机模式。</li>
<li>I/O控制器选择默认即可。</li>
<li>虚拟硬盘类型默认即可。</li>
<li>在是否创建虚拟磁盘，一般情况下创建虚拟磁盘。</li>
<li>选择磁盘大小，记得不要超过你的磁盘大小。其中需要注意的是<font color="red">立即分配所以磁盘空间</font>是将磁盘立即划分出来，之后就不能使用你所选择的这部分空间，所以一般不打勾。而将虚拟盘拆分多个文件有利于虚拟机的转移。</li>
<li>然后一直下一步即可完成。</li>
</ol>
<h2 id="安装操作系统"><a href="#安装操作系统" class="headerlink" title="安装操作系统"></a>安装操作系统</h2><ol>
<li>点击虚拟机界面下的<font color="red">编辑此虚拟机设置</font>在其中的CD/DVD中选择使用ISO映像文件，选择你下载的镜像包然后保存。</li>
<li>启动虚拟机进行安装。</li>
<li>选择START FEDORA进行下一步，安装的开始会进行一些初始化。</li>
<li>此时会出现主界面，不过是试用界面，可以点击Install to Hard Drive 进行安装到硬盘中。</li>
<li>安装的第一就是选择中文。</li>
<li>安装信息摘要中，凡是带感叹号的都是需要 用户修改的。</li>
<li>按照步骤安装即可。注意!由于目前的操作系统不允许超级用户登入，所以必须创建用户用于登入。<u>不要</u>选择将用户设置为管理员。</li>
<li>创建完成后单击开始安装。</li>
<li>最后重启系统即可完成。</li>
</ol>
<p><font color="red">注意：最好将网络断开，避免在未换源的情况下由于下载更新导致安装过慢的问题</font></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Fedora</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Fedora</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下gcc编译器的使用</title>
    <url>/posts/linux-gcc.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：此为学习Linux课程中关于gcc编译器的一些总结，方便以后查阅。</p>
<a id="more"></a>



<p>用集成的编程软件很难了解到程序背后编译器对代码编译过程的具体步骤，所以在这里进行手动编译可以让人更直观的了解到编译器编译代码的过程。</p>
<p>首先，我们来写一段程序，当然是我们最熟悉的它啦！Hello World：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello world!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并保存为test.c</p>
<h3 id="第一种编译方式"><a href="#第一种编译方式" class="headerlink" title="第一种编译方式"></a>第一种编译方式</h3><p>然后我们到命令行中输入<code>gcc test.c</code> 直接回车后可以发现多了一个a.out的文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200229155717.png" alt></p>
<p>a.out就是刚刚生成的可执行文件，现在我们要执行它。</p>
<p>输入<code>./a.out</code>即可执行它了，如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200229160013.png" alt></p>
<p>可以看到我们很顺利的就打印出了Hello world！</p>
<p><strong>总结：</strong> </p>
<p>gcc &lt;filename.c&gt;</p>
<h3 id="第二种编译方式"><a href="#第二种编译方式" class="headerlink" title="第二种编译方式"></a>第二种编译方式</h3><p>这是一种通过中间代码进行编译</p>
<p>输入<code>gcc -c test.c</code>按下回车，可以看到多了一个以文件名.o命名的文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200229160338.png" alt></p>
<p>这是编译器用 -c 这个参数时单一生成的中间代码，但是中间代码是不可以执行的，我们需要进行链接生成可执行文件。</p>
<p>输入<code>gcc -o test_1 test.o</code>(其中test_1为你自定义的文件名，test.o为上一步生成的中间文件)，我们可以直接执行test_1来看看会得到一样的效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/1582963693916.png" alt></p>
<p><strong>总结：</strong></p>
<ol>
<li>gcc -c &lt;filename.c&gt;</li>
<li>gcc -o <filename_exe> &lt;filename.o&gt;</filename_exe></li>
</ol>
<p>但是我们在编写代码时不能所以都由自己写，需要用到写好的库文件时，该怎么用呢？</p>
<p>这里我们重新编写代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello world!\n"</span>);</span><br><span class="line">     </span><br><span class="line">    ret = <span class="built_in">sqrt</span>(data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the sqrt = %d\n"</span>,ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果直接运行<code>gcc -c test.c</code>会发现报错：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200229163141.png" alt></p>
<p>可以发现，凡是语法错误在编译的时候就会识别出来了，已经说明函数sqrt未被定义。可以看到解决方案，加上头文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello world!\n"</span>);</span><br><span class="line">     </span><br><span class="line">    ret = <span class="built_in">sqrt</span>(data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the sqrt = %d\n"</span>,ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编译<code>gcc -c test.c</code>  和<code>gcc -o test test.o</code>后</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200229163714.png" alt></p>
<p>发现调用别人的函数有两个要求，一是知道函数的原型，一般在头文件中就给出。二是函数会编译成库的形式，我需要来调用这个库的形式，需要告诉调用的库的名字是什么，所以这个问题是因为我们在链接的时候没有把库函数链接上。解决办法：</p>
<p><code>gcc -o test test.o -lm</code>(链接math.h不是-lmath而是-lm)</p>
<p>这个时候就编译成功了！</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200229164511.png" alt></p>
<p>输入 <code>man sqrt</code> 可以查看手册，得到链接的参数。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200229164751.png" alt></p>
<h3 id="第三种编译方式"><a href="#第三种编译方式" class="headerlink" title="第三种编译方式"></a>第三种编译方式</h3><p>测试多个文件怎么进行编译：</p>
<p>这里test.c为主程序，myfunc.c和myfunc.h为模块代码</p>
<p><code>test.c</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myfunc.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> data = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello world!\n"</span>);</span><br><span class="line">     </span><br><span class="line">    ret = <span class="built_in">sqrt</span>(data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the sqrt = %d\n"</span>,ret);</span><br><span class="line">    </span><br><span class="line">    a = add(<span class="number">100</span>,<span class="number">200</span>);</span><br><span class="line">    b = sub(<span class="number">1000</span>,<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d , b = %d \n"</span>,a,b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>myfunc.c</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span>  y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x+y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x-y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>myfunc.h</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然后使用<code>gcc -c ***</code>各自生成可执行文件，接下来我们将两个中间文件进行链接：</p>
<p>使用<code>gcc -o test test.o myfunc.o -lm</code>进行链接，然后成功执行：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200229172011.png" alt></p>
<p><strong>tips：</strong></p>
<p>如果遇到下面这种情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200229165815.jpg" alt></p>
<p>是因为本文件夹中查找不到，将头文件中的#include &lt;myfunc.h&gt;改成#include “myfunc.h”即可~</p>
<p><strong>总结：</strong></p>
<ol>
<li>gcc -c &lt;filename1.c&gt;</li>
<li>gcc -c &lt;filename2.c&gt;   …</li>
<li>gcc -0 <filename_exe> &lt;filename.o&gt; &lt;filename2.o&gt; ……  -l …..</filename_exe></li>
</ol>
<h3 id="第四种编译方式（makefile）"><a href="#第四种编译方式（makefile）" class="headerlink" title="第四种编译方式（makefile）"></a>第四种编译方式（makefile）</h3><p>利用makefile文件来编译程序</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">test:test.o myfunc.o</span></span><br><span class="line">	gcc -o test test.o myfunc.o -lm</span><br><span class="line"><span class="section">test.o:test.c</span></span><br><span class="line">	gcc -c test.c</span><br><span class="line"><span class="section">myfunc.o:myfunc.c</span></span><br><span class="line">	gcc -c myfunc.c</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm *.o</span><br></pre></td></tr></table></figure>

<p>执行</p>
<p><strong>tips:</strong></p>
<p>采用倒叙的方式书写</p>
<p><code>gcc,rm</code>等命令前加的是TAB （注意不要用空格代替制表符！）</p>
<p><strong>makefile文件格式总结：</strong></p>
<p>&lt;模块名&gt;:&lt;生成所需资源文件&gt;</p>
<p>​        <tab>&lt;生成方法&gt;</tab></p>
<h3 id="gdb调试方法"><a href="#gdb调试方法" class="headerlink" title="gdb调试方法"></a>gdb调试方法</h3><p>不能<strong>直接</strong>使用，需要在编译时加入调试方法</p>
<p>采用的指令是 gcc -g</p>
<p>例如：输入<code>gcc -g test.c myfunc.c -o test -lm</code>也可以正常生成，但是会发现可执行文件容量比较大。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200229175435.png" alt></p>
<p>输入<code>gdb test</code>进入调试，界面如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200229175610.png" alt></p>
<p>查看代码：</p>
<ol>
<li><p>list          （查看10行的内容）</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200229180156.png" alt></p>
</li>
<li><p>list 10       (以第10行为中心上下共10行的内容)</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200229180217.png" alt></p>
</li>
<li><p>list 6,12    (列出6到12行的内容) </p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200229180233.png" alt></p>
<p>输入<code>run</code>可以使得程序在调试时运行</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200229180342.png" alt></p>
<p>断点设置：</p>
<ol>
<li><p>设置断点 break 行数</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200229180528.png" alt></p>
</li>
<li><p>清除断点 </p>
<p>采用<code>info break</code>查看断点信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200229184734.png" alt></p>
<p>输入 <code>delete breakpoint &lt;Num&gt;</code>即可删除对应编号的断点。</p>
</li>
<li><p><code>print  data</code> 即可查看当前赋的值</p>
</li>
<li><p>单步运行</p>
<p>① step进入函数体的单步执行</p>
<p>② next 不进入函数体的单步执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/asdfaa1213.png" alt></p>
</li>
<li><p>多步执行</p>
<p><code>step &lt;步数&gt;</code></p>
<p><code>next &lt;步数&gt;</code></p>
</li>
</ol>
<hr>
<p><strong>gdb总结：</strong></p>
<ol>
<li><p>生成： gcc -g &lt;源文件&gt; -o &lt;执行文件&gt; -l&lt;库&gt;</p>
</li>
<li><p>进入调试 gdb <filename_exe></filename_exe></p>
</li>
<li><p>list              显示十条语句</p>
<p>list n           以n为中心，显示十条语句</p>
<p>list m,n      显示从m到n的语句</p>
</li>
<li><p>break &lt;行号&gt;    设断点</p>
</li>
<li><p>info break   显示断点信息</p>
</li>
<li><p>delete breakpoint &lt;编号&gt;</p>
</li>
<li><p>enable/disable breakpoint &lt;编号&gt; 启用/禁用 断点</p>
</li>
<li><p>run 执行到断点</p>
</li>
<li><p>step进入函数体的单步执行</p>
<p>next 不进入函数体的单步执行</p>
</li>
<li><p>print &lt;变量&gt;   查看变量信息</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下文件系统的管理</title>
    <url>/posts/linux-file-management.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：我们都听过一句话，Linux/Unix中一切都是文件，所以在这里介绍一下Linux下文件系统的管理。</p>
<a id="more"></a>

<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>所谓的文件系统，一般情况下磁盘/分区的文件组织方式，就叫文件系统。要想了解文件系统，就从磁盘开始。</p>
<p>首先我们先了解下根目录。</p>
<blockquote>
<p>bin:    用户二进制文件</p>
<p>dev ：设备描述（device的缩写）</p>
<p>home：家目录</p>
<p>media：可移动媒体设备</p>
<p>opt：可选的附加应用程序</p>
<p>root：超级用户目录</p>
<p>sbin:    系统二进制文件</p>
<p>usr:    用户程序</p>
<p>boot：引导加载程序文件</p>
<p>etc:  所有的配置文件</p>
<p>lib：系统库</p>
<p>mnt：挂载目录</p>
<p>proc: 内置的系统镜像</p>
<p>srv：服务数据</p>
<p>tmp：临时文件</p>
<p>var：变量文件</p>
</blockquote>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200312213005.png" alt></p>
<p>我们可以进入<code>/dev</code>目录查看下里面的文件，我们可以找到磁盘设备，stdin,stdout,stderr等。</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/1584020537514.png" alt></p>
<p>通常情况下我们添加一块磁盘会进行 分区–&gt; 格式化 接着我们就可以在文件系统中进行文件操作。</p>
<p>sda1,sda2代表磁盘已经加入了，还需要进行磁盘的分区和格式化才可以进行使用。</p>
<blockquote>
<p>fdisk -l</p>
</blockquote>
<p>来查看分区信息：</p>
<p>sda:    sd代表SCSI 类型的硬盘 a代表第一块硬盘</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200312214725.png" alt></p>
<p>硬盘的分区有三个：主分区，扩展分区，逻辑分区。</p>
<p>操作系统启动时必须找到主分区的引导程序才能启动，而我们最多可以有4个主分区（MBR：4*16B）。</p>
<h2 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h2><p>现在我们模拟添加新磁盘的过程。</p>
<h3 id="识别硬盘"><a href="#识别硬盘" class="headerlink" title="识别硬盘"></a>识别硬盘</h3><p>我们先在虚拟机上添加一块硬盘</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200312220104.png" alt></p>
<p>接着按下面的方法选择，并创建新的磁盘并选择磁盘大小一直下一步。</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/1584021741262.png" alt></p>
<h3 id="启动虚拟机"><a href="#启动虚拟机" class="headerlink" title="启动虚拟机"></a>启动虚拟机</h3><p>我们可以看见添加了新的硬盘，相对于向物理机添加了硬盘。接着启动虚拟机</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/1584021980785.png" alt></p>
<h3 id="硬盘位置"><a href="#硬盘位置" class="headerlink" title="硬盘位置"></a>硬盘位置</h3><p>Linux中会将硬件放入/dev下，我们可以到该目录下找到我们刚刚添加的硬盘。</p>
<p>用超级用户进入/dev目录，我们可以发现和上面的图比较多了一个sdb文件。</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/1584022309191.png" alt></p>
<p>接着我们用<code>fdisk</code>命令来查看磁盘信息，发现多了一块sdb但是并没有进行分区和格式化</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200312221304.png" alt></p>
<h3 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h3><blockquote>
<p>fdisk /dev/&lt;设备名&gt;</p>
</blockquote>
<p>接下来我们运行fdisk /dev/sdb      可以选择m查看帮助</p>
<blockquote>
<p>帮助：</p>
<p>  DOS (MBR)<br>   a   开关 可启动 标志<br>   b   编辑嵌套的 BSD 磁盘标签<br>   c   开关 dos 兼容性标志</p>
<p>  常规<br>   d   删除分区<br>   F   列出未分区的空闲区<br>   l   列出已知分区类型<br>   n   添加新分区<br>   p   打印分区表<br>   t   更改分区类型<br>   v   检查分区表<br>   i   打印某个分区的相关信息</p>
<p>  杂项<br>   m   打印此菜单<br>   u   更改 显示/记录 单位<br>   x   更多功能(仅限专业人员)</p>
<p>  脚本<br>   I   从 sfdisk 脚本文件加载磁盘布局<br>   O   将磁盘布局转储为 sfdisk 脚本文件</p>
<p>  保存并退出<br>   w   将分区表写入磁盘并退出<br>   q   退出而不保存更改</p>
<p>  新建空磁盘标签<br>   g   新建一份 GPT 分区表<br>   G   新建一份空 GPT (IRIX) 分区表<br>   o   新建一份的空 DOS 分区表<br>   s   新建一份空 Sun 分区表</p>
</blockquote>
<p>接下来输入<code>l</code>来查看分区类型</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200312223307.png" alt></p>
<p>接下来我们输入<code>n</code>新建一个分区。</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200312223420.png" alt></p>
<p>接下来选择先创建一个主分区，输入<code>p</code>回车，接着我们以所以磁盘都是一个主分区来管理，不进行创建扩展分区，按下面来填写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分区类型</span><br><span class="line">   p   主分区 (0个主分区，0个扩展分区，4空闲)</span><br><span class="line">   e   扩展分区 (逻辑分区容器)</span><br><span class="line">选择 (默认 p)：p</span><br><span class="line">分区号 (1-4, 默认  1): 1</span><br><span class="line">第一个扇区 (2048-2097151, 默认 2048): 2048</span><br><span class="line">最后一个扇区，+/-sectors 或 +size&#123;K,M,G,T,P&#125; (2048-2097151, 默认 2097151): </span><br><span class="line"></span><br><span class="line">创建了一个新分区 1，类型为“Linux”，大小为 1023 MiB。</span><br></pre></td></tr></table></figure>

<p>接下来输入<code>w</code>即可保存退出。</p>
<p>接下来查看可以发现已经不一样了，多了一个sdb1</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200312223937.png" alt></p>
<h3 id="分区格式化"><a href="#分区格式化" class="headerlink" title="分区格式化"></a>分区格式化</h3><p>windows: format /右键格式化</p>
<p>Linux: mkfs (make file system)</p>
<blockquote>
<p>mkfs -t <type> &lt;分区名称&gt;</type></p>
</blockquote>
<p>我们使用<code>mkfs -t ext4 /dev/sdb1</code>来格式化分区。</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200312224410.png" alt></p>
<h3 id="绑定（挂载）"><a href="#绑定（挂载）" class="headerlink" title="绑定（挂载）"></a>绑定（挂载）</h3><p>要想能访问还需要最后一步就是绑定！</p>
<blockquote>
<p>mount  &lt;挂载点&gt; &lt;挂载目录&gt;</p>
</blockquote>
<p>我们运行<code>mount /dev/sdb1 /disk_2</code>即可挂载sdb1到disk_2下</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200312224702.png" alt></p>
<p>接着在<code>fdisk -l</code>也可以查看但磁盘信息已经添加上去了</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200312224917.png" alt></p>
<blockquote>
<p>df -l  查看磁盘信息</p>
</blockquote>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200312225033.png" alt></p>
<h3 id="解除挂载"><a href="#解除挂载" class="headerlink" title="解除挂载"></a>解除挂载</h3><p>linux系统下卸载硬盘要先解除挂载才能去掉硬盘</p>
<blockquote>
<p>umount &lt;挂载点&gt;</p>
</blockquote>
<p>我们运行<code>umount /dev/sdb1</code>解除挂载。</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200312225449.png" alt></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下关于目录的操作及其程序设计</title>
    <url>/posts/linux-catalog.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：此为Linux下目录的操作，通过学习目录操作使用C语言模拟读取目录信息等，进一步进行模拟程序的编写。</p>
<a id="more"></a>

<h2 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h2><ol>
<li>打开目录</li>
<li>读取目录信息</li>
<li>关闭目录</li>
</ol>
<h3 id="打开目录"><a href="#打开目录" class="headerlink" title="打开目录"></a>打开目录</h3><p>头文件dirent.h</p>
<blockquote>
<p>DIR*    opendir(目录名称)；</p>
<p>成功：    地址</p>
<p>失败：    NULL</p>
</blockquote>
<h3 id="关闭目录"><a href="#关闭目录" class="headerlink" title="关闭目录"></a>关闭目录</h3><blockquote>
<p>closedir(DIR* 指针)；</p>
<p>成功：    0</p>
<p>失败：    -1</p>
</blockquote>
<h3 id="读取目录信息"><a href="#读取目录信息" class="headerlink" title="读取目录信息"></a>读取目录信息</h3><blockquote>
<p>struct dirent* readdir(DIR* 指针)；</p>
<p>成功：    返回结构体指针</p>
<p>失败：    NULL</p>
<p>方式：    循环自动读取</p>
<p>结构体内容：</p>
<p>​            dt_tpye：目录类型</p>
<p>​            dt_name：名称</p>
</blockquote>
<p>tips:</p>
<p>如果文件名以<code>“.”</code>引导，该文件不可见</p>
<p><code>.</code>为当前目录</p>
<p><code>..</code>为父目录</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bail</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Error(%d):"</span>,errno);</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DIR* dp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">dir</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	</span><br><span class="line">	dp = opendir(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span> (dp == <span class="literal">NULL</span>)</span><br><span class="line">		bail(<span class="string">"open dir error."</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>((dir = readdir(dp))!= <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dir -&gt;d_name[<span class="number">0</span>] ==<span class="string">'.'</span>) </span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(dir -&gt; d_type == DT_REG)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Regular file: %s \n"</span>,dir-&gt;d_name);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(dir -&gt; d_type == DT_DIR)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Dir file: %s\n"</span>,dir-&gt;d_name);</span><br><span class="line">	&#125;</span><br><span class="line">	closedir(dp);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200318115207.png" alt></p>
<h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p>在Linux中可以使用命令 <code>mkdir</code> 进行创建目录，也可以在程序设计中使用mkdir进行创建。</p>
<blockquote>
<p> 创建目录函数</p>
<p><code>mkdir (目录名称，权限参数)</code></p>
<p>成功返回： 0</p>
<p>失败返回： -1</p>
</blockquote>
<blockquote>
<p>切换目录函数</p>
<p><code>chdir(新目录名称)</code></p>
<p>成功返回： 0</p>
<p>失败返回： -1</p>
</blockquote>
<p>例如：</p>
<ol>
<li>给定源目录</li>
<li>遍历目录</li>
<li>创建一个新目录</li>
<li>将源目录加入到新目录中</li>
</ol>
<p>假定：</p>
<ol>
<li>一级目录，不进入子目录</li>
<li>只创建，不复制</li>
</ol>
<p>可行性：</p>
<p>cpdir（ source,dest)中</p>
<ol>
<li>source 要存在，可读</li>
<li>dest 要不存在，可写</li>
<li>读取source状态，作为dest状态</li>
<li>创建目标目录</li>
<li>source:     readdir;chdir(dest)</li>
<li>dest:     mkdir/create;chdir(source)</li>
<li>关闭两个目录指针</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 512</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bail</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Error(%d):"</span>,errno);</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> sdir[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> ddir[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> sname[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> dname[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> create_fd = <span class="number">-1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">dir</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	DIR* dp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(access(argv[<span class="number">1</span>],F_OK) &lt; <span class="number">0</span>) <span class="comment">//判断源文件是否存在，不存在则报错</span></span><br><span class="line">		bail(<span class="string">"Source directory not exist!"</span>);</span><br><span class="line">	<span class="keyword">if</span>(access(argv[<span class="number">2</span>],F_OK) == <span class="number">0</span>) <span class="comment">//判断目标文件是否存在，存在则报错</span></span><br><span class="line">		bail(<span class="string">"Dest directory exist!"</span>);</span><br><span class="line">	getcwd(sdir,<span class="keyword">sizeof</span>(sdir)); <span class="comment">//获取源文件路径，存入sdir</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;sb,<span class="number">0</span>,<span class="keyword">sizeof</span>(sb)); <span class="comment">//清空sb</span></span><br><span class="line">	stat(argv[<span class="number">1</span>],&amp;sb);	<span class="comment">//	获取权限存入sb块中</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>((mkdir(argv[<span class="number">2</span>],sb.st_mode)) &lt; <span class="number">0</span>)		<span class="comment">//创建目标目录,并判断是否创建成功</span></span><br><span class="line">		bail(<span class="string">"Create dest directory error!"</span>);</span><br><span class="line">	chdir(argv[<span class="number">2</span>]);	<span class="comment">//进入目标路径</span></span><br><span class="line">	getcwd(ddir,<span class="keyword">sizeof</span>(ddir));	<span class="comment">//获取目标路径，存入ddir</span></span><br><span class="line">	chdir(sdir);	<span class="comment">//回到源目录进行读写操作</span></span><br><span class="line">	</span><br><span class="line">	dp = opendir(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">while</span>((dir = readdir(dp)) != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//假定只有普通文件和目录文件</span></span><br><span class="line">		<span class="keyword">if</span> (dir-&gt;d_name[<span class="number">0</span>] == <span class="string">'.'</span>)	<span class="comment">//如果读取文件第一位为“.”，则跳过</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (dir-&gt;d_type == DT_DIR) <span class="comment">//如果读取类型是文件夹</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">memset</span>(&amp;sb,<span class="number">0</span>,<span class="keyword">sizeof</span>(sb));</span><br><span class="line">			stat(dir-&gt;d_name ,&amp;sb);</span><br><span class="line">			chdir(ddir);</span><br><span class="line">			mkdir(dir-&gt;d_name,sb.st_mode);</span><br><span class="line">			chdir(sdir);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">memset</span>(&amp;sb,<span class="number">0</span>,<span class="keyword">sizeof</span>(sb));</span><br><span class="line">			stat(dir-&gt;d_name,&amp;sb);</span><br><span class="line">			chdir(ddir);</span><br><span class="line">			create_fd = creat(dir-&gt;d_name,sb.st_mode);</span><br><span class="line">			<span class="comment">// 写入内容，调用复制，自行填写</span></span><br><span class="line">			close(create_fd);</span><br><span class="line">			chdir(sdir);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">closedir(dp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>目录操作</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下文件读写的操作</title>
    <url>/posts/Linux-file-readandwrite.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：Linux系统管理与开发课程中对于文件的读写操作的认识并且运用C语言进行模拟读、写和复制操作。</p>
<a id="more"></a>

<h2 id="文件开关以及读写说明"><a href="#文件开关以及读写说明" class="headerlink" title="文件开关以及读写说明"></a>文件开关以及读写说明</h2><h3 id="读操作read"><a href="#读操作read" class="headerlink" title="读操作read()"></a>读操作read()</h3><blockquote>
<p> read(int fd,  void *buf,  size_t count);</p>
</blockquote>
<p>len: 请求读取的字节数</p>
<p>返回值：</p>
<p>​        -1 ：读取失败</p>
<p>​        0：没有读取到数据</p>
<p>​        n：读取到的字节数（n:1~len)</p>
<p>实际情况下：</p>
<p>​        &lt; 0 : 失败</p>
<p>​        = len: 正常读取</p>
<p>​        = 0~len-1: 读取完毕</p>
<h3 id="写操作write"><a href="#写操作write" class="headerlink" title="写操作write()"></a>写操作write()</h3><blockquote>
<p> write(int fd, const void *buf, size_t count);</p>
</blockquote>
<p>返回值：</p>
<p>​        -1 ：读取失败</p>
<p>​        n：写入字符个数（n:1~len)</p>
<h3 id="打开文件open-creat"><a href="#打开文件open-creat" class="headerlink" title="打开文件open()/creat()"></a>打开文件open()/creat()</h3><blockquote>
<p> creat(文件名称,权限模式)；   =     open(文件名称,O_CREAT,权限模式)；</p>
</blockquote>
<p>类型：</p>
<table>
<thead>
<tr>
<th align="center">O_RDONLY</th>
<th align="center">O_WRONLY</th>
<th align="center">O_RDWR</th>
<th align="center">O_APPEND</th>
<th align="center">O_CREAT</th>
<th align="center">O_TRUNC</th>
</tr>
</thead>
<tbody><tr>
<td align="center">只读</td>
<td align="center">只写</td>
<td align="center">读写</td>
<td align="center">末尾追加</td>
<td align="center">若文件存在，此标志无用；若不存在，建新文件</td>
<td align="center">若文件存在，则长度被截为0，属性不变</td>
</tr>
</tbody></table>
<p>权限模式：</p>
<p>S_I &lt;权限&gt;&lt;对象&gt;</p>
<p>​    权限：R, W, X, RWX</p>
<p>​    对象：USR, GRP, OTH, U, G, O</p>
<p>​    举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usr:rwx;	group:rw;	other:r;</span><br><span class="line">creat(&quot;test&quot;, S_IRWXU | S_IRGRP |S_IROTH);</span><br><span class="line">=</span><br><span class="line">open(&quot;test&quot;,O_CREAT, S_IRWXU | S_IRGRP |S_IROTH)</span><br></pre></td></tr></table></figure>

<p>tips:</p>
<p>权限位：3个八进制数</p>
<p>764</p>
<p>creat(“test”,010764);</p>
<h3 id="关闭文件close"><a href="#关闭文件close" class="headerlink" title="关闭文件close()"></a>关闭文件close()</h3><blockquote>
<p>close(句柄);</p>
</blockquote>
<h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p>解释一下<code>int main(int argc, char** argv)</code>的意思:</p>
<p>例如一条指令：cp abc.txt xyz.log</p>
<p>则 <code>argc = 3</code> （指令的三个部分）        <code>argv[0] = cp</code>    <code>argv[1]=abc.txt</code>    <code>argv[2]= xyz.log</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 512</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bail</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Error(%d):"</span>,errno);</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> read_return = <span class="number">-1</span>;</span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">		bail(<span class="string">"open file error."</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"fd = %d \n"</span>,fd);</span><br><span class="line">	</span><br><span class="line">	read_return = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">	<span class="keyword">while</span>(read_return &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s"</span>,buf);</span><br><span class="line">		<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">		read_return = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (read_return &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		close(fd);</span><br><span class="line">		bail(<span class="string">"read file error."</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 512</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bail</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Error(%d):"</span>,errno);</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> write_return = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> read_return = <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">//fd = open(argv[1],O_WRONLY);   //以只写的方式写入</span></span><br><span class="line">	<span class="comment">//fd = open(argv[1],O_WRONLY | O_APPEND);	//以只写＋尾部追加的方式写入</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>],O_CREAT | O_WRONLY | O_APPEND, S_IRUSR | S_IRGRP | S_IROTH);</span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>) </span><br><span class="line">		bail(<span class="string">"open file error."</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"fd = %d \n"</span>,fd);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"&gt;"</span>);</span><br><span class="line">	gets(buf);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">strcmp</span>(buf, <span class="string">"quit"</span>) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		write_return = write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">		<span class="keyword">if</span>(write_return &lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		close(fd);</span><br><span class="line">		bail(<span class="string">"Write file error."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(buf , <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"&gt;"</span>);</span><br><span class="line">		gets(buf);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="复制功能的实现"><a href="#复制功能的实现" class="headerlink" title="复制功能的实现"></a>复制功能的实现</h2><ol>
<li>打开源文件</li>
<li>创建目标文件</li>
<li>读取源文件</li>
<li>写入目标文件</li>
<li>关闭句柄退出</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 512</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bail</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Error(%d):"</span>,errno);</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> read_fd = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> write_fd = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> write_return = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> read_return = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	read_fd = open(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line">	write_fd = open(argv[<span class="number">2</span>],O_CREAT | O_RDWR , <span class="number">010755</span>);</span><br><span class="line">	<span class="keyword">if</span>(read_fd &lt; <span class="number">0</span>) </span><br><span class="line">		bail(<span class="string">"open file error."</span>);</span><br><span class="line">	<span class="keyword">if</span>(write_fd &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		close(read_fd);</span><br><span class="line">		bail(<span class="string">"Create file error."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	read_return = read(read_fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">	<span class="keyword">while</span>( read_return &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		write_return = write(write_fd, buf , read_return);</span><br><span class="line">		<span class="keyword">if</span>(write_return &lt; read_return)</span><br><span class="line">		&#123;</span><br><span class="line">			close(read_fd);</span><br><span class="line">			close(write_fd);</span><br><span class="line">			bail(<span class="string">"Write file error."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">		read_return = read(read_fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(read_fd &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		close(read_fd);</span><br><span class="line">		close(write_fd);</span><br><span class="line">		bail(<span class="string">"Read file error."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	close(read_fd);</span><br><span class="line">	close(write_fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tips:</p>
<p>复制操作中关于文件权限判断和使用的问题未能成功实现，留待下次更新。</p>
<p>—3.18更新—</p>
<h2 id="访问文件（判断权限）"><a href="#访问文件（判断权限）" class="headerlink" title="访问文件（判断权限）"></a>访问文件（判断权限）</h2><p>access函数使用方法：</p>
<blockquote>
<p>access(“文件名称”,测试权限)</p>
<p>测试权限：</p>
<p>​    R_OK:读可以</p>
<p>​    W_OK:写可以</p>
<p>​    X_OK:执行可以</p>
<p>​    F_OK:文件存在</p>
<p>返回值：</p>
<p>​    0：测试成功</p>
<p>​    -1：测试失败</p>
</blockquote>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200318101428.png" alt></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bail</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Error(%d):"</span>,errno);</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	ret = access(argv[<span class="number">1</span>],F_OK);</span><br><span class="line">    <span class="comment">//ret = access(argv[1],F_OK | X_OK);     //同时检测满足文件是否同时存在和可执行</span></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"File not exist.\n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"File exist.\n"</span>);</span><br><span class="line">	close(ret);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就很好的解释了在读写前可以使用access函数判断权限。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">读操作：</span><br><span class="line"></span><br><span class="line">ret = access(argv[<span class="number">1</span>],F_OK | R_OK);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret ==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	fd = open();</span><br><span class="line"></span><br><span class="line">写操作：</span><br><span class="line"></span><br><span class="line">ret = access(argv[<span class="number">1</span>],F_OK );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ret &lt;<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	fd = creat();</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"overwrite?"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="获取状态信息"><a href="#获取状态信息" class="headerlink" title="获取状态信息"></a>获取状态信息</h2><p>stat函数：</p>
<blockquote>
<p>struct stat st;</p>
<p>stat(“文件名”，&amp;st);</p>
<p>返回值：</p>
<p>​    -1：失败</p>
<p>st返回值：</p>
<p>​    st.st_size：文件大小</p>
<p>​    st.st_mode：文件类型、权限</p>
<p>​    st.st_xtim：时间相关参数（秒为单位，用ctime转换）</p>
<p>​    st.mode：</p>
<p>​                    ①st.mode&amp;S_IFMT</p>
<p>​                    ②宏函数：S_ISDIR、S_ISREG、S_ISLNK、S_ISFIFO、S_ISCHR、S_ISSOCK</p>
</blockquote>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200318102758.png" alt></p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200318103031.png" alt></p>
<h4 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bail</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Error(%d):"</span>,errno);</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">bs</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(&amp;bs,<span class="number">0</span>,<span class="keyword">sizeof</span>(bs));</span><br><span class="line">	ret = stat(argv[<span class="number">1</span>],&amp;bs);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		bail(<span class="string">"Stat error.\n"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (S_ISDIR(bs.st_mode))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">" %s \t"</span>,<span class="string">"D"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(bs.st_mode))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">" %s \t"</span>,<span class="string">"-"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (S_ISLNK(bs.st_mode))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">" %s \t"</span>,<span class="string">"l"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">" %s \t"</span>,<span class="string">"u"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\t"</span>,bs.st_size);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%o\t"</span>,bs.st_mode);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\t"</span>,ctime(&amp;bs.st_atime));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一下为运行截图</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200318144324692.png" alt="image-20200318144324692"></p>
<h4 id="获取权限信息并复制到另一文件"><a href="#获取权限信息并复制到另一文件" class="headerlink" title="获取权限信息并复制到另一文件"></a>获取权限信息并复制到另一文件</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bail</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Error(%d):"</span>,errno);</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> dfd = <span class="number">-1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">bs</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;bs , <span class="number">0</span>, <span class="keyword">sizeof</span>(bs));</span><br><span class="line">	ret = stat(argv[<span class="number">1</span>],&amp;bs);</span><br><span class="line">	dfd = creat(argv[<span class="number">2</span>],bs.st_mode);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下图所示</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200318144820783.png" alt="image-20200318144820783"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件读写</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下用户管理的程序设计</title>
    <url>/posts/linux-user-program.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：此为在Linux下的用户管理中运用C语言程序设计来获得用户信息。</p>
<a id="more"></a>

<p>代码很简单，uid是当前用户的ID号，euid是当前用户的有效用户ID号。</p>
<p>其中：</p>
<p>#include &lt;unistd.h&gt;是Unix的标准库函数，以后会很经常用到。</p>
<p>#include &lt;sys/types.h&gt;是Uni/Linux系统的基本系统数据类型的头文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">uid_t</span> uid = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">uid_t</span> euid = <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	uid = getuid();</span><br><span class="line">	euid = geteuid();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"uid = %d, euid = %d \n"</span>,uid,euid);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接来执行一下就可以看到uid和euid了~</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200312204341.png" alt></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>Linux</tag>
        <tag>程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下的用户管理与操作</title>
    <url>/posts/linux-user-management.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：这为学习Linux系统管理与开发课程中对于用户管理的一些使用和总结。</p>
<a id="more"></a>

<h2 id="用户操作基本命令"><a href="#用户操作基本命令" class="headerlink" title="用户操作基本命令"></a>用户操作基本命令</h2><blockquote>
<p> who:    显示当前实际用户</p>
<p>whoami:    当前使用的用户</p>
<p>users：    同who</p>
<p>w:    显示详细信息</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200311210157.png" alt></p>
<blockquote>
<p> id:显示用户身份</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200311210020.png" alt></p>
<h2 id="时间相关"><a href="#时间相关" class="headerlink" title="时间相关"></a>时间相关</h2><blockquote>
<p>date:     显示当前系统时间</p>
<p>time：    显示系统运行时间，系统时间片的分配</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200311212507.png" alt></p>
<blockquote>
<p>cal:    显示当前月份的日历</p>
<p>cal &lt;年份&gt;：    显示一整年的日历</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200311212745.png" alt></p>
<p>特殊的：1752年的日历和其他的不一样，历法上修订新历会导致九月份不一样。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200311212915.png" alt></p>
<p>以下可以显示离1970-01-01 后99999天的日期。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[hongcyu@localhost etc]$ date -d &quot;1970-01-01 99999days&quot;</span><br></pre></td></tr></table></figure>

<h2 id="目录相关"><a href="#目录相关" class="headerlink" title="目录相关"></a>目录相关</h2><blockquote>
<p>pwd:    显示当前目录路径</p>
<p>cd &lt;路径&gt; :    更改当前路径</p>
<p>cd    :回到初始目录</p>
<p>./    :当前目录</p>
<p>../    :上一个目录（父目录）</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200311213248.png" alt></p>
<blockquote>
<p>ls    ：显示当前目录下的文件</p>
<p>ls -l    :显示文件并包含详细信息</p>
<p>ls | more    :以翻页的方式查看目录文件</p>
<p>mv &lt; filename1 &gt;  &lt; filename2 &gt;     ：将文件进行备份</p>
<p>rm &lt; filename &gt;：      删除文件</p>
<p>rm -r     :删除目录</p>
<p>cat &lt; filename &gt;    :查看文件内容</p>
<p>head/tail &lt; filename &gt;    :从头/尾查看文件（每次10行）</p>
</blockquote>
<h2 id="用户配置文件"><a href="#用户配置文件" class="headerlink" title="用户配置文件"></a>用户配置文件</h2><ol>
<li>用户信息文件     /etc/passwd</li>
<li>影子文件     /etc/shadow</li>
<li>组信息文件     /etc/group</li>
<li>组影子文件     /etc/gshadow</li>
</ol>
<p>用户管理中安全等级越高，月需要用户分级管理</p>
<h3 id="口令文件"><a href="#口令文件" class="headerlink" title="口令文件"></a>口令文件</h3><p>打开 /etc/passwd查看用户基本信息，每一行代表一个用户</p>
<blockquote>
<p>· 用户名称</p>
<p>· 用户密码标识</p>
<p>· 用户ID</p>
<p>· 组编号</p>
<p>· 用户说明</p>
<p>· 家目录</p>
<p>· 用户对应的bash</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200311214850.png" alt></p>
<p>一共分成7个部分，其中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root   :          x         :   0   :   0   :   root   : /root:  /bin/bash</span><br><span class="line">用户名称： 口令(X标识符表示存在) : 用户ID : 组编号： 用户说明  ：家目录： 用户对应的bash</span><br></pre></td></tr></table></figure>

<p>tips：</p>
<ol>
<li>只要你的用户ID为0即为超级用户</li>
<li>后期创建的用户由于系统保留从1000开始。可以再/etc/login.defs查看。</li>
<li>/sbin/nologin表示不可以登入</li>
</ol>
<h3 id="影子文件"><a href="#影子文件" class="headerlink" title="影子文件"></a>影子文件</h3><p>分别代表：</p>
<blockquote>
<p>· 用户名称</p>
<p>· 加密密码（SHA512)</p>
<p>· 最后修改密码时间（时间戳模式，1970-1-1）</p>
<p>· 两次密码的修改间隔时间（0 表示可以不修改）</p>
<p>· 密码有效期</p>
<p>· 密码到期提醒时间（提前提醒）</p>
<p>· 到期后宽限时间（0：立即失效 ；-1永不失效）</p>
<p>· 账户失效时间</p>
<p>· 保留</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200311220950.png" alt></p>
<h3 id="组信息文件"><a href="#组信息文件" class="headerlink" title="组信息文件"></a>组信息文件</h3><blockquote>
<p>· 组名称</p>
<p>· 组密码标识</p>
<p>· GID</p>
<p>· 组中附加用户</p>
</blockquote>
<h3 id="组影子文件"><a href="#组影子文件" class="headerlink" title="组影子文件"></a>组影子文件</h3><p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200311223253.png" alt></p>
<h2 id="用户与组的添加"><a href="#用户与组的添加" class="headerlink" title="用户与组的添加"></a>用户与组的添加</h2><p>tips：用户和组的添加需要管理员权限！</p>
<h3 id="添加一个全新的用户"><a href="#添加一个全新的用户" class="headerlink" title="添加一个全新的用户"></a>添加一个全新的用户</h3><blockquote>
<p>用户添加    useradd &lt; username &gt;</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hongcyu@localhost etc]$ su</span><br><span class="line">密码：</span><br><span class="line">[root@localhost etc]# useradd bob</span><br><span class="line">[root@localhost etc]#</span><br></pre></td></tr></table></figure>

<p>只要不报错即为添加成功。</p>
<blockquote>
<p>tips:</p>
<p>可以使用管道来强制修改密码，在超级用户下使用：</p>
<p>echo 123456 | passwd &lt; username &gt;</p>
</blockquote>
<p>接着到passwd文件中可以看的出来bob这个用户已经添加成功了</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200312084223.png" alt></p>
<p>到口令文件（shadow）下查看也添加成功了，不过会发现一个问题，bob没有密码！</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200312084301.png" alt></p>
<p>再看一下组信息文件发现也添加成功了，名称与用户名一致。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200312084459.png" alt></p>
<p>组影子文件就不看了。</p>
<p>接着退出管理员用户，尝试用su切换用户发现，bob登录不了，因为没有口令！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost etc]# exit</span><br><span class="line">exit</span><br><span class="line">[hongcyu@localhost etc]$ su bob</span><br><span class="line">密码：</span><br><span class="line">su: 鉴定故障</span><br><span class="line">[hongcyu@localhost etc]$</span><br></pre></td></tr></table></figure>

<p>接着到bob的目录去看一下发现进入不了，原因是现在我是hongcyu这个用户，没有权限访问bob的目录，可以用<code>ls -l</code>查看权限。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200312084805.png" alt></p>
<p>解决这个问题的办法就是给用户设置口令。</p>
<blockquote>
<p>passwd 表示修改当前用户的口令</p>
</blockquote>
<blockquote>
<p>passwd   &lt; username &gt;  修改其他用户的口令</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[hongcyu@localhost home]$ su</span><br><span class="line">密码：</span><br><span class="line">[root@localhost home]# passwd bob</span><br><span class="line">更改用户 bob 的密码 。</span><br><span class="line">新的 密码：</span><br><span class="line">重新输入新的 密码：</span><br><span class="line">passwd：所有的身份验证令牌已经成功更新。</span><br></pre></td></tr></table></figure>

<p>接着回到hongcyu用户使用<code>su bob</code>切换用户。这个时候会发现（bob@localhost hongcyu）是由hongcyu切换到了bob用户。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[hongcyu@localhost ~]$ su bob</span><br><span class="line">密码：</span><br><span class="line">[bob@localhost hongcyu]$</span><br></pre></td></tr></table></figure>

<p>这个时候查看bob的目录下会发现啥也没干就存在着文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200312090337.png" alt></p>
<p>其实是每个用户在创建时会自动生成一些配置文件，而这些文件在每个用户最先配置时都是一样的。其实进入<code>/etc/skel</code>会发现存在的一样的文件，很好的解释了是在用户创建的最后把skel下的文件复制了过去。所以作为一个管理员，如果你想向新用户发送一个信息，就可以在skel下创建文件，这样每当创建新用户时就会将skel下的文件全部的复制过去。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200312090541.png" alt></p>
<h3 id="将新用户添加到已有的目录"><a href="#将新用户添加到已有的目录" class="headerlink" title="将新用户添加到已有的目录"></a>将新用户添加到已有的目录</h3><blockquote>
<p>useradd -d &lt; route &gt; &lt; username &gt;</p>
</blockquote>
<p>首先进入管理员用户，到/home下自己用<code>mkdir</code>创建一个新的文件夹</p>
<p>接着使用<code>useradd -d /home/tomtom tom</code>来指定新用户的家目录，会产生一个警告，是因为如果没有刚刚创建的<code>tomtom</code>文件夹的话，系统会自己创建并复制初始配置文件，但是由于我们是自己先前已经创建的目录，可以看到提示说不从 skel 目录里向其中复制任何文件。如果想有的话可以手动从skel复制过去。</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/2133134134.png" alt></p>
<h3 id="创建新的组"><a href="#创建新的组" class="headerlink" title="创建新的组"></a>创建新的组</h3><blockquote>
<p>useradd -g &lt; groupname &gt; &lt; username &gt;</p>
</blockquote>
<p>需要注意的是，在创建用户时如果未指定组的话会自带创建一个名字和用户名一样的组。</p>
<p>接着我们使用命令去创建用户时会发现提示错误，那么到底是添加成功还是添加不成功呢。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost home]# useradd -g mygroup alice</span><br><span class="line">useradd：“mygroup”组不存在</span><br></pre></td></tr></table></figure>

<p>我们到passwd文件里发现并没有Alice用户的存在，说明了不能指定用户添加入不存在的组。</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200312093512.png" alt></p>
<p>所以想将新用户指定到固定的组时需要先添加组。</p>
<blockquote>
<p>groupadd  &lt; groupname &gt;</p>
</blockquote>
<p>创建组成功后接着运行之前创建用户的命令即可创建新用户成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost etc]# groupadd mygroup</span><br><span class="line">[root@localhost etc]# useradd -g mygroup alice</span><br><span class="line">[root@localhost etc]#</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200312104602.png" alt></p>
<h3 id="将新用户加入多个组"><a href="#将新用户加入多个组" class="headerlink" title="将新用户加入多个组"></a>将新用户加入多个组</h3><blockquote>
<p>useradd -G &lt; groupname1 &gt;,&lt; groupname2 &gt;， …  &lt; username &gt;</p>
</blockquote>
<p>我们执行<code>useradd -G mygroup,bob sonya</code>后到group中看一下，可以发现bob和mygroup中都有了sonya这个用户。</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200312104912.png" alt></p>
<h3 id="将用户添加到组"><a href="#将用户添加到组" class="headerlink" title="将用户添加到组"></a>将用户添加到组</h3><blockquote>
<p>gpasswd -a &lt; username &gt; &lt; groupname &gt;</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost etc]# gpasswd -a sonya bob</span><br><span class="line">正在将用户“sonya”加入到“bob”组中</span><br><span class="line">[root@localhost etc]#</span><br></pre></td></tr></table></figure>

<h3 id="自定义用户号和组号"><a href="#自定义用户号和组号" class="headerlink" title="自定义用户号和组号"></a>自定义用户号和组号</h3><blockquote>
<p>useradd -u&lt; number &gt; &lt; username &gt;</p>
</blockquote>
<p>我们执行<code>useradd -u8888 testuser</code>后到passwd下查看可以看到详细信息</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200312105332.png" alt></p>
<h2 id="用户与组的删除"><a href="#用户与组的删除" class="headerlink" title="用户与组的删除"></a>用户与组的删除</h2><h3 id="删除所在组的成员"><a href="#删除所在组的成员" class="headerlink" title="删除所在组的成员"></a>删除所在组的成员</h3><blockquote>
<p>gpasswd -d &lt; username &gt; &lt; groupname &gt;</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost etc]# gpasswd -d sonya bob</span><br><span class="line">正在将用户“sonya”从“bob”组中删除</span><br><span class="line">[root@localhost etc]#</span><br></pre></td></tr></table></figure>

<h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><blockquote>
<p>userdel &lt; username &gt;</p>
</blockquote>
<p>虽然删除成功了但是你会发现它的家目录却并没有被删除。然后你会发现文件夹被超级用户接管了。这样的好处是不会因为勿删导致文件无法找回。</p>
<p>tips：若是删除用户时它的组中有其他成员则组并不会被一起删除。</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200312193020.png" alt></p>
<blockquote>
<p>userdel -r &lt; username &gt;   带家目录一起删除</p>
</blockquote>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200312193624.png" alt></p>
<h3 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h3><blockquote>
<p>groupdel &lt; groupname &gt;</p>
</blockquote>
<p>运行之后发现mygroup 的组被删除了。</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200312193916.png" alt></p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200312193935.png" alt></p>
<h2 id="普通用户的分权"><a href="#普通用户的分权" class="headerlink" title="普通用户的分权"></a>普通用户的分权</h2><p>最经典的当然是在命令前加上<code>sudo</code>啦，以超级用户的权限来执行命令。</p>
<p>那么如何修改权限呢，可以在<code>etc/sudoers</code>下修改。(这个文件不能在vi编辑器下直接编辑，这里提供一个命令<code>visudo</code>来修改。)</p>
<p>这里可以看到<code>root   ALL=(ALL)   ALL</code>是代表着root用户在任何机器任何域可以执行任何命令。</p>
<p>按照如图所示的方法可以将修改口令的权限分配给bob,而后面的<code>/bin/passwd</code>命令可以去/bin目录或者/sbin下查看~</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200312195042.png" alt></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Fadora</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下的网络控制和网络通信</title>
    <url>/posts/Linux-network.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：通过对Linux中的网络、网络控制和网络通信等来了解系统对于网络方面的细节，加强对Linux下网络的认识，加深对网络编程的理解。</p>
<a id="more"></a>

<h2 id="网络基本命令"><a href="#网络基本命令" class="headerlink" title="网络基本命令"></a>网络基本命令</h2><blockquote>
<p>ifconfig</p>
<p>查看当前网络的基本信息</p>
</blockquote>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200408110625465.png" alt="image-20200408110625465"></p>
<p>lo:loop网络回路</p>
<p>ens&lt; number &gt;:网卡名</p>
<p>临时修改方法：</p>
<p>ifconfig &lt;设备&gt; &lt; IP &gt;</p>
<p>ifconfig &lt;设备&gt; netmask &lt;掩码&gt;</p>
<p>ifconfig &lt;设备&gt; broadcast &lt;广播地址&gt;</p>
<p>虚拟网卡：</p>
<p>ens33:&lt;虚拟卡编号&gt;    </p>
<p>例如：ens33:0,ens33:1</p>
<p>刷新配置：</p>
<p>ifconfig &lt;设备&gt; &lt; ip&gt; up/down</p>
<p>例如：ifconfig ens33 192.168.122.11 up/down</p>
<blockquote>
<p>ping</p>
<p>连通性检测</p>
</blockquote>
<blockquote>
<p>traceroute </p>
<p>网络路径追踪</p>
</blockquote>
<blockquote>
<p>netstat</p>
<p>网络状态</p>
</blockquote>
<blockquote>
<p>service NetworkManager start|stop|…</p>
<p>启动/关闭服务</p>
</blockquote>
<h2 id="网络服务于守护进程"><a href="#网络服务于守护进程" class="headerlink" title="网络服务于守护进程"></a>网络服务于守护进程</h2><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><p>即为进程间通信，不同的机器、不同的进程交换信息</p>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>整数（16bit）：0~65535</p>
<p>分类：</p>
<p>公开（0~1023）：紧密绑定 </p>
<p>注册（1024~49151）：松散绑定，系统自动绑定</p>
<p>私有（49152~65535）：系统不分配，用户自定义</p>
<h3 id="网络服务程序-Daemon"><a href="#网络服务程序-Daemon" class="headerlink" title="网络服务程序(Daemon)"></a>网络服务程序(Daemon)</h3><p>监听：端口</p>
<p>工作原理：</p>
<p>S:listen port ，有请求时发生–&gt;fork() 子进程响应请求，父进程继续监听</p>
<p>C:发送请求等待应答</p>
<p>工作模式：</p>
<p>独立：一个服务对应一个端口，高负载用独立</p>
<p>网络：服务监听不同端口，根据端口不同，调用不同进程</p>
<h2 id="DHCP服务"><a href="#DHCP服务" class="headerlink" title="DHCP服务"></a>DHCP服务</h2><ul>
<li><p>目标： 自动分配IP地址，减少出错，减少浪费(局域网)</p>
</li>
<li><p>工作原理：</p>
<p>问：</p>
<p>DHCP服务器：如何接受？向谁应答？</p>
<p>Client客户端：需要分配地址，客户端没有IP地址则需要发送什么？发给谁？</p>
<p>答：</p>
<p>Client发送请求：</p>
<p>源地址：0.0.0.0</p>
<p>目标地址：255.255.255.255（向一切地址发广播）只要DHCP在同一个网段内，则必定会收到应答。</p>
<p>MAC：地址+IP包</p>
<p>DHCP应答：</p>
<ul>
<li><p>DHCP Offer包：IP地址相关信息。</p>
</li>
<li><p>源地址：DHCP服务器IP</p>
</li>
<li><p>目标地址：255.255.255.255</p>
</li>
<li><p>MAC：    源地址：DHCP的MAC    目标地址：client的MAC</p>
</li>
</ul>
<p>问：假如网络中多个DHCP服务器，就会有多个应答，client如何处理？</p>
<p>答：按照先来先接收的原则。</p>
<p>Client：确认IP租用信息，DHCPQuest包：说明已经接收到的IP地址（包括client的IP地址+DHCP服务器IP地址）</p>
<p>DHCP服务器确认信息：</p>
<p>DHCP服务刷新：</p>
<p>IP地址的租期（4096），当到达租期的一半时，发送刷新的请求。</p>
<p>服务器应答：刷新出租时间</p>
<p>服务器没有应答：等待，到87.5%时间时再次请求</p>
</li>
</ul>
<h3 id="DHCP配置过程"><a href="#DHCP配置过程" class="headerlink" title="DHCP配置过程"></a>DHCP配置过程</h3><p>1.安装软件</p>
<p>包括DHCP服务器、DHCP客户端</p>
<p>在管理员模式下，输入<code>yum install dhcp*</code>即可查看安装情况。</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200415102421411.png" alt="image-20200415102421411"></p>
<p>可以发现需要安装的软件，直接进行安装。</p>
<p>2.虚拟机设置</p>
<p>关闭计算机–&gt;编辑–&gt; 虚拟网络设置</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200415103014664.png" alt="image-20200415103014664"></p>
<p>选择host-only模式（虚拟机和主机构成直连网络，虚拟机和主机可通信，但是虚拟机不能于Internet通信），即对VMnet1进行操作。</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200415103259136.png" alt="image-20200415103259136"></p>
<p>需要端基更改设置获得管理员权限，再修改DHCP设置。设置成下图</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200415103438192.png" alt="image-20200415103438192"></p>
<p>再将虚拟机的网络设置改为仅主机模式，接着开启虚拟机。</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200415103547015.png" alt="image-20200415103547015"></p>
<p>3.DHCP服务配置</p>
<p>可以发现网络没有被分配IP地址，所以需要给网卡设置IP地址，</p>
<ol>
<li><p>配置IP地址：<code>ifconfig ens33 192.168.66.1 up</code></p>
<p>这里的网段是当初上面有个子网IP的网段。</p>
</li>
<li><p>修改配置文件/etc/dhcp/dhcpd.conf</p>
<p>首先，先进行备份<code>cp dhcpd.conf dhcpd.conf.bak</code></p>
<p>接着打开 dhcpd.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># DHCP Server Configuration file.</span><br><span class="line">#   see /usr/share/doc/dhcp-server/dhcpd.conf.example</span><br><span class="line">#   see dhcpd.conf(5) man page</span><br><span class="line"></span><br><span class="line">#定义domain</span><br><span class="line">option domain-name &quot;mytest.org&quot;;</span><br><span class="line">option domain-name-servers dns.mytest.org;</span><br><span class="line">#分配最大及其默认续租时间</span><br><span class="line">default-lease-time 600;</span><br><span class="line">max-lease-time 7200;</span><br><span class="line">#分配地址池</span><br><span class="line">subnet 192.168.66.0 netmask 255.255.255.128&#123;</span><br><span class="line">        range 192.168.66.10 192.168.66.125;</span><br><span class="line">        option routers 192.168.66.1;</span><br><span class="line">&#125;</span><br><span class="line">#分配固定的IP</span><br><span class="line">host hname&#123;</span><br><span class="line">        hardware ethernet 00:50:56:C0:00:01;</span><br><span class="line">        FIXED-ADDRESS 192.168.66.100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>启动服务</p>
<p>service dhcpd start/status/stop/restart</p>
</li>
<li><p>查看日志</p>
<p>/var/log/messages    或者     journalctl -xe</p>
</li>
<li><p>测试</p>
<p>DHCP客户端选择自动获取IP与DNS。</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200415112146469.png" alt="image-20200415112146469"></p>
</li>
</ol>
<h2 id="DNS服务配置——IP与域名转换"><a href="#DNS服务配置——IP与域名转换" class="headerlink" title="DNS服务配置——IP与域名转换"></a>DNS服务配置——IP与域名转换</h2><ol>
<li><p>工作原理：将域名和IP地址进行转换翻译。</p>
</li>
<li><p>域名管理原则</p>
<p>分级原则：根域（.）、顶级域（com,uk,cn…）、二级域、三级域…</p>
</li>
<li><p>服务器类型</p>
<blockquote>
<p>主域名服务器（权威服务器）</p>
<p>辅助域名服务器（备份、从主服务器复制信息、只读）</p>
<p>缓存域名服务器（服务器软件，但是没有数据库，提供高速缓存、非权威）</p>
<p>转发域名服务器（非本地域名的本地查询）</p>
</blockquote>
</li>
<li><p>工作流程</p>
<p><a href="http://www.mit.edu" target="_blank" rel="noopener">www.mit.edu</a>  –&gt;查看本机缓存（ 浏览器/hosts文件） –&gt; DNS –&gt;  转发服务器/根服务器  (递归或者迭代查询)</p>
</li>
</ol>
<h3 id="配置基本的DNS服务器"><a href="#配置基本的DNS服务器" class="headerlink" title="配置基本的DNS服务器"></a>配置基本的DNS服务器</h3><ol>
<li><p>安装软件</p>
<p><code>yum install bind</code></p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200420144953309.png" alt="image-20200420144953309"></p>
</li>
<li><p>配置</p>
<p>服务端：主配置文件、正向配置文件、反向配置文件</p>
<p>客户端：指定域名选择方式</p>
</li>
<li><p>主配置文件</p>
<p>记录dns服务器的基本参数信息</p>
<blockquote>
<p>port：53    </p>
<p>记录正向、反向配置文件的位置、名称</p>
<p>记录当前域的信息</p>
<p>记录根域</p>
<p>修改etc/named.conf</p>
</blockquote>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200420145644338.png" alt="image-20200420145644338"></p>
<p>以及添加以下自定义内容：</p>
<blockquote>
<p>参数说明：</p>
<p>hint：根服务器</p>
<p>master：主服务器</p>
<p>slaver：从服务器</p>
</blockquote>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200420150612088.png" alt="image-20200420150612088"></p>
</li>
</ol>
<p>   并且到 /var/named下创建 <code>infosecurity.org.zone</code>配置<strong>正向配置文件</strong></p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$TTL    1D</span><br><span class="line">@       IN      SOA     infosecurity.org.       adm.infosecurity.org.(</span><br><span class="line">                                                        0;</span><br><span class="line">                                                        1D;</span><br><span class="line">                                                        1H;</span><br><span class="line">                                                        1W;</span><br><span class="line">                                                        3H);</span><br><span class="line">        IN      NS      dns</span><br><span class="line">        IN      A       192.168.17.130</span><br><span class="line">www     IN      A       192.168.17.130</span><br><span class="line">mail    IN      A       192.168.17.130</span><br><span class="line">ftp     IN      A       192.168.17.130</span><br><span class="line">dns     IN      A       192.168.17.130</span><br></pre></td></tr></table></figure>

<p>   最后一个 * 是代表所以都指向一个服务器。</p>
<p>   这里是dns：192.168. * * *. * * *可以从ifconfig中查看本机ip</p>
<ol start="4">
<li><p>修改/etc/hosts文件 加入域名服务器信息</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200422101727076.png" alt="image-20200422101727076"></p>
</li>
<li><p>修改/etc/resolv.conf文件</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200422101749789.png" alt="image-20200422101749789"></p>
</li>
<li><p>启动服务</p>
<p><code>service named start</code></p>
</li>
</ol>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200422101937723.png" alt="image-20200422101937723"></p>
<p>可以发现可以ping通了！</p>
<p>tips:</p>
<p>如果发现ping不通的情况下将Linux防火墙的服务器使用命令<code>service firewalld stop</code>关闭即可。</p>
<h3 id="反向配置文件"><a href="#反向配置文件" class="headerlink" title="反向配置文件"></a>反向配置文件</h3><p>修改/etc/named.conf</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200422105034720.png" alt="image-20200422105034720"></p>
<p>并且到 /var/named下创建 17.168.192.zone`配置<strong>反向配置文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$TTL    1D</span><br><span class="line">@       IN      SOA     infosecurity.org.       adm.infosecurity.org.(</span><br><span class="line">                                                        0;</span><br><span class="line">                                                        1D;</span><br><span class="line">                                                        1H;</span><br><span class="line">                                                        1W;</span><br><span class="line">                                                        3H);</span><br><span class="line">        IN      NS      dns.infosecurity.org.</span><br><span class="line">130     IN      PTR     dns.infosecurity.org.</span><br><span class="line">130     IN      PTR     www.infosecurity.org.</span><br><span class="line">130     IN      PTR     mail.infosecurity.org.</span><br></pre></td></tr></table></figure>

<h2 id="web服务"><a href="#web服务" class="headerlink" title="web服务"></a>web服务</h2><ol>
<li><p>工作原理</p>
<p>http/https:协议</p>
<p>www:主机</p>
<p>infosecurity.org:域名</p>
<p>port：80（默认）</p>
</li>
<li><p>安装</p>
<p>yum install httpd*</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200422111130476.png" alt="image-20200422111130476"></p>
</li>
<li><p>配置web服务器</p>
<p>修改配置文件/etc/httpd/conf/httpd.conf：</p>
<p>​    listen:80    #修改监听端口</p>
<p>​    document root：    #制定主页文件目录</p>
<p>​    dorectorityindex:    #设定首页文件名称、类型</p>
</li>
<li><p>启动服务</p>
<p><code>service httpd start</code></p>
</li>
</ol>
<h2 id="FTP文件服务器"><a href="#FTP文件服务器" class="headerlink" title="FTP文件服务器"></a>FTP文件服务器</h2><ol>
<li><p>工作原理</p>
<p>对不同的系统，不同的网络，不同的文件格式进行统一操作。</p>
</li>
<li><p>端口</p>
<p>20和21</p>
<p>主动和被动方式：</p>
<blockquote>
<p>主动:</p>
<p>Client：申请X端口，请求访问server的21端口，server应答，并利用21端口传达控制命令。</p>
<p>server：利用20端口向客户端的X+1端口发出传送请求，进行数据传送。</p>
</blockquote>
<blockquote>
<p>被动:</p>
<p>server连接成功后，给client发送一个端口用于数据传输。</p>
</blockquote>
</li>
<li><p>安装</p>
<p>yum install vsftpd</p>
</li>
<li><p>配置</p>
<p>基本配置文件：/etc/vsftpd/vsftpd.conf</p>
<p>资源文件：/var/ftp</p>
<p>用户类型：匿名、本地、虚拟</p>
<p>匿名</p>
<p>anonymous：可以无口令（或口令为anonymous）</p>
<p>进行备份和过滤：</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200422113039501.png" alt="image-20200422113039501"></p>
<p>将/etc/vsftpd/vsftpd.conf修改为以下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen_port=21</span><br><span class="line">anonymous_enable=YES</span><br><span class="line">write_enable=YES</span><br><span class="line">anon_upload_enable=YES</span><br><span class="line">anon_mkdir_write_enable=YES</span><br><span class="line">anon_other_write_enable=YES</span><br><span class="line">anon_umask=022</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
<p>service vsftpd start</p>
</li>
<li><p>测试登入</p>
<p>安装ftp客户端：yum install ftp</p>
<p>终端输入<code>ftp</code>,填写IP后输入账号密码（均为ftp）即可连接</p>
<p>ftp ip ：登入</p>
<p>cd/binasc</p>
<p>put/get：上传下载</p>
<p>quit：退出</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200427142311393.png" alt="image-20200427142311393"></p>
</li>
<li><p>默认路径</p>
<p>var/ftp/</p>
</li>
<li><p>其他问题</p>
<p>默认路径有没有权限，一般情况下用户上传文件不修改var/ftp权限，应将var/ftp/pub/权限修改为777</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200427141900471.png" alt="image-20200427141900471"></p>
<p>如果还是不能上传 需要关闭SELinux: #<code>setenforce 0</code>，1为打开策略。</p>
</li>
</ol>
<h3 id="本地用户配置"><a href="#本地用户配置" class="headerlink" title="本地用户配置"></a>本地用户配置</h3><ol>
<li><p>创建一个新用户，这里定为叫myftp</p>
</li>
<li><p>修改/etc/passwd下的配置文件为<code>/bin/nologin</code>:</p>
<p>例如：<code>myftp:x:1002:1002::/home/myftp:/bin/nologin</code></p>
</li>
<li><p>修改/etc/vsftpd/vsftpd.conf为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen_port=21</span><br><span class="line">anonymous_enable=YES</span><br><span class="line">write_enable=YES</span><br><span class="line">anon_upload_enable=YES</span><br><span class="line">anon_mkdir_write_enable=YES</span><br><span class="line">anon_other_write_enable=YES</span><br><span class="line">anon_umask=022</span><br><span class="line">local_enable=YES</span><br><span class="line">local_umask=022</span><br><span class="line">pam_service_name=vsftpd</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行命令</p>
<p>#ldd /usr/sbin/vsftpd</p>
<p>#cp /lib64/libpam.so.0 /etc/pam.d</p>
</li>
<li><p>根据需要修改/etc/shells文件，加入/bin/nologin</p>
</li>
<li><p>测试登入</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200427144217992.png" alt="image-20200427144217992"></p>
</li>
<li><p>修改当前用户的家目录</p>
<p>修改etc/passwd：<code>myftp:x:1002:1002::/var/ftp:/bin/nologin</code></p>
</li>
</ol>
<h3 id="虚拟用户"><a href="#虚拟用户" class="headerlink" title="虚拟用户"></a>虚拟用户</h3><ol>
<li><p>修改用户信息</p>
<p>/etc/vsftpd下创建username</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200427145908552.png" alt="image-20200427145908552"></p>
</li>
<li><p>转换信息格式</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200427150136837.png" alt="image-20200427150136837"></p>
</li>
<li><p>修改配置文件</p>
<p>/etc/vsftpd.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen_port=21</span><br><span class="line">anonymous_enable=YES</span><br><span class="line">write_enable=YES</span><br><span class="line">anon_upload_enable=YES</span><br><span class="line">anon_mkdir_write_enable=YES</span><br><span class="line">anon_other_write_enable=YES</span><br><span class="line">anon_umask=022</span><br><span class="line">local_enable=YES</span><br><span class="line">local_umask=022</span><br><span class="line">guest_enable=YES</span><br><span class="line">guest_username=myftp</span><br><span class="line">pam_service_name=vsftpd</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改加密数据文件</p>
<p>/etc/pam.d/vsftpd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auth required /lib64/security/pam_userdb.so db=/etc/vsftpd/vuser</span><br><span class="line">account required /lib64/security/pam_userdb.so db=/etc/vsftpd/vuser</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="5">
<li><p>重启服务</p>
<p>service vsftpd restart</p>
<p>可以发现正常登入了</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200427155401689.png" alt="image-20200427155401689"></p>
</li>
</ol>
<blockquote>
<p>tips:</p>
</blockquote>
<p>在Windows中访问ftp的话需要再/etc/vsftpd/vsftpd.conf下添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pasv_enable=YES</span><br><span class="line">pasv_min_port=3000</span><br><span class="line">pasv_max_port=6000</span><br></pre></td></tr></table></figure>

<p>并在有需要的情况下修改以下选项：</p>
<p>设置IE浏览器&gt;&gt;Internet选项&gt;&gt;高级&gt;&gt;将“使用被动FTP（用于防火墙和DSL调制解调器的兼容）”选项去掉&gt;&gt;确定即可</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20170411162146752.png" alt="20170411162146752"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件权限位的介绍</title>
    <url>/posts/Linux-file-competence.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：在这里介绍一下Linux中比较重要的文件权限位的属性和使用方法，方便大家查阅，此文仅供参考。</p>
<a id="more"></a>

<h2 id="权限位"><a href="#权限位" class="headerlink" title="权限位"></a>权限位</h2><p>权限位指的是文件管理的基本方式。</p>
<blockquote>
<p>第一位：文件类型（使用缩写）</p>
<p>分为pipe（命名管道）、 socket、 block（块设备文件）、 char（字符设备文件）、 dir（目录文件 ）、 link（连接文件）、-（普通文件）</p>
</blockquote>
<blockquote>
<p>第二位到第十位：</p>
<p>属主权限、属组权限、其他权限</p>
<p>own        、group     、other</p>
<p>分为rwx（读、写、执行）三个。</p>
</blockquote>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200318092831.png" alt></p>
<h2 id="用户权限设定"><a href="#用户权限设定" class="headerlink" title="用户权限设定"></a>用户权限设定</h2><p>在这里我们使用名字为test的文件夹进行试验。</p>
<blockquote>
<p>chmod &lt;权限值&gt; &lt;文件&gt;</p>
</blockquote>
<p>取值方法一：</p>
<blockquote>
<p>二进制数 rwx(—)</p>
<p>例如： </p>
<p>chmod 777 test  代表 111 111 111 说明是rwx rwx rwx</p>
<p>chmod 755 test  代表 111 101 101 说明是rwx r-x r-x</p>
</blockquote>
<p>取值方法二：</p>
<blockquote>
<p>chmod &lt;u/g/o/ug/ugo/…&gt;&lt;+/-&gt;&lt;r/w/x&gt;</p>
<p>例如：</p>
<p>chmod u+x abc 代表给test文件增加属主执行的权限</p>
<p>chmod ug-x abc 代表给test文件减少属主和属组执行的权限</p>
</blockquote>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200318094328.png" alt></p>
<p>tips：</p>
<p>在Windows中只有可执行文件才能运行，而在Linux中能不能执行要看两个条件：1.有没有执行权限。2. 本身能不能执行。</p>
<h2 id="分配权限的用户"><a href="#分配权限的用户" class="headerlink" title="分配权限的用户"></a>分配权限的用户</h2><ol>
<li>属主可以给自己文件分配权限</li>
<li>超级用户可以修改所以文件的权限</li>
</ol>
<p>特例： root用户无视一切读写权限，但文件没有执行权限，root也无法执行这个文件。</p>
<h2 id="文件链接"><a href="#文件链接" class="headerlink" title="文件链接"></a>文件链接</h2><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><blockquote>
<p>ln &lt;文件名&gt; &lt;链接名&gt;</p>
</blockquote>
<p>相当与文件的复制</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200318095344.png" alt></p>
<h3 id="软键接"><a href="#软键接" class="headerlink" title="软键接"></a>软键接</h3><blockquote>
<p>ln -s  &lt;文件名&gt; &lt;链接名&gt;</p>
</blockquote>
<p>可以发现有一个<code>→</code></p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200318095517.png" alt></p>
<p>一旦删除testmode.c则link就无法执行</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/20200318095704.png" alt></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络程序设计</title>
    <url>/posts/network-pro.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：Linux下网络程序设计的方案，进行网络相关我程序设计，进一步理解这个Linux系统管理和开发。</p>
<a id="more"></a>

<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><ol>
<li><p>创建套接字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socket( int family,   //协议族	AF_LOCAL,AF_INET,AF_INET6</span><br><span class="line">		int type,	  //socket类型	socke_stream,sock_dgram,socket_raw</span><br><span class="line">		int proto	  //默认为0</span><br><span class="line">		);</span><br></pre></td></tr></table></figure>

<p>成功：正数，相当于句柄</p>
<p>失败：负数</p>
</li>
<li><p>套接字地址：决定ip和port</p>
<p>1）本地套接字</p>
<p>2）网络套接字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct sockaddr in&#123;</span><br><span class="line">	sa_family_t sin_family;	//AF_INET</span><br><span class="line">	uint16_t sin_port;		//端口号</span><br><span class="line">	struct in_addr sin)addr;//ip地址</span><br><span class="line">	unsigned char sin_zero[8];//占位</span><br><span class="line">					&#125;</span><br><span class="line">	struct sockaddr_in_myaddr;</span><br><span class="line">	memset(&amp;myaddr,0,sizeof(myaddr));</span><br><span class="line">    myaddr.sin_family = AF_INET;</span><br><span class="line">    myaddr_sin_port = htons(54321);//h:host,n:net,s:short</span><br><span class="line">    myaddr.sin_addr.s_addr = inet_addr(&quot;192.168.123.123&quot;)//IP转为32位的位串（成功返回对应二进制串，失败返回-1）</span><br><span class="line">    inet_aton(&quot;192.168.123.123&quot;,&amp;myaddr.sin_addr)//失败返回0</span><br></pre></td></tr></table></figure>

<p>3）绑定</p>
<p>bind(int sockfd,(struct sockaddr*)&amp;myaddr,int len);</p>
<p>4）监听：TCPServer</p>
<p>listen(int sockfd,int len);</p>
<p>5）通信：UDP</p>
<p>read与write函数</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程与状态管理及其程序设计</title>
    <url>/posts/Linux-process.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：此为Linux中系统进程与状态管理的具体操作及其程序设计的方法来实现进程管理。</p>
<a id="more"></a>

<p>Linux 进程与状态管理：</p>
<p>状态查看命令</p>
<p>进程控制命令</p>
<p>进程与子进程</p>
<p>信号</p>
<h2 id="常见状态管理命令"><a href="#常见状态管理命令" class="headerlink" title="常见状态管理命令"></a>常见状态管理命令</h2><blockquote>
<p>w:    查看负载  </p>
<p>主要查看1分钟内的负载，需要小于CPU个数或核心数。</p>
</blockquote>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200323150521091.png" alt="image-20200323150521091"></p>
<blockquote>
<p>vmstat:    查看负载具体位置</p>
</blockquote>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200323151818068.png" alt="image-20200323151818068"></p>
<blockquote>
<p>free:    查看内存负载</p>
</blockquote>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200323152023941.png" alt="image-20200323152023941"></p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><blockquote>
<p>ps:查看静态进程状态</p>
<p>常见参数： -ef  、 -aux</p>
</blockquote>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200323152214907.png" alt="image-20200323152214907"></p>
<p>ps -aux | grep 3149 :查看所以与3149有关的进程（过滤）</p>
<blockquote>
<p>top: 查看准动态信息</p>
</blockquote>
<p>stat: S， sleep,终端的进程，绝大多数进程都是S</p>
<p>stat: R ，run，运行中的进程</p>
<p>stat: T， terminate， 停止或者终止的进程</p>
<p>stat: s， 主进程</p>
<p>stat: l，多线程进程</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200323153148107.png" alt="image-20200323153148107"></p>
<h2 id="进程创建方式"><a href="#进程创建方式" class="headerlink" title="进程创建方式"></a>进程创建方式</h2><p>多进程：唯一创建标志 –&gt;进程号</p>
<p>​                特殊进程号：1（一切进程的父进程）</p>
<p>父进程：把子进程创建的进程</p>
<p>子进程：被父进程创建的进程</p>
<p>生成关系： 1:n</p>
<blockquote>
<p>创建进程的函数</p>
<p>ret = fork()</p>
<p>同时返回多于一个的返回值。</p>
<p>ret =  -1    失败</p>
<p>ret != -1 返回两个返回值，分别为<code>0</code>和<code>大于0的数</code> ，其中大于零的返回值为子进程的进程号，所以大于零的返回值给父进程，等于零的返回值给子进程。（相对于一个给父进程，一个给子进程）</p>
</blockquote>
<blockquote>
<p>获取进程号函数</p>
<p>getpid():获得当前进程的进程号</p>
<p>getppid():获得当前进程的父进程的进程号</p>
</blockquote>
<p>问题：当前进程与父进程来确定进程父子关系（√）/当前进程与子进程来确定进程父子关系（X）</p>
<p>答：因为一个父进程有的多个子进程，而一个子进程只有一个父进程，获得父进程编号比较容易。</p>
<h3 id="创建子进程"><a href="#创建子进程" class="headerlink" title="创建子进程"></a>创建子进程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bail</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *err)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(err);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">pid_t</span> ppid = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">pid_t</span> ret = <span class="number">-1</span>;</span><br><span class="line">	ret = fork();</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">		bail(<span class="string">"fork error!\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"return = 0:pid =%d,ppid=%d.\n"</span>,getpid(),getppid());	</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"return &gt; 0:pid =%d,ppid=%d.\n"</span>,getpid(),getppid());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200325103953336.png" alt="image-20200325103953336"></p>
<p>可以看出来fork()函数的返回值中 <code>大于零的返回值给：父进程</code> <code>等于零的返回值给：子进程</code></p>
<p>如果生成三个子进程，下面这段代码中使用for循环会发现出错了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(i=0;i&lt;3;i++)</span><br><span class="line">&#123;</span><br><span class="line">    ret = fork();</span><br><span class="line">    if(ret &lt; 0)</span><br><span class="line">            bail(&quot;fork error!\n&quot;);</span><br><span class="line">        else if(ret == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;pid =%d,ppid=%d.\n&quot;,getpid(),getppid());	</span><br><span class="line">        &#125;	</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;pid =%d,ppid=%d.\n&quot;,getpid(),getppid());</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>主要在于fork()函数创建子进程时，不但生成一个进程，子进程的结构、数据段均来自于父进程。</p>
<p>正确方法如下，调整子进程的部分即可：</p>
<p>子进程要返回：return</p>
<p>父进程要等待：wait</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;error.h&gt;</span><br><span class="line">void bail(const char *err)</span><br><span class="line">&#123;</span><br><span class="line">	perror(err);</span><br><span class="line">	exit(-1);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	pid_t pid = -1;</span><br><span class="line">	pid_t ppid = -1;</span><br><span class="line">	pid_t ret = -1;</span><br><span class="line">	int i = 0;</span><br><span class="line">	for(i = 0;i&lt;3;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ret = fork();</span><br><span class="line">		if(ret &lt; 0)</span><br><span class="line">			bail("fork error!\n");</span><br><span class="line">		else if(ret == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			printf("pid =%d,ppid=%d.\n",getpid(),getppid());	</span><br><span class="line"><span class="addition">+			return 0;</span></span><br><span class="line">		&#125;	</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line"><span class="deletion">-			 printf("pid =%d,ppid=%d.\n",getpid(),getppid());</span></span><br><span class="line"><span class="addition">+			 wait(pid,NULL,0);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200325110123256.png" alt="image-20200325110123256"></p>
<h3 id="子进程调用程序（替换）"><a href="#子进程调用程序（替换）" class="headerlink" title="子进程调用程序（替换）"></a>子进程调用程序（替换）</h3><p>目标：执行用户指定的程序。</p>
<p>开始：子进程代码段数据段都来自父进程。</p>
<p>调用后：子进程的代码段数据段来自于被调用程序。</p>
<blockquote>
<p>execl()函数</p>
</blockquote>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200325111625439.png" alt="image-20200325111625439"></p>
<p>使用子程序实现： <code>ls -l &gt; aaa</code></p>
<p>调用要点：调用的程序位置、名称、path+file</p>
<p>调用参数：不定长的字符串，字符串的个数不一定,当最后一个有效参数给定后用NULL来表示结束</p>
<p>例如：execl(“/bin/ls” , “ls” , “-l” , “&gt;” , “aaa” , NULL)</p>
<p>先获取ls路径</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200325112651718.png" alt="image-20200325112651718"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bail</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *err)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(err);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">pid_t</span> ppid = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">pid_t</span> ret = <span class="number">-1</span>;</span><br><span class="line">	ret = fork();</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">		bail(<span class="string">"fork error!\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"return = 0:pid =%d,ppid=%d.\n"</span>,getpid(),getppid());	</span><br><span class="line">		execl(<span class="string">"/usr/bin/ls"</span>,<span class="string">"ls"</span>,<span class="string">"-l"</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"return &gt; 0:pid =%d,ppid=%d.\n"</span>,getpid(),getppid());</span><br><span class="line">		wait(pid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行就可以看到如下图所示：</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200325112942475.png" alt="image-20200325112942475"></p>
<p>小结：</p>
<blockquote>
<p>execl()函数</p>
<p>execl(“/bin/ls” , “ls” , “-l” , “&gt;” , “aaa” , NULL)</p>
</blockquote>
<blockquote>
<p>execlp()函数</p>
<p>例如：execlp(“ls”,”ls”,”-l”,NULL)</p>
<p>写的时候只要给出调用程序的名称，不要给出路径，系统会在默认路径中查找</p>
</blockquote>
<blockquote>
<p>execv()函数(v:vector向量)</p>
<p>例如：</p>
<p>const char* args[] = {“ls”,”-l”,”&gt;”,”aaa”,NULL}</p>
<p>execv(“/bin/ls”,args)</p>
</blockquote>
<blockquote>
<p>execvp()函数</p>
<p>例如：</p>
<p>const char* args[] = {“ls”,”-l”,”&gt;”,”aaa”,NULL}</p>
<p>execvp(“ls”,args)</p>
</blockquote>
<h2 id="进程控制与通信"><a href="#进程控制与通信" class="headerlink" title="进程控制与通信"></a>进程控制与通信</h2><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号：本质上是一种软中断，系统提供唯一一种异步机制。（中断是系统进程通信的一种形式）</p>
<p>信号分类：标准和实时</p>
<p>信号俘获：</p>
<ol>
<li>默认处理：系统自动完成</li>
<li>忽略处理：不处理</li>
<li>用户自定义：按用户定义函数处理</li>
</ol>
<p>发送和接受：</p>
<ol>
<li>终端输入</li>
<li>硬件产生</li>
<li>软件产生：进程调用、超时、异常。</li>
</ol>
<blockquote>
<p>进程控制命令：<code>kill</code></p>
<p>功能： <font color="red">发送</font>信号给某个进程</p>
<p>kill &lt;信号编号/宏命令&gt; &lt;进程编号&gt;</p>
<p>进程根据收到的信号、执行相关的操作。</p>
<p>列举几个常用的：SIGINT(中断信号 CTRL+C）、 SIGQUIT（退出 CTRL+\）、 SIGKILL（结束当前进程 CTRL+Z）</p>
</blockquote>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200330144025850.png" alt="image-20200330144025850"></p>
<h3 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a>alarm函数</h3><blockquote>
<p>定时器：alarm</p>
<p>unsigned int alarm(unsigned int seconds);</p>
<p>每隔指定秒数 发生一次信号</p>
<p>触发alarm事件：如果同时安装多个alarm函数，则只要最后一个有效</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	alarm(<span class="number">2</span>); <span class="comment">//默认情况下是中断</span></span><br><span class="line">	alarm(<span class="number">3</span>); <span class="comment">//安装第二个定时器，同时屏蔽了上面的alarm</span></span><br><span class="line">	alarm(<span class="number">5</span>); <span class="comment">//第三个定时器，屏蔽上面所有的alarm事件，只执行最后一个</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;=<span class="number">65535000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"i = %d\n"</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="raise函数"><a href="#raise函数" class="headerlink" title="raise函数"></a>raise函数</h3><blockquote>
<p>发送信号给自身：raise</p>
<p>int raise(int sig);</p>
<p>sig:信号值</p>
<p>成功返回：0         失败返回：非0</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>( i = <span class="number">0</span>;i&lt;=<span class="number">65535</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"i = %d \n"</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">	raise(SIGKILL);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">" I am dead!"</span>);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200330153019792.png" alt="image-20200330153019792"></p>
<p>可以看到并没有输出最后一个printf就退出了。</p>
<h3 id="kill函数"><a href="#kill函数" class="headerlink" title="kill函数"></a>kill函数</h3><blockquote>
<p>给指定的进程发送信号：kill</p>
<p>这个和上面的kill有点不一样，这个是介绍程序中的kill，而之前那个是命令kill</p>
<p> int kill(pid_t pid, int sig);</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	kill(atoi(argv[<span class="number">1</span>]),atoi(argv[<span class="number">2</span>]));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先在后台执行一个死循环的程序，接着查看进程号，再运行kill程序就可以发现进程被杀死了。</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200330154559163.png" alt="image-20200330154559163"></p>
<h3 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h3><p>指针函数和函数指针的问题：</p>
<p>指针函数：char* getinf()</p>
<p>函数指针：指向函数首地址的指针，一旦指向函数首地址则表示<font color="red">执行</font>该函数。</p>
<p>typedef void (*sighandler_t)(int);    ——&gt;     void ( * )(int);   //函数指针</p>
<p>举个栗子：</p>
<p>int func (int , int)    返回值 名称  参数</p>
<p>int （*p) (int , int)     返回值 指针说明 参数  （p为指针变量，指向类型int ( * )(int ， int）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">-10</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">-5</span>;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span>(*p)(<span class="keyword">int</span>,<span class="keyword">int</span>);  <span class="comment">//函数指针</span></span><br><span class="line">	p = add;</span><br><span class="line">	ret = (*p)(a,b); <span class="comment">//p是地址 取出d的内容，相当于调用函数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ret = %d \n"</span>,ret);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们说一下signal函数：</p>
<blockquote>
<p>signal函数</p>
<p>typedef void (*sighandler_t)(int);</p>
<p>sighandler_t signal(int signum, sighandler_t handler);</p>
</blockquote>
<p>工作方式：</p>
<ol>
<li>加载signal函数</li>
<li>等待触发</li>
<li>触发后执行</li>
</ol>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200330153306297.png" alt="image-20200330153306297"></p>
<h4 id="调用系统函数"><a href="#调用系统函数" class="headerlink" title="调用系统函数"></a>调用系统函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		signal(SIGINT,SIG_DEL);</span><br><span class="line">		<span class="comment">//signal(SIGINT , SIG_IGN); //忽略sigint信号</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"TEST\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调用用户自定义函数"><a href="#调用用户自定义函数" class="headerlink" title="调用用户自定义函数"></a>调用用户自定义函数</h4><p>单个signal信号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void abc(int sig)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;\n abc : signal is %d\n&quot;,sig);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	signal(SIGINT,abc); //调用用户自定义函数</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;TEST\n&quot;);</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200401103539531.png" alt="image-20200401103539531"></p>
<p>多个signal信号：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abc</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(sig)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> SIGINT: <span class="built_in">printf</span>(<span class="string">" This is SIGINT.\n"</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SIGUSR1: <span class="built_in">printf</span>(<span class="string">" This is SIGUSR1.\n"</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> SIGUSR2: <span class="built_in">printf</span>(<span class="string">" This is SIGUSR2.\n"</span>); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"NULL\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	signal(SIGINT,abc);</span><br><span class="line">	signal(SIGUSR1,abc);</span><br><span class="line">	signal(SIGUSR2,abc);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//signal(SIGINT , SIG_IGN);</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"TEST\n"</span>);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200401104226138.png" alt="image-20200401104226138"></p>
<h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><p>IPC:InterProcess Communication 进程间通信</p>
<p>管道（信道，用标识符标定，用read和write读写）：</p>
<p>分类：</p>
<ol>
<li>有名管道：文件系统中的标识</li>
<li>无名管道：无法按名称进行访问</li>
</ol>
<h3 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h3><p>pipe：int pipe(int fd[2]) 成功返回0并生成文件描述</p>
<p>​            fd[2]:记录文件描述符(    fd[0]:读端口   fd[1]:写端口    )</p>
<p>通信流程：</p>
<p>​            读：缓冲区是否为空，如为空则进程阻塞等待。</p>
<p>​            写：缓冲区是否为满，如为满则进程堵塞等待。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int fd[2] = &#123;0&#125;;</span><br><span class="line">	char buf[128] = &#123;0&#125;;</span><br><span class="line">	char msg[128] = &#123;0&#125;;</span><br><span class="line">	int ret = -1;</span><br><span class="line">	</span><br><span class="line">	ret = pipe(fd);</span><br><span class="line">	ret = fork();</span><br><span class="line">	if (ret == 0)</span><br><span class="line">	&#123;	</span><br><span class="line">		printf(&quot;Child[%d]\n&quot;,getpid());</span><br><span class="line">		sprintf(msg,&quot;%s:%d\n&quot;,&quot;child&quot;,getpid());//把打印结果显示到字符串中</span><br><span class="line">		sleep(2);</span><br><span class="line">		write(fd[1],msg,strlen(msg));</span><br><span class="line">		close(fd[1]);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	else if(ret &lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;error!\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Father[%d]\n&quot;,getpid());</span><br><span class="line">		read(fd[0],buf,sizeof(buf));</span><br><span class="line">		printf(&quot;recv:%s \n&quot;,buf);</span><br><span class="line">		close(fd[0]);</span><br><span class="line">		sleep(0);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有名管道FIFO"><a href="#有名管道FIFO" class="headerlink" title="有名管道FIFO"></a>有名管道FIFO</h3><p>FIFO：First in First out</p>
<p>管道：缓冲区、单向、阻塞</p>
<p>有名管道：文件系统中的名称，是特殊文件（open、read、write、close）</p>
<p>创建管道：</p>
<ol>
<li>命令： mkfifo &lt;管道名称&gt;</li>
<li>函数调用（C）：mkfifo(&lt;名称&gt;,&lt;访问权限&gt;)</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    umask(<span class="number">111</span>);</span><br><span class="line">	ret = mkfifo(argv[<span class="number">1</span>],<span class="number">0664</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200408102830668.png" alt="image-20200408102830668"></p>
<p>传送信息：</p>
<p>tips：不可用读写权限进行打开，因为管道是单向的。只能是只读或只写。</p>
<p>fifoA.C:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> ffd = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> pfd = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">4096</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> msg[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	ffd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">	pfd = open(<span class="string">"./FIFO"</span>,O_WRONLY);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>((ret = read(ffd,buf,<span class="keyword">sizeof</span>(buf)))&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ret = write(pfd,buf,ret);</span><br><span class="line">		<span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	close(ffd);</span><br><span class="line">	close(pfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fifoB.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> pfd = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">4096</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> msg[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	pfd = open(<span class="string">"./FIFO"</span>,O_RDONLY);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(ret = read(pfd,buf,<span class="keyword">sizeof</span>(buf))&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">puts</span>(buf);</span><br><span class="line">		<span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	close(pfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200408105947811.png" alt="image-20200408105947811"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora极简教程</title>
    <url>/posts/56339.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要： <strong>Markdown</strong> 是一种<strong>轻量级</strong>标记语言，创始人是<strong>约翰·格鲁伯</strong>（John Gruber）。它允许人们 “使用易读易写的纯文本格式编写文档，然后转换成有效的 HTML 文档。”</p>
<a id="more"></a>

<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>Typora官方下载：<a href="https://www.typora.io/#download" target="_blank" rel="noopener">https://www.typora.io/#download</a></p>
<hr>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ul>
<li>加粗： <code>Ctrl/Cmd + B</code></li>
<li>标题： <code>Ctrl/Cmd + H</code></li>
<li>插入链接： <code>Ctrl/Cmd + K</code></li>
<li>插入代码： <code>Ctrl/Cmd + Shift + C</code></li>
<li>行内代码： <code>Ctrl/Cmd + Shift + K</code></li>
<li>插入图片： <code>Ctrl/Cmd + Shift + I</code></li>
<li>无序列表： <code>Ctrl/Cmd + Shift + L</code></li>
<li>撤销： <code>Ctrl/Cmd + Z</code></li>
<li>一级标题：快捷键为<code>Ctrl + 1</code>，以此类推</li>
</ul>
<hr>
<h2 id="引用文字"><a href="#引用文字" class="headerlink" title="引用文字"></a>引用文字</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; + 空格 + 引用文字</span></span><br><span class="line"><span class="quote">&gt; 引用内容1</span></span><br><span class="line"><span class="quote">&gt; 引用内容2</span></span><br><span class="line">&gt;&gt; 引用内容3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用内容1<br>引用内容2</p>
<blockquote>
<p>引用内容3</p>
</blockquote>
</blockquote>
<hr>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>输入  <em>列表内容 将创建一个无序列表，该</em>符号可以替换为+或-。</p>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>无序列表1</span><br><span class="line"><span class="bullet">+ </span>无序列表2</span><br><span class="line"><span class="bullet">- </span>无序列表3</span><br></pre></td></tr></table></figure>

<ul>
<li>无序列表1</li>
</ul>
<ul>
<li>无序列表2</li>
</ul>
<ul>
<li>无序列表3</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>有序列表1</span><br><span class="line"><span class="bullet">2. </span>有序列表2</span><br><span class="line"><span class="bullet">3. </span>有序列表3</span><br></pre></td></tr></table></figure>

<ol>
<li>有序列表1</li>
<li>有序列表2</li>
<li>有序列表3</li>
</ol>
<h3 id="多行无序列表"><a href="#多行无序列表" class="headerlink" title="多行无序列表"></a>多行无序列表</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>多行无序列表1</span><br><span class="line">TAB * 多行无序列表2</span><br><span class="line">TAB TAB * 多行无序列表3</span><br></pre></td></tr></table></figure>

<ul>
<li>多行无序列表1<ul>
<li>多行无序列表2<ul>
<li>多行无序列表3</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">-[ ] 不抽烟</span><br><span class="line">-[x] 不喝酒</span><br><span class="line">-[ ] 不烫头</span><br></pre></td></tr></table></figure>

<p>-[ ] 不抽烟<br>-[x] 不喝酒<br>-[ ] 不烫头</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|姓名|性别|年龄|手机号|</span><br><span class="line">|:---|:--:|:--:|---:|</span><br><span class="line">|居左|居中|居中|居右|</span><br><span class="line">|张三|男|21|18975346876|</span><br><span class="line">|李四|女|23|17789548964|</span><br><span class="line">|王五|男|25|15876513546|</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">姓名</th>
<th align="center">性别</th>
<th align="center">年龄</th>
<th align="right">手机号</th>
</tr>
</thead>
<tbody><tr>
<td align="left">居左</td>
<td align="center">居中</td>
<td align="center">居中</td>
<td align="right">居右</td>
</tr>
<tr>
<td align="left">张三</td>
<td align="center">男</td>
<td align="center">21</td>
<td align="right">18975346876</td>
</tr>
<tr>
<td align="left">李四</td>
<td align="center">女</td>
<td align="center">23</td>
<td align="right">17789548964</td>
</tr>
<tr>
<td align="left">王五</td>
<td align="center">男</td>
<td align="center">25</td>
<td align="right">15876513546</td>
</tr>
</tbody></table>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><h4 id="本地图片"><a href="#本地图片" class="headerlink" title="本地图片"></a>本地图片</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[图片上传失败...(image-61fd19-1520850984854)]</span><br></pre></td></tr></table></figure>

<h4 id="网络图片"><a href="#网络图片" class="headerlink" title="网络图片"></a>网络图片</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">pikachu.jpg</span>](<span class="link">https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1564157419510&amp;di=e96d9359d9cba4b936ed55eb804c54bb&amp;imgtype=0&amp;src=http%3A%2F%2Fdata.whicdn.com%2Fimages%2F3045613%2Flarge.jpg</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1564157419510&di=e96d9359d9cba4b936ed55eb804c54bb&imgtype=0&src=http%3A%2F%2Fdata.whicdn.com%2Fimages%2F3045613%2Flarge.jpg" alt="pikachu.jpg"></p>
<h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><h4 id="行内式链接"><a href="#行内式链接" class="headerlink" title="行内式链接"></a>行内式链接</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">我的博客</span>][<span class="symbol">https://hongcyu.github.io</span>]</span><br></pre></td></tr></table></figure>

<p>[我的博客][<a href="https://hongcyu.github.io]" target="_blank" rel="noopener">https://hongcyu.github.io]</a></p>
<h4 id="参考式链接"><a href="#参考式链接" class="headerlink" title="参考式链接"></a>参考式链接</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">CSDN</span>][<span class="symbol">CSDN网址</span>]</span><br><span class="line">[<span class="symbol">CSDN网址</span>]:<span class="link">https://www.csdn.net/</span></span><br></pre></td></tr></table></figure>

<p><a href="https://www.csdn.net/" target="_blank" rel="noopener">CSDN</a></p>
<h4 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">https:</span>//<span class="attr">www.github.com</span>&gt;</span></span></span><br><span class="line">或</span><br><span class="line">https://www.github.com</span><br></pre></td></tr></table></figure>

<p><a href="https://www.github.com" target="_blank" rel="noopener">https://www.github.com</a></p>
<p><a href="https://www.github.com" target="_blank" rel="noopener">https://www.github.com</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br><span class="line"><span class="emphasis">_斜体_</span></span><br></pre></td></tr></table></figure>

<p><em>斜体</em><br><em>斜体</em></p>
<h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**加粗**</span></span><br><span class="line"><span class="strong">__加粗__</span></span><br></pre></td></tr></table></figure>

<p><strong>加粗</strong><br><strong>加粗</strong></p>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线<span class="xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><u>下划线</u></p>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure>

<p><del>删除线</del></p>
<h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">---</span><br><span class="line">___</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
<h3 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Typora[^1]</span><br><span class="line">[^1]A markdown editor</span><br></pre></td></tr></table></figure>

<p>Typora[^1]<br>[^1]A markdown editor</p>
<h3 id="符号的输入"><a href="#符号的输入" class="headerlink" title="符号的输入"></a>符号的输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\\   反斜线</span><br><span class="line">\`   反引号</span><br><span class="line">\*   星号</span><br><span class="line">\_   底线</span><br><span class="line">\&#123; \&#125;  花括号</span><br><span class="line">\[ \]  方括号</span><br><span class="line">\( \)  括弧</span><br><span class="line">\#   井字号</span><br><span class="line">\+   加号</span><br><span class="line">\-   减号</span><br><span class="line">\.   英文句点</span><br><span class="line">\!   惊叹号</span><br></pre></td></tr></table></figure>

<p>\   反斜线<br>`   反引号<br>*   星号<br>_   底线<br>{ }  花括号<br>[ ]  方括号<br>( )  括弧<br>#   井字号<br>+   加号<br>-   减号<br>.   英文句点<br>!   惊叹号</p>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;copy;      版权      </span><br><span class="line">&amp;reg;       注册商标</span><br><span class="line">&amp;trade;     商标</span><br><span class="line">&amp;nbsp;      空格</span><br><span class="line">&amp;amp;       和号</span><br><span class="line">&amp;quot;      引号</span><br><span class="line">&amp;apos;      撇号</span><br><span class="line">&amp;lt;        小于号</span><br><span class="line">&amp;gt;        大于号</span><br><span class="line">&amp;ne;        不等号</span><br><span class="line">&amp;le;        小于等于</span><br><span class="line">&amp;ge;        大于等于</span><br><span class="line">&amp;cent;      分</span><br><span class="line">&amp;pound;     磅</span><br><span class="line">&amp;euro;      欧元</span><br><span class="line">&amp;yen;       元</span><br><span class="line">&amp;sect;      节</span><br><span class="line">&amp;times;     乘号</span><br><span class="line">&amp;divide;    除号</span><br><span class="line">&amp;plusmn;    正负号</span><br></pre></td></tr></table></figure>

<p>&copy;      版权<br>&reg;       注册商标<br>&trade;     商标<br>&nbsp;      空格<br>&amp;       和号<br>&quot;      引号<br>&apos;      撇号<br>&lt;        小于号<br>&gt;        大于号<br>&ne;        不等号<br>&le;        小于等于<br>&ge;        大于等于<br>&cent;      分<br>&pound;     磅<br>&euro;      欧元<br>&yen;       元<br>&sect;      节<br>&times;     乘号<br>&divide;    除号<br>&plusmn;    正负号</p>
<p>附件：[HTML特殊字符编码对照表][<a href="https://www.jb51.net/onlineread/htmlchar.htm]" target="_blank" rel="noopener">https://www.jb51.net/onlineread/htmlchar.htm]</a></p>
<h2 id="插入音乐和视频"><a href="#插入音乐和视频" class="headerlink" title="插入音乐和视频"></a>插入音乐和视频</h2><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><p>1）直接用 HTML 的标签，写法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;audio src=&quot;https://什么什么什么.mp3&quot; style=&quot;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;&quot; controls=&quot;controls&quot; loop=&quot;loop&quot; preload=&quot;meta&quot;&gt;Your browser does not support the audio tag.&lt;/audio&gt;</span><br></pre></td></tr></table></figure>

<p>2）用插件，有显示歌词功能，也美观。首先在<strong>站点</strong>文件夹根目录安装插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-aplayer --save</span><br></pre></td></tr></table></figure>

<p>然后文章中的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% aplayer &quot;歌曲名&quot; &quot;歌手名&quot; &quot;https://什么什么什么.mp3&quot; &quot;https://封面图.jpg&quot; &quot;lrc:https://歌词.lrc&quot; %&#125;</span><br></pre></td></tr></table></figure>

<p>另外可以支持歌单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% aplayerlist %&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;autoplay&quot;: false,</span><br><span class="line">    &quot;showlrc&quot;: 3,</span><br><span class="line">    &quot;mutex&quot;: true,</span><br><span class="line">    &quot;music&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;title&quot;: &quot;歌曲名&quot;,</span><br><span class="line">            &quot;author&quot;: &quot;歌手名&quot;,</span><br><span class="line">            &quot;url&quot;: &quot;https://什么什么什么.mp3&quot;,</span><br><span class="line">            &quot;pic&quot;: &quot;https://封面图.jpg&quot;,</span><br><span class="line">            &quot;lrc&quot;: &quot;https://歌词.lrc&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;title&quot;: &quot;歌曲名&quot;,</span><br><span class="line">            &quot;author&quot;: &quot;歌手名&quot;,</span><br><span class="line">            &quot;url&quot;: &quot;https://什么什么什么.mp3&quot;,</span><br><span class="line">            &quot;pic&quot;: &quot;https://封面图.jpg&quot;,</span><br><span class="line">            &quot;lrc&quot;: &quot;https://歌词.lrc&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endaplayerlist %&#125;</span><br></pre></td></tr></table></figure>

<p>里面的详细参数见 <a href="https://github.com/MoePlayer/hexo-tag-aplayer" target="_blank" rel="noopener">README</a> 和这插件的「母亲」Aplayer 的<a href="https://aplayer.js.org/" target="_blank" rel="noopener">官方文档</a>。关于 <a href="https://baike.baidu.com/item/lrc/46935" target="_blank" rel="noopener">LRC</a>歌词，可以用<a href="https://www.zhihu.com/question/27638171" target="_blank" rel="noopener">工具</a>下载网易云音乐的歌词，另发现暂时不支持<code>offset</code>参数。当然，如果那歌词很操蛋，有错误（比如字母大小写和标点符号乱加）或者时间完全对不上，然后你也和我一样是个完美主义者，那接下来就是令人窒息的操作了，一句一句自己查看修改……</p>
<p>什么，你想把网易云的几百首歌手动同步到博客？慢慢慢，有一种<a href="https://github.com/MoePlayer/hexo-tag-aplayer#meingjs-support-new-in-30" target="_blank" rel="noopener">非常简单的方法</a>，此这种方法也支持单曲，将参数里的<code>playlist</code>更改为<code>song</code>即可，非常建议食用！更多功能请仔细阅读 README。</p>
<h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>1）直接用 HTML 的标签，写法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;video poster=&quot;https://封面图.jpg&quot; src=&quot;https://什么什么什么.mp4&quot; style=&quot;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;&quot; controls=&quot;controls&quot; loop=&quot;loop&quot; preload=&quot;meta&quot;&gt;Your browser does not support the video tag.&lt;/video&gt;</span><br></pre></td></tr></table></figure>

<p>2）用插件，可支持弹幕，首先在站点文件夹根目录安装插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-dplayer --save</span><br></pre></td></tr></table></figure>

<p>然后文章中的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% dplayer &quot;url=https://什么什么什么.mp4&quot; &quot;https://封面图.jpg&quot; &quot;api=https://api.prprpr.me/dplayer/&quot; &quot;id=&quot; &quot;loop=false&quot; %&#125;</span><br></pre></td></tr></table></figure>

<p>要使用弹幕，必须有<code>api</code>和<code>id</code>两项，并且若使用的是官方的 api 地址（即上面的），id 的值不能与<a href="https://api.prprpr.me/dplayer/list" target="_blank" rel="noopener">这个列表</a>的值一样。id 的值自己随便取，唯一要求就是前面这点。如果唯一要求难倒了你，可以使用<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">这个工具</a>将一段与众不同的文字生成一段看起来毫无意义的哈希值，这样看起来是不是好多了。</p>
<p>当然，这个插件的功能还有很多，可以去 <a href="https://github.com/MoePlayer/hexo-tag-dplayer" target="_blank" rel="noopener">README</a> 和这插件的「母亲」Dplayer 的<a href="https://dplayer.js.org/" target="_blank" rel="noopener">官方文档</a>看看。</p>
]]></content>
      <categories>
        <category>书写格式</category>
        <category>Typora</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客Next主题进阶写作技巧</title>
    <url>/posts/13500.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要： 以下博客写作都是基于Next主题，其它主题不一定集成了以下写作方式。</p>
<a id="more"></a>

<h1 id="note标签的官方文档使用"><a href="#note标签的官方文档使用" class="headerlink" title="note标签的官方文档使用"></a>note标签的官方文档使用</h1><p>首先我们需要在<code>Next</code>主题<code>_config.xml</code>中设置一下功能开关，有些默认是开的，有些默认是关的：</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: simple</span><br><span class="line">  icons: false</span><br><span class="line">  border_radius: 3</span><br><span class="line">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span><br><span class="line">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span><br><span class="line">  light_bg_offset: 0</span><br></pre></td></tr></table></figure>

<p>note写作方式正如我最上面的样式，我们可以这样使用：</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note [class] [no-icon] %&#125;</span><br><span class="line">这里写你需要写的内容</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">// 注意上面的class和no-icon属性是可以选择的</span><br><span class="line">[class]   : default | primary | success | info | warning | danger.</span><br><span class="line">[no-icon] : Disable icon in note.</span><br></pre></td></tr></table></figure>

<h3 id="爬坑"><a href="#爬坑" class="headerlink" title="爬坑"></a>爬坑</h3><p>标签开头和结尾在一行的写法是错误的</p>
<p>比如，如果你这样写是错误的：</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note danger %&#125;note text, note text, note text&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<p>或者如果这样写也是错误的：</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note danger %&#125;note text</span><br><span class="line">note text</span><br><span class="line">note text</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<p>内容必须要跟<code>note</code>标签不在一行：</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note danger %&#125;</span><br><span class="line">note text, note text, note text</span><br><span class="line">note text, note text, note text</span><br><span class="line">note text, note text, note text</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="1、没有定义样式类别"><a href="#1、没有定义样式类别" class="headerlink" title="1、没有定义样式类别"></a>1、没有定义样式类别</h4><p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note %&#125;</span><br><span class="line">(没有定义样式类别)</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<p>没有定义样式类别</p>
<h4 id="2、默认的类别"><a href="#2、默认的类别" class="headerlink" title="2、默认的类别"></a>2、默认的类别</h4><p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">默认形式的类别</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<p>默认形式的类别</p>
<h4 id="3、primary形式的类别"><a href="#3、primary形式的类别" class="headerlink" title="3、primary形式的类别"></a>3、primary形式的类别</h4><p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note primary %&#125;</span><br><span class="line">首要类型形式</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<p>首要类型形式</p>
<h4 id="4、info形式的类别"><a href="#4、info形式的类别" class="headerlink" title="4、info形式的类别"></a>4、info形式的类别</h4><p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note info %&#125;</span><br><span class="line">info形式的类别</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<p>info形式的类别</p>
<h4 id="5、success形式的类别"><a href="#5、success形式的类别" class="headerlink" title="5、success形式的类别"></a>5、success形式的类别</h4><p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note success %&#125;</span><br><span class="line">success形式的类别</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<p>success形式的类别</p>
<h4 id="6、warning形式的类别"><a href="#6、warning形式的类别" class="headerlink" title="6、warning形式的类别"></a>6、warning形式的类别</h4><p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note warning %&#125;</span><br><span class="line">warning形式的类别</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<p>warning形式的类别</p>
<h4 id="7、danger形式的类别"><a href="#7、danger形式的类别" class="headerlink" title="7、danger形式的类别"></a>7、danger形式的类别</h4><p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note danger %&#125;</span><br><span class="line">danger形式的类别</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<p>danger形式的类别</p>
<h4 id="8、无图标形式的note标签"><a href="#8、无图标形式的note标签" class="headerlink" title="8、无图标形式的note标签"></a>8、无图标形式的note标签</h4><p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note info no-icon %&#125;</span><br><span class="line">没有图标的note标签</span><br><span class="line">&#123;% code %&#125;</span><br><span class="line">code block in note tag</span><br><span class="line">code block in note tag</span><br><span class="line">code block in note tag</span><br><span class="line">&#123;% endcode %&#125;</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<p>没有图标的note标签<br>Note <strong>without</strong> icon: <code>note info no-icon</code></p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code block in note tag</span><br><span class="line">code block in note tag</span><br><span class="line">code block in note tag</span><br></pre></td></tr></table></figure>

<h4 id="9、无图标形式的success标签"><a href="#9、无图标形式的success标签" class="headerlink" title="9、无图标形式的success标签"></a>9、无图标形式的success标签</h4><p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note success %&#125;</span><br><span class="line">在note中插入代码块</span><br><span class="line">&#123;% code %&#125;</span><br><span class="line">code block in note tag</span><br><span class="line">code block in note tag</span><br><span class="line">code block in note tag</span><br><span class="line">&#123;% endcode %&#125;</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<p>在note中插入代码块</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code block in note tag</span><br><span class="line">code block in note tag</span><br><span class="line">code block in note tag</span><br></pre></td></tr></table></figure>

<h4 id="10、note标签中插入有序无序列表"><a href="#10、note标签中插入有序无序列表" class="headerlink" title="10、note标签中插入有序无序列表"></a>10、note标签中插入有序无序列表</h4><p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">在note中放入无序、有序列表</span><br><span class="line">* ul</span><br><span class="line">* ul</span><br><span class="line">* ul</span><br><span class="line"></span><br><span class="line">1. ol</span><br><span class="line">2. ol</span><br><span class="line">3. ol</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<p>在note中放入无序、有序列表</p>
<ul>
<li>ul</li>
<li>ul</li>
<li>ul</li>
</ul>
<ol>
<li>ol</li>
<li>ol</li>
<li>ol</li>
</ol>
<h4 id="11、note标签中插入表格"><a href="#11、note标签中插入表格" class="headerlink" title="11、note标签中插入表格"></a>11、note标签中插入表格</h4><p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">| 1 | 2 |</span><br><span class="line">| - | - |</span><br><span class="line">| 3 | 4 |</span><br><span class="line">| 5 | 6 |</span><br><span class="line">| 7 | 8 |</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">1</th>
<th align="left">2</th>
</tr>
</thead>
<tbody><tr>
<td align="left">3</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">8</td>
</tr>
</tbody></table>
<h1 id="note标签的html使用"><a href="#note标签的html使用" class="headerlink" title="note标签的html使用"></a>note标签的html使用</h1><p>在主题配置文件<code>_config.yml</code>里有一个关于这个的配置，但官方文档没有提供 HTML 的使用方式，个人认为这种方式更简单，也不会产生一些奇怪的显示 bugs……</p>
<p>default</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;note default&quot;&gt;&lt;p&gt;default&lt;/p&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>primary</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;note primary&quot;&gt;&lt;p&gt;primary&lt;/p&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>success</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;note success&quot;&gt;&lt;p&gt;success&lt;/p&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>info</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;note info&quot;&gt;&lt;p&gt;info&lt;/p&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>warning</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;note warning&quot;&gt;&lt;p&gt;warning&lt;/p&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>danger</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;note danger&quot;&gt;&lt;p&gt;danger&lt;/p&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>danger no-icon</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;note danger no-icon&quot;&gt;&lt;p&gt;danger no-icon&lt;/p&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h1 id="主题自带FontAwesome图标"><a href="#主题自带FontAwesome图标" class="headerlink" title="主题自带FontAwesome图标"></a>主题自带FontAwesome图标</h1><p>效果：</p>
<ol>
<li>支持 Markdown<br><em>Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</em></li>
<li>一件部署<br><em>只需一条指令即可部署到 GitHub Pages，或其他网站。</em></li>
<li>丰富的插件<br><em>Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade，CoffeeScript。</em></li>
</ol>
<p>源码：</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. &lt;i class=&quot;fa fa-pencil&quot;&gt;&lt;/i&gt; 支持 Markdown</span><br><span class="line">   &lt;i&gt;Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。&lt;/i&gt;</span><br><span class="line">2. &lt;i class=&quot;fa fa-cloud-upload&quot;&gt;&lt;/i&gt; 一件部署</span><br><span class="line">   &lt;i&gt;只需一条指令即可部署到 GitHub Pages，或其他网站。&lt;/i&gt;</span><br><span class="line">3. &lt;i class=&quot;fa fa-cog&quot;&gt;&lt;/i&gt; 丰富的插件</span><br><span class="line">   &lt;i&gt;Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade，CoffeeScript。&lt;/i&gt;</span><br><span class="line">   采用的是 Font Awesome 的图标，下面给出一些简单的使用例子，更多请查看官网的使用示例。</span><br></pre></td></tr></table></figure>

<p>采用的是 <a href="https://fontawesome.com/v4.7.0/" target="_blank" rel="noopener">Font Awesome</a> 的图标，下面给出一些简单的使用例子，更多请查看官网的<a href="https://fontawesome.com/v4.7.0/examples/" target="_blank" rel="noopener">使用示例</a>。</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &lt;i class=&quot;fa fa-pencil&quot;&gt;&lt;/i&gt; 铅笔</span><br><span class="line">- &lt;i class=&quot;fa fa-cloud-upload&quot;&gt;&lt;/i&gt; 上传</span><br><span class="line">- &lt;i class=&quot;fa fa-download&quot;&gt;&lt;/i&gt; 下载</span><br></pre></td></tr></table></figure>

<ul>
<li>铅笔</li>
<li>上传</li>
<li>下载</li>
</ul>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &lt;i class=&quot;fa fa-download&quot;&gt;&lt;/i&gt; 下载</span><br><span class="line">- &lt;i class=&quot;fa fa-download fa-lg&quot;&gt;&lt;/i&gt; 下载变大 33%</span><br><span class="line">- &lt;i class=&quot;fa fa-download fa-2x&quot;&gt;&lt;/i&gt; 下载两倍大</span><br></pre></td></tr></table></figure>

<ul>
<li>下载</li>
<li>下载变大 33%</li>
<li>下载两倍大</li>
</ul>
<h1 id="代码块内部样式高亮"><a href="#代码块内部样式高亮" class="headerlink" title="代码块内部样式高亮"></a>代码块内部样式高亮</h1><p>Next主题其实是自带代码块高亮显示的，但是有另外一种好玩的代码块高亮写法，叫<code>diff</code>语言</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line"># 代码自动高亮</span><br><span class="line">-  auto_detect: false</span><br><span class="line">+  auto_detect: true</span><br></pre></td></tr></table></figure>

<p>只需要在markdown语法代码块的语言选择处写上<code>diff</code>即可，然后在相应代码前面加上<code>-</code>和<code>+</code>就行了。不过默认的<code>-</code>是绿色，<code>+</code>是红色，与 GitHub 上相反，也可以自己修改成Github上样式。</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文件位置：themes/next/source/css/_custom/custom.styl// 文章```代码块diff样式</span><br><span class="line">pre .addition &#123;</span><br><span class="line">    background: #e6ffed;</span><br><span class="line">&#125;</span><br><span class="line">pre .deletion &#123;</span><br><span class="line">    background: #ffeef0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，要是你不满意顶部的文字样式，也可以自己在<code>custom.styl</code>自定义：</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 文章```代码块顶部样式</span><br><span class="line">.highlight figcaption &#123;</span><br><span class="line">    margin: 0em;</span><br><span class="line">    padding: 0.5em;</span><br><span class="line">    background: #eee;</span><br><span class="line">    border-bottom: 1px solid #e9e9e9;</span><br><span class="line">&#125;</span><br><span class="line">.highlight figcaption a &#123;</span><br><span class="line">    color: rgb(80, 115, 184);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="文本居中引用"><a href="#文本居中引用" class="headerlink" title="文本居中引用"></a>文本居中引用</h1><p>效果：</p>
<blockquote>
<p>人生乃是一面镜子，<br>从镜子里认识自己，<br>我要称之为头等大事，<br>也只是我们追求的目的！</p>
</blockquote>
<p>源码：</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% cq %&#125;</span><br><span class="line">人生乃是一面镜子，</span><br><span class="line">从镜子里认识自己，</span><br><span class="line">我要称之为头等大事，</span><br><span class="line">也只是我们追求的目的！</span><br><span class="line">&#123;% endcq %&#125;</span><br></pre></td></tr></table></figure>

<h1 id="主题自带label标签"><a href="#主题自带label标签" class="headerlink" title="主题自带label标签"></a>主题自带label标签</h1><p>首先需要在Next主题<code>_config.xml</code>中配置：</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Label tag.</span><br><span class="line">label: true</span><br></pre></td></tr></table></figure>

<p>然后效果如下（@ 前面的是<code>label</code>的名字，后面的是要显示的文字）：</p>
<ul>
<li>default</li>
</ul>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% label default@default %&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>primary</li>
</ul>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% label primary@primary %&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>success</li>
</ul>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% label success@success %&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>info</li>
</ul>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% label info@info %&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>warning</li>
</ul>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% label warning@warning %&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>danger</li>
</ul>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% label danger@danger %&#125;</span><br></pre></td></tr></table></figure>

<p>注意这个有一个BUG，千万不要把这个放到段首。。。</p>
<h1 id="主题自带tabs标签"><a href="#主题自带tabs标签" class="headerlink" title="主题自带tabs标签"></a>主题自带tabs标签</h1><p>效果：</p>
<ul>
<li><a href="https://blog.bestzuo.cn/posts/3147047336.html#选项卡-1" target="_blank" rel="noopener">选项卡 1</a></li>
<li><a href="https://blog.bestzuo.cn/posts/3147047336.html#选项卡-2" target="_blank" rel="noopener">选项卡 2</a></li>
<li><a href="https://blog.bestzuo.cn/posts/3147047336.html#选项卡-3" target="_blank" rel="noopener">选项卡 3</a></li>
</ul>
<p><strong>这是选项卡 2</strong></p>
<p>源码：</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% tabs 选项卡, 2 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**这是选项卡 1** 呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈呵呵哈哈哈哈哈哈哈哈……</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**这是选项卡 2**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**这是选项卡 3** 哇，你找到我了！φ(≧ω≦*)♪～</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>

<p>首先还是需要在Next主题配置文件中配置：</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文件位置：~/blog/themes/next/_config.yml# Tabs tag.</span><br><span class="line">tabs:</span><br><span class="line">  enable: true</span><br><span class="line">  transition:</span><br><span class="line">    tabs: true</span><br><span class="line">    labels: true</span><br><span class="line">  border_radius: 0</span><br></pre></td></tr></table></figure>

<p>然后上面源码中<code>, 2</code>表示一开始在第二个选项卡，非必须，若数值为<code>-1</code>则隐藏选项卡内容。更多用法请查看<a href="https://almostover.ru/2016-01/hexo-theme-next-test/#Tab-tag-test" target="_blank" rel="noopener">这个页面</a>。</p>
<h1 id="主题自带样式按钮"><a href="#主题自带样式按钮" class="headerlink" title="主题自带样式按钮"></a>主题自带样式按钮</h1><p>效果：</p>
<p><a href="https://www.baidu.com/" target="_blank" rel="noopener">点击下载百度</a></p>
<p>源码：</p>
<p>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% btn https://www.baidu.com, 点击下载百度, download fa-lg fa-fw %&#125;</span><br></pre></td></tr></table></figure>

<p>关于按钮的更多使用可以前往<a href="https://almostover.ru/2016-01/hexo-theme-next-test/#Button-tag-test" target="_blank" rel="noopener">这个页面</a>查看。</p>
]]></content>
      <categories>
        <category>书写格式</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>python装饰器的理解与使用</title>
    <url>/posts/24380.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：本篇主要描述什么是python的装饰器，以及装饰器是如何使用和工作原理。</p>
<a id="more"></a>

<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</p>
<p>我们来看个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo1</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">"I'm demo1."</span>)</span><br></pre></td></tr></table></figure>

<p>但现在我需要在调用函数时记录执行日志，于是在代码中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def demo1():</span><br><span class="line">	print(&quot;I&apos;m demo1.&quot;)</span><br><span class="line">	logging.info(&quot;demo1 is running.&quot;)</span><br></pre></td></tr></table></figure>

<p>但是如果其他函数也需要的话一个一个添加就会很麻烦。</p>
<p>接下来我们可以写一个函数来代替一个个添加。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(func)</span>:</span></span><br><span class="line">	logging.info(<span class="string">"%s is running."</span>%func.__name__)</span><br><span class="line">	func()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo1</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">"I'm demo1."</span>)</span><br><span class="line">	</span><br><span class="line">use_logging(demo1)</span><br></pre></td></tr></table></figure>

<p>逻辑上不难理解， 但是这样的话，我们每次都要将一个函数作为参数传递给use_logging函数。而且这种方式已经破坏了原有的代码逻辑结构，之前执行业务逻辑时，执行运行demo1()，但是现在不得不改成use_logging(demo1)。那么有没有更好的方式的呢？当然有，答案就是装饰器。</p>
<h3 id="简单装饰器"><a href="#简单装饰器" class="headerlink" title="简单装饰器"></a>简单装饰器</h3><p>先看这个新的例子来解释闭包：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># print_msg是外围函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_msg</span><span class="params">()</span>:</span></span><br><span class="line">    msg = <span class="string">"I'm closure"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># printer是嵌套函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printer</span><span class="params">()</span>:</span></span><br><span class="line">        print(msg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> printer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里获得的就是一个闭包</span></span><br><span class="line">closure = print_msg()</span><br><span class="line"><span class="comment"># 输出 I'm closure</span></span><br><span class="line">closure()</span><br></pre></td></tr></table></figure>

<p><code>msg</code>是一个局部变量，在<code>print_msg</code>函数执行之后应该就不会存在了。但是嵌套函数引用了这个变量，将这个局部变量封闭在了嵌套函数中，这样就形成了一个闭包。</p>
<p>结合这个例子再看维基百科的解释，就清晰明了多了。闭包就是引用了自有变量的函数，这个函数保存了执行的上下文，可以脱离原本的作用域独立存在。</p>
<p>下面看看python中的装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"call %s():"</span>%func.__name__)</span><br><span class="line">        print(<span class="string">"args = &#123;&#125;"</span>.format(*args))</span><br><span class="line">        <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper()</span><br></pre></td></tr></table></figure>

<p>调用它：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(p)</span>:</span></span><br><span class="line">    print(test.__name__ + <span class="string">"param:"</span>+p)</span><br><span class="line"></span><br><span class="line">test(<span class="string">"I'm param"</span>)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200621230457462.png" alt="image-20200621230457462"></p>
<p>装饰器在调用是时候使用了@语法，其实实际上的调用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def test(p):</span><br><span class="line">	print(test.__name__ + &quot;param:&quot;+p)</span><br><span class="line">wrapper = log(test)</span><br><span class="line">wrapper (&quot;I&apos;m param&quot;)</span><br></pre></td></tr></table></figure>

<p><code>@</code>语法只是将函数传入装饰器函数，并无神奇之处。</p>
<p>值得注意的是<code>@functools.wraps(func)</code>，这是python提供的装饰器。它能把原函数的元信息拷贝到装饰器里面的 func 函数中。函数的元信息包括docstring、<strong>name</strong>、参数列表等等。可以尝试去除<code>@functools.wraps(func)</code>，你会发现<code>test.__name__</code>的输出变成了wrapper。</p>
<h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><p>装饰器允许传入参数，一个携带了参数的装饰器将有三层函数，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_with_param</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">        @functools.wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">'call %s():'</span> % func.__name__)</span><br><span class="line">            print(<span class="string">'log_param = &#123;&#125;'</span>.format(text))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line">    </span><br><span class="line"><span class="meta">@log_with_param("param")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_with_param</span><span class="params">()</span>:</span></span><br><span class="line">    print(test_with_param.__name__)</span><br><span class="line">test_with_param()</span><br></pre></td></tr></table></figure>

<p>看到这个代码是不是又有些疑问，内层的decorator函数的参数func是怎么传进去的？和上面一般的装饰器不大一样啊。</p>
<p>其实道理是一样的，将其<code>@</code>语法去除，恢复函数调用的形式一看就明白了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 传入装饰器的参数，并接收返回的decorator函数</span><br><span class="line">decorator = log_with_param(&quot;param&quot;)</span><br><span class="line"># 传入test_with_param函数</span><br><span class="line">wrapper = decorator(test_with_param)</span><br><span class="line"># 调用装饰器函数</span><br><span class="line">wrapper(&quot;I&apos;m a param&quot;)</span><br></pre></td></tr></table></figure>

<p>输出结果与正常使用装饰器相同：</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200621232456603.png" alt="image-20200621232456603"></p>
<p>至此，装饰器这个有点费解的特性也没什么神秘了。</p>
<p>装饰器这一语法体现了Python中函数是第一公民，函数是对象、是变量，可以作为参数、可以是返回值，非常的灵活与强大。</p>
<p>Python中引入了很多函数式编程的特性，需要好好学习与体会。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>树和二叉树的应用</title>
    <url>/posts/tree_1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：树的基本概念、二叉树、树和森林、树与二叉树的应用。</p>
<a id="more"></a>

<h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p>树是一种非线性的数据结构。树是若干结点的集合，是由唯一的根和若干棵互不相交的子树组成的。其中每一棵子树又是一棵树，也是唯一的根节点和若干互不相交的子树组成的。由此可见树的定义是递归的。其中需要注意的是结点数为0的树称为空树。</p>
<h3 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h3><p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200910090801458.png" alt="image-20200910090801458"></p>
<p>结点：A、B、C等都是结点，结点不仅包含数据，而且包含指向子树的分支。</p>
<p>结点的度：结点拥有的子树个数或者分支的个数。例如A结点有3棵子树，所以A的结点的度为3。</p>
<p>树的度：树中个结点度的最大值。</p>
<p>叶子结点：指度为0的结点。</p>
<p>非终端结点：指度不为0的结点，除了根结点之外的非终端结点，也叫作内部节点。</p>
<p>孩子：结点的子树的根，如A结点的孩子就是B、C、D</p>
<p>双亲：与孩子定义对应，如B、C、D的双亲就是A</p>
<p>兄弟：同一个双亲的孩子之间互为兄弟，如B、C、D互为兄弟。</p>
<p>祖先：从根到某个结点的路径上的所有结点，都是这个结点的祖先。如K的祖先是A、B、E</p>
<p>子孙：以某个结点为根的子树中的所有结点，都是该结点的子孙，如D的子树为H、I、J、M</p>
<p>层次：从根开始，根为第一次，根的孩子为第二次，以此类推</p>
<p>树的高度（深度）：树中结点的最大层次。</p>
<p>结点的高度（深度）：从根节点到该节点路径上的结点个数</p>
<p>堂兄弟：双亲在同一层的结点互为堂兄弟，如G和H互为堂兄弟。</p>
<p>有序树：树中的结点的子树从左到右是有次序的，不能交换，这样的树叫做有序树</p>
<p>无序树：树中结点的子树没有顺序，可以任意次交换。</p>
<p>丰满树：丰满树即为了理想平衡树，要求除去最底层外，其他层都是满的</p>
<p>森林：若干互不相交的树的集合，例如把A去掉，则剩下的三个子树互不相交，构成一个森林。</p>
<h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><p>1.顺序存储结构</p>
<p>树的顺序存储结构中最直观的是双亲存储的结构，用以为数组即可实现。<code>int tree[maxSize]</code>。数组下标表示树中的结点，数组元素的内容表示该结点的双亲结点，这样就可以表示一棵树了。</p>
<p>2.链式存储结构</p>
<p>（1）孩子存储结构</p>
<p>孩子存储结构实质上就是图的邻接表存储结构，树是一种特殊的图，把图中多对多的关系改为一对多即可得到树。</p>
<p>（2）孩子兄弟存储结构</p>
<p>孩子兄弟存储结构与树和森林和二叉树的相互转换关系密切。</p>
<h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p>将一般的树加上下面两个限制即可得到二叉树：</p>
<p>1.每个结点最多只有两个子树</p>
<p>2.子树有左右顺序之分</p>
<p>所有的分支结点都有左右孩子结点及并且叶子结点都集中在二叉树的最下一层，这样的二叉树称为满二叉树。对满二叉树进行编号，如果个结点编号与次深度相同的满二叉树相同位置的结点编号钧相同，则为完全二叉树</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200910103118995.png" alt="image-20200910103118995"></p>
<h3 id="二叉树的主要性质"><a href="#二叉树的主要性质" class="headerlink" title="二叉树的主要性质"></a>二叉树的主要性质</h3><p>1.非空二叉树上叶子结点数等于双分支结点数+1</p>
<p>2.二叉搜索的第i层上最多有2^(i-1)个结点。（i&gt;=1)</p>
<p>3.高度为k的二叉树最多有2^k - 1个结点。</p>
<p>其他待补充……</p>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><p>1.顺序存储结构</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200910105118422.png" alt="image-20200910105118422"></p>
<p>2.链式存储结构</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200912232642646.png" alt="image-20200912232642646"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BTNode;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的遍历算法"><a href="#二叉树的遍历算法" class="headerlink" title="二叉树的遍历算法"></a>二叉树的遍历算法</h2><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>访问根节点–&gt;先序遍历左子树–&gt;先序遍历右子树</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(BTNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Visit(p);	<span class="comment">//假设访问函数为Visit</span></span><br><span class="line">		preorder(p-&gt;lchild);	<span class="comment">//先序遍历左子树</span></span><br><span class="line">		preorder(p-&gt;rchild);	<span class="comment">//先序遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>中序遍历左子树–&gt;访问根节点–&gt;中序遍历右子树</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(BTNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		inorder(p-&gt;lchild);</span><br><span class="line">		Visit(p);</span><br><span class="line">		inorder(p-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>后序遍历左子树–&gt;后序遍历右子树–&gt;访问根节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(BTNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		postorder(p-&gt;lchild);</span><br><span class="line">		postorder(p-&gt;rchild);</span><br><span class="line">		Visit(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_tree_depth</span><span class="params">(BTNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ld,rd;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ld = get_tree_depth(root-&gt;lchild);  <span class="comment">//求左子树深度</span></span><br><span class="line">        rd = get_tree_depth(root-&gt;rchild);  <span class="comment">//求右子树深度</span></span><br><span class="line">        <span class="keyword">return</span> (ld&gt;rd?ld:rd) +<span class="number">1</span>;            <span class="comment">//返回左右子树深度最大值+1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><p>按照层次进行遍历输出，需要建立一个循环队列。先将二叉树的头结点入队，然后出队列，访问该节点。如果左子树存在则左子树根节点入队，如果右子树存在则右子树根节点入队，然后出队列，对结点进行访问。如此反复直到队列为空。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leavel</span><span class="params">(BTNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span>,rear = <span class="number">0</span>;</span><br><span class="line">    BTNode *que[MAX_SIZE];</span><br><span class="line">    BTNode *temp_node;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rear =(rear + <span class="number">1</span>)% MAX_SIZE; <span class="comment">//循环队列</span></span><br><span class="line">        que[rear] = node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(front != rear)    <span class="comment">//队列不为空的时候出队</span></span><br><span class="line">        &#123;</span><br><span class="line">            front = (front + <span class="number">1</span>) % MAX_SIZE;</span><br><span class="line">            temp_node = que[front];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%3c"</span>,temp_node-&gt;data);  <span class="comment">//访问结点</span></span><br><span class="line">            <span class="keyword">if</span>(temp_node-&gt;lchild != <span class="literal">NULL</span>)   <span class="comment">//左子树不为空则入队</span></span><br><span class="line">            &#123;</span><br><span class="line">                rear = (rear + <span class="number">1</span>)% MAX_SIZE;</span><br><span class="line">                que[rear] = temp_node-&gt;lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp_node-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                rear = (rear + <span class="number">1</span>) % MAX_SIZE;</span><br><span class="line">                que[rear] = temp_node-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建二叉树"><a href="#创建二叉树" class="headerlink" title="创建二叉树"></a>创建二叉树</h4><p>二叉树以链表的形式存储</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 128</span></span><br><span class="line"><span class="comment">// 二叉树的结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            二叉树的创建</span></span><br><span class="line"><span class="comment">采取输入格式为：ABD##E##CF###</span></span><br><span class="line"><span class="comment">构建：</span></span><br><span class="line"><span class="comment">                    A</span></span><br><span class="line"><span class="comment">            B               C</span></span><br><span class="line"><span class="comment">        D       E       F       #</span></span><br><span class="line"><span class="comment">      #   #   #   #   #   #</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function">BTNode *<span class="title">create_tree</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *root;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    ch = str[cnt];</span><br><span class="line">    ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">'#'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    root = (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">    root-&gt;data = ch;</span><br><span class="line">    root-&gt;lchild = create_tree(str);</span><br><span class="line">    root-&gt;rchild = create_tree(str);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(BTNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%3c"</span>,node-&gt;data);</span><br><span class="line">        preorder(node-&gt;lchild);</span><br><span class="line">        preorder(node-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(BTNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        preorder(node-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%3c"</span>,node-&gt;data);</span><br><span class="line">        preorder(node-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(BTNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        preorder(node-&gt;lchild);</span><br><span class="line">        preorder(node-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%3c"</span>,node-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leavel</span><span class="params">(BTNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span>,rear = <span class="number">0</span>;</span><br><span class="line">    BTNode *que[MAX_SIZE];</span><br><span class="line">    BTNode *temp_node;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rear =(rear + <span class="number">1</span>)% MAX_SIZE; <span class="comment">//循环队列</span></span><br><span class="line">        que[rear] = node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(front != rear)    <span class="comment">//队列不为空的时候出队</span></span><br><span class="line">        &#123;</span><br><span class="line">            front = (front + <span class="number">1</span>) % MAX_SIZE;</span><br><span class="line">            temp_node = que[front];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%3c"</span>,temp_node-&gt;data);  <span class="comment">//访问结点</span></span><br><span class="line">            <span class="keyword">if</span>(temp_node-&gt;lchild != <span class="literal">NULL</span>)   <span class="comment">//左子树不为空则入队</span></span><br><span class="line">            &#123;</span><br><span class="line">                rear = (rear + <span class="number">1</span>)% MAX_SIZE;</span><br><span class="line">                que[rear] = temp_node-&gt;lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp_node-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                rear = (rear + <span class="number">1</span>) % MAX_SIZE;</span><br><span class="line">                que[rear] = temp_node-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_tree_depth</span><span class="params">(BTNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ld,rd;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ld = get_tree_depth(root-&gt;lchild);  <span class="comment">//求左子树深度</span></span><br><span class="line">        rd = get_tree_depth(root-&gt;rchild);  <span class="comment">//求右子树深度</span></span><br><span class="line">        <span class="keyword">return</span> (ld&gt;rd?ld:rd) +<span class="number">1</span>;            <span class="comment">//返回左右子树深度最大值+1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BTNode *bt = create_tree(<span class="string">"ABD##E##CF###"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"preorderr:\n"</span>);</span><br><span class="line">	preorder(bt);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"inorder:\n"</span>);</span><br><span class="line">	inorder(bt);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"postorder:\n"</span>);</span><br><span class="line">	postorder(bt);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"tree_leave:\n"</span>);</span><br><span class="line">    leavel(bt);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"tree_depth:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%3d"</span>,get_tree_depth(bt));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树遍历算法的改进"><a href="#二叉树遍历算法的改进" class="headerlink" title="二叉树遍历算法的改进"></a>二叉树遍历算法的改进</h2><p>二叉树的深度优先遍历算法都是用递归函数实现的，效率低下。原因是因为相当于调用一个栈并做了诸如保护线程和恢复现场等复杂操作，才使得代码简短。可以采用二叉树深度优先遍历算法的非递归实现和线索二叉树。</p>
<ol>
<li>二叉树深度优先遍历算法是用用户自定义的栈来代替系统栈，也就是用非递归的方式来实现遍历算法。</li>
<li>线索二叉树是将二叉树线索化，不需要栈来辅助完成遍历操作，更进一步提高效率。</li>
</ol>
<h3 id="二叉树深度优先遍历算法的非递归实现"><a href="#二叉树深度优先遍历算法的非递归实现" class="headerlink" title="二叉树深度优先遍历算法的非递归实现"></a>二叉树深度优先遍历算法的非递归实现</h3><h4 id="先序遍历的非递归算法"><a href="#先序遍历的非递归算法" class="headerlink" title="先序遍历的非递归算法"></a>先序遍历的非递归算法</h4><blockquote>
<p>将出栈的结点的孩子依照右孩子先入栈，左孩子后入栈的顺序入栈。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder_nonrecurision</span><span class="params">(Btree *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node)   <span class="comment">//结点不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        Btree *<span class="built_in">stack</span>[MAX_SIZE];     <span class="comment">//定义一个栈</span></span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">        Btree *temp;    <span class="comment">//定义一个缓存结点</span></span><br><span class="line">        <span class="built_in">stack</span>[++top] = node;    <span class="comment">//根节点入栈</span></span><br><span class="line">        <span class="keyword">while</span>(top != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = <span class="built_in">stack</span>[top--];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%3c"</span>,temp-&gt;data);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;rchild)</span><br><span class="line">                <span class="built_in">stack</span>[++top] = temp-&gt;rchild;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;lchild)</span><br><span class="line">                <span class="built_in">stack</span>[++top] = temp-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中序遍历的非递归算法"><a href="#中序遍历的非递归算法" class="headerlink" title="中序遍历的非递归算法"></a>中序遍历的非递归算法</h4><blockquote>
<p>入栈时左孩子存在则继续入栈</p>
<p>左孩子不存在则栈顶出栈，出栈元素右孩子存在则入栈</p>
</blockquote>
<p>tip：会存在栈空但是遍历未结束的情况，所以判断条件不能像先序遍历那样使用<code>top!=-1</code>来判断，需要使用<code>top!=-1 ||p!=NULL</code>进行判断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder_nonrecurision</span><span class="params">(Btree *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node)</span><br><span class="line">    &#123;</span><br><span class="line">        Btree *<span class="built_in">stack</span>[MAX_SIZE];</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">        Btree *temp=node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(top != <span class="number">-1</span> || temp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(temp) <span class="comment">//左孩子存在则左孩子入栈</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>[++top] = temp;</span><br><span class="line">                temp = temp-&gt;lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(top != <span class="number">-1</span>)   <span class="comment">//栈不为空的情况下出栈</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp = <span class="built_in">stack</span>[top--];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%3c"</span>,temp-&gt;data);</span><br><span class="line">                temp = temp-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="后序遍历的非递归算法"><a href="#后序遍历的非递归算法" class="headerlink" title="后序遍历的非递归算法"></a>后序遍历的非递归算法</h4><p>先序遍历序列：A B D E C F</p>
<p>后序遍历序列：D E B F C A</p>
<p>后序遍历逆序：A C F B E D</p>
<blockquote>
<p>观察发现,逆后序遍历和先序遍历存在一点联系，逆后序遍历序列只不过是先序遍历过程中对左右子树遍历顺序交换所得到的结果</p>
<p>只需要将先序遍历的左右子树遍历的顺序交换遍历方式并将遍历结果压入栈即可得到后序遍历序列。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder_nonrecurision</span><span class="params">(Btree *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node)</span><br><span class="line">    &#123;</span><br><span class="line">        Btree *stack_1[MAX_SIZE];</span><br><span class="line">        Btree *stack_2[MAX_SIZE];</span><br><span class="line">        <span class="keyword">int</span> top1,top2;</span><br><span class="line">        top1 = top2 = <span class="number">-1</span>;</span><br><span class="line">        Btree *temp;</span><br><span class="line">        stack_1[++top1] = node;</span><br><span class="line">        <span class="keyword">while</span>(top1 != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = stack_1[top1--];</span><br><span class="line">            stack_2[++top2] = temp; <span class="comment">//将出栈结点存入stack_2</span></span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;lchild)</span><br><span class="line">                stack_1[++top1] = temp-&gt;lchild;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;rchild)</span><br><span class="line">                stack_1[++top1] = temp-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(top2 != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = stack_2[top2--];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%3c"</span>,temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完成代码"><a href="#完成代码" class="headerlink" title="完成代码"></a>完成代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Btree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Btree</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Btree</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;Btree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            二叉树的创建</span></span><br><span class="line"><span class="comment">采取输入格式为：ABD##E##CF###</span></span><br><span class="line"><span class="comment">构建：</span></span><br><span class="line"><span class="comment">                    A</span></span><br><span class="line"><span class="comment">            B               C</span></span><br><span class="line"><span class="comment">        D       E       F       #</span></span><br><span class="line"><span class="comment">      #   #   #   #   #   #</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function">Btree *<span class="title">create_Btree</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Btree *root;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    ch = str[cnt++];</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">'#'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    root = (Btree*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Btree));</span><br><span class="line">    root-&gt;data = ch;</span><br><span class="line">    root-&gt;lchild = create_Btree(str);</span><br><span class="line">    root-&gt;rchild = create_Btree(str);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder_nonrecurision</span><span class="params">(Btree *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node)   <span class="comment">//结点不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        Btree *<span class="built_in">stack</span>[MAX_SIZE];     <span class="comment">//定义一个栈</span></span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">        Btree *temp;    <span class="comment">//定义一个缓存结点</span></span><br><span class="line">        <span class="built_in">stack</span>[++top] = node;    <span class="comment">//根节点入栈</span></span><br><span class="line">        <span class="keyword">while</span>(top != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = <span class="built_in">stack</span>[top--];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%3c"</span>,temp-&gt;data);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;rchild)</span><br><span class="line">                <span class="built_in">stack</span>[++top] = temp-&gt;rchild;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;lchild)</span><br><span class="line">                <span class="built_in">stack</span>[++top] = temp-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder_nonrecurision</span><span class="params">(Btree *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node)</span><br><span class="line">    &#123;</span><br><span class="line">        Btree *<span class="built_in">stack</span>[MAX_SIZE];</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">        Btree *temp=node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(top != <span class="number">-1</span> || temp != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(temp) <span class="comment">//左孩子存在则左孩子入栈</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>[++top] = temp;</span><br><span class="line">                temp = temp-&gt;lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(top != <span class="number">-1</span>)   <span class="comment">//栈不为空的情况下出栈</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp = <span class="built_in">stack</span>[top--];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%3c"</span>,temp-&gt;data);</span><br><span class="line">                temp = temp-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder_nonrecurision</span><span class="params">(Btree *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node)</span><br><span class="line">    &#123;</span><br><span class="line">        Btree *stack_1[MAX_SIZE];</span><br><span class="line">        Btree *stack_2[MAX_SIZE];</span><br><span class="line">        <span class="keyword">int</span> top1,top2;</span><br><span class="line">        top1 = top2 = <span class="number">-1</span>;</span><br><span class="line">        Btree *temp;</span><br><span class="line">        stack_1[++top1] = node;</span><br><span class="line">        <span class="keyword">while</span>(top1 != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = stack_1[top1--];</span><br><span class="line">            stack_2[++top2] = temp; <span class="comment">//将出栈结点存入stack_2</span></span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;lchild)</span><br><span class="line">                stack_1[++top1] = temp-&gt;lchild;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;rchild)</span><br><span class="line">                stack_1[++top1] = temp-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(top2 != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = stack_2[top2--];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%3c"</span>,temp-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Btree *bt = create_Btree(<span class="string">"ABD##E##CF###"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"preorder_nonrecurision:\n"</span>);</span><br><span class="line">    preorder_nonrecurision(bt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"inorder_nonrecurision:\n"</span>);</span><br><span class="line">    inorder_nonrecurision(bt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"postorder_nonrecurision:\n"</span>);</span><br><span class="line">    postorder_nonrecurision(bt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>二叉树非递归算法避免了系统栈的调用，提高了一定的执行效率。而线索二叉树可以将用户栈也省掉，把二叉树的遍历过程线性化，进一步提高效率。</p>
<p>二叉树线索化后进士于一个线性结构，分支结构的遍历操作就转化为近似于线性结构的遍历操作，通过线索的辅助使得寻找当前结点前驱或者后继的平均效率大大提高。</p>
<h4 id="线索二叉树的构造"><a href="#线索二叉树的构造" class="headerlink" title="线索二叉树的构造"></a>线索二叉树的构造</h4><p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200916160034330.png" alt="image-20200916160034330"></p>
<p>在二叉树线索化的时候会把树中的空指针利用起来作为寻找当前结点的前驱或者后继的线索，这样就出现一个问题，即线索和树中原有的孩子结点的指针无法区别。上面的设计是为了区分两类指针，其中ltag和rtag为标识域，具体意义为：</p>
<p>1）如果 ltag=0,表示lchild为指针，指向左孩子。如果ltag=1,表示lchild为线索，指向结点的直接前驱。</p>
<p>2）如果 rtag=0,表示rchild为指针，指向右孩子。如果rtag=1,表示rchild为线索，指向结点的直接后继。</p>
<h4 id="二叉树中序线索化"><a href="#二叉树中序线索化" class="headerlink" title="二叉树中序线索化"></a>二叉树中序线索化</h4><p>有待更新</p>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>哈夫曼树也叫最优二叉树，是一类带权路径最短的树，广泛应用于查找（将更经常使用的结点放在树顶，更少使用的放在叶子结点，这也是哈夫曼编码的优点）</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>使用PicGo+Github搭建免费图床</title>
    <url>/posts/picgo.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：讲解了基于GitHub采用jsdeliver cdn 进行加速的图床搭建，上传工具采用PicGo。</p>
<a id="more"></a>

<h2 id="GitHub创建仓库"><a href="#GitHub创建仓库" class="headerlink" title="GitHub创建仓库"></a>GitHub创建仓库</h2><ol>
<li><p>新建一个GitHub仓库，名字自定义</p>
</li>
<li><p>生成token：</p>
<p>直接看图</p>
</li>
</ol>
<p>   <img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/tuchuang-1.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/tuchuang-2.png" alt></p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/tuchuang-3.png" alt></p>
<p>最后点击<code>Generate token</code>即可看到显示的token页面，它只会显示一次，<strong>关闭页面</strong>后再打开这个页面就<strong>不会显示</strong>了。复制token值粘贴到文本文档中，先保存下来，后面配置PicGo要用到。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/tuchuang-4.png" alt></p>
<h2 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h2><ol>
<li><p>首先下载安装PicGo，图片上传工具PicGo下载地址：<a href="https://yafine-blog.cn/go.html?url=aHR0cHM6Ly9naXRodWIuY29tL01vbHVuZXJmaW5uL1BpY0dvL3JlbGVhc2Vz" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo/releases</a></p>
</li>
<li><p>下载完成后进行安装，安装完毕后开始配置</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/tuchuang-5.png" alt></p>
</li>
</ol>
<ul>
<li>设定仓库名：这个是刚刚第一步所新建仓库的名称，我的为Yafine-imgs，此处填写格式username/repo。</li>
<li>设定分支名：master，采用默认分支即可</li>
<li>设定Token：此处填写上一步得到的Token，添加到输入框即可。</li>
<li>指定存储路径：自定义，例：images/，相当于在刚刚新建的仓库下新建了一个文件夹。</li>
<li>设定自定义域名：格式：<code>https://cdn.jsdelivr.net/gh/username/repo</code>，<code>username</code>为GitHub用户名，<code>repo</code>为新建的仓库，用于存储图片</li>
</ul>
<ol start="3">
<li>使用方法直接将图片托入上传区即可！</li>
</ol>
<p><strong>注意</strong>：上传前注意选择链接格式，当然也可以不选择，可以去相册选择图片的链接格式，如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/tuchuang-6.png" alt></p>
<p>本文参考：<a href="https://yafine-blog.cn/go.html?url=aHR0cHM6Ly95YWZpbmUtYmxvZy5jbi9wb3N0cy9lYjNhLmh0bWw=" target="_blank" rel="noopener">https://yafine-blog.cn/posts/eb3a.html</a></p>
]]></content>
      <categories>
        <category>GitHub</category>
        <category>图床</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>Python+unittest相关的使用总结</title>
    <url>/posts/unittest_1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要： 研读了python官方文档有关unittest相关的部分，在此做出笔记以及记录一下使用过程的问题以及步骤。</p>
<a id="more"></a>



<p>官方文档中介绍说，unittest是受JUnit（Java）启发而成的单元测试框架，与其他主流的单元测试框架有着相似的风格。其支持测试自动化，配置共享和关机代码（这个地方不懂是什么）测试。支持将测试样例聚合到测试集中，并将测试和报告框架相独立。</p>
<p><strong>概念</strong></p>
<ol>
<li><p>test fixture：</p>
<p>表示为了开展一项或者多项测试所需进行的准备工作，以及所有相关的清理操作。比如说可能是包含临时或者代理的数据库、目录，再或者是启动一个服务器进程。</p>
</li>
<li><p>test case：</p>
<p>一个测试用例是一个独立的测试单元。它检测输入特定的数据时的响应。unittest提供一个基类：TestCase，用于新建测试用例</p>
</li>
<li><p>test suite</p>
<p>test suite是一系列的测试用例，或测试套件，或者两者皆是。他用于归档需要一起执行的测试。</p>
</li>
<li><p>test runner</p>
<p>测试运行器是一个用于执行和输出测试结果的组件。这个运行器可以使用图形接口、文本接口，或返回一个特定的值表示运行测试的结果。</p>
</li>
</ol>
<blockquote>
<p>一些其他的测试框架/模块</p>
</blockquote>
<ul>
<li><p>doctest – 文档测试模块</p>
<p>python中另一个风格不同的测试模块</p>
</li>
<li><p>pytest</p>
<p>第三方单元测试框架，提供轻量化的语法来编写测试，例如assert func(100) == 10000。</p>
</li>
<li><p>Robot Framework</p>
<p>Robot Framework 是一款基于 Python 的功能自动化测试框架。它具备良好的可扩展性，支持关键字驱动，可以同时测试多种类型的客户端或者接口，可以进行分布式测试执行。主要用于轮次很多的验收测试和验收测试驱动开发（ATDD）。</p>
</li>
<li><p>…</p>
</li>
</ul>
<h3 id="基本实例"><a href="#基本实例" class="headerlink" title="基本实例"></a>基本实例</h3><p>简短的代码进行测试三种字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> uniitest</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test_string</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_upper</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertTrue(<span class="string">'foo'</span>.upper(),<span class="string">'FOO'</span>)	<span class="comment">#使用断言进行判断内容是否相同</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_isupper</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertTrue(<span class="string">'FOO'</span>.isupper())	<span class="comment">#使用断言判断内容是否为True</span></span><br><span class="line">        self.assertTrue(<span class="string">'Foo'</span>.isupper())	<span class="comment">#使用断言判断内容是否为False</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_split</span><span class="params">(self)</span>:</span></span><br><span class="line">        s = <span class="string">'hello world'</span></span><br><span class="line">        self.assertEqual(s.split(),[<span class="string">'hello'</span>,<span class="string">'world'</span>])</span><br><span class="line">        <span class="comment">#下面令solit报错</span></span><br><span class="line">        <span class="keyword">with</span> self.assertRaises(TypeError):</span><br><span class="line">            s.split(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>继承 unittest.TestCase 就创建了一个测试样例。上述三个独立的测试是三个类的方法，这些方法的命名都以 test 开头。 这个命名约定告诉测试运行者类的哪些方法表示测试。</p>
<p>每个测试的关键是：调用 assertEqual() 来检查预期的输出； 调用 assertTrue() 或 assertFalse() 来验证一个条件；调用 assertRaises() 来验证抛出了一个特定的异常。使用这些方法而不是 assert 语句是为了让测试运行者能聚合所有的测试结果并产生结果报告。</p>
<p>通过 setUp() 和 tearDown() 方法，可以设置测试开始前与完成后需要执行的指令。 在 组织你的测试代码 中，对此有更为详细的描述。</p>
<p>运行方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 在py文件添加代码：</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    unittest.main()</span><br><span class="line">2.命令行中运行文件:(后文详解)</span><br><span class="line">python -m unittest xxx.py</span><br></pre></td></tr></table></figure>

<p>上文的脚本生成如以下格式的输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 3 tests in 0.000s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>在调用测试脚本时添加 -v 参数使 unittest.main() 显示更为详细的信息，生成如以下形式的输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test_isupper (__main__.TestStringMethods) ... ok</span><br><span class="line">test_split (__main__.TestStringMethods) ... ok</span><br><span class="line">test_upper (__main__.TestStringMethods) ... ok</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 3 tests in 0.001s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h3 id="命令行界面"><a href="#命令行界面" class="headerlink" title="命令行界面"></a>命令行界面</h3><p>unittest 模块可以通过命令行运行模块(py文件)、类和独立测试方法的测试:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m unittest test_module</span><br><span class="line">python -m unittest test_module.TestClass</span><br><span class="line">python -m unittest test_module.TestClass.test_method</span><br></pre></td></tr></table></figure>

<p>可以传入模块名、类、方法名或者他们的任意组合。</p>
<p>在运行测试时，你可以通过添加 -v 参数获取更详细（更多的冗余）的信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m unittest -v test_module</span><br></pre></td></tr></table></figure>

<p>当运行时不包含参数，开始探索性测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m unittest</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:一个新的 TestCase 实例作为一个<em>test fixture</em>，用于运行各个独立的测试方法。在运行每个测试时，<code>setUp()</code> 、<code>tearDown()</code> 和 <code>__init__()</code> 会被调用一次。</p>
</blockquote>
]]></content>
      <categories>
        <category>unittest</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>unittest</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Windows server搭建FTP</title>
    <url>/posts/FTP.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：此次使用Windows server2012 搭建一个FTP服务器，可以用来在不同电脑见进行文件传输。</p>
<a id="more"></a>

<h2 id="安装IIS"><a href="#安装IIS" class="headerlink" title="安装IIS"></a>安装IIS</h2><ol>
<li><p>首先打开服务器管理器的仪表盘，在配置服务器的位置选择<code>添加角色</code>。如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200311191157.png" alt></p>
</li>
<li><p>接着选择下一步</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200311191309.png" alt></p>
</li>
<li><p>在安装类型这选择<code>基于角色或基于功能的安装</code>，然后下一步。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200311191429.png" alt></p>
</li>
<li><p>服务器选择默认的<code>从服务器池种选择服务器</code>，然后下一步。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200311191542.png" alt></p>
</li>
<li><p>接着勾选<code>web服务器</code>，在弹出的窗口中选择<code>添加功能</code>，然后下一步。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200311191654.png" alt></p>
</li>
<li><p>接着一直到<code>角色服务</code>里勾选<code>FTP服务器</code>和 <code>管理工具</code>下的几个选项，如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200311192108.png" alt></p>
</li>
<li><p>然后点击安装，安装完关闭即可。</p>
</li>
</ol>
<h2 id="建立FTP站点"><a href="#建立FTP站点" class="headerlink" title="建立FTP站点"></a>建立FTP站点</h2><ol>
<li><p>回到<code>服务器管理器</code>，点击<code>工具</code>-<code>IIS管理器</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200311193225.png" alt></p>
</li>
<li><p>在<code>网站</code>上点击鼠标右键，选择<code>添加FTP站点</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200311193345.png" alt></p>
</li>
<li><p>填写<code>站点名称</code>和<code>物理路径</code>（自己创建）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200311193456.png" alt></p>
</li>
<li><p>绑定本机IP（是内网并不是公网，直接点下三角选择）并选择无SSL。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200311194243.png" alt></p>
</li>
<li><p>填上身份验证、授权信息和权限。并点击完成。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200311194352.png" alt></p>
</li>
</ol>
<h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><ol>
<li><p>新建一个用于访问FTP站点的用户。打开计算机管理器、单击新用户创建用户、输入用户名和密码后建立。（注：用户名不可起ftp）</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200311203331.png" alt></p>
</li>
</ol>
<h3 id="访问FTP"><a href="#访问FTP" class="headerlink" title="访问FTP"></a>访问FTP</h3><p>在输入框输入<code>ftp://***.***.***.***</code>后输入密码即可访问。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200311203513.png" alt></p>
]]></content>
      <categories>
        <category>FTP</category>
      </categories>
      <tags>
        <tag>Windows server</tag>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title>创建神经网络并进行训练和查询</title>
    <url>/posts/14905.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：通过对神经网络编程这本书的内容，模仿其中的代码，对初次学习神经网络进行熟悉，并逐步完成神经网络的搭建，完成对手写数字的识别。</p>
<a id="more"></a>

<h2 id="神经网络的三大步骤"><a href="#神经网络的三大步骤" class="headerlink" title="神经网络的三大步骤"></a>神经网络的三大步骤</h2><ol>
<li><p>初始化函数–设定输入节点、隐藏节点和输出节点的数量。</p>
</li>
<li><p>训练–学习给定的训练集样本后，优化权重。</p>
</li>
<li><p>查询–给定输入，从输出的节点给出答案。</p>
</li>
</ol>
<h2 id="初始化网络–输入"><a href="#初始化网络–输入" class="headerlink" title="初始化网络–输入"></a>初始化网络–输入</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self , inputnodes , hiddennodes , outputnodes , learningrate)</span>:</span>   </span><br><span class="line">        <span class="comment">#set number of nodes in each input, hidden, output layer</span></span><br><span class="line">    </span><br><span class="line">        self.inodes = inputnodes</span><br><span class="line">        self.hnodes = hiddennodes</span><br><span class="line">        self.onodes = outputnodes</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">#链接权重矩阵</span></span><br><span class="line">        <span class="comment">#link weight matrices, wih and who 注释：此处wih的意思是 w:权重  i:input  h:hidden ,后面的who同理</span></span><br><span class="line">        <span class="comment">#weights inside the arrays are w_i_j,where link is from node i to node j in the next layter</span></span><br><span class="line">        <span class="comment">#w11 w21</span></span><br><span class="line">        <span class="comment">#w12 w22 etc</span></span><br><span class="line">        self.wih = (numpy.random.rand(self.hnodes, self.inodes) - <span class="number">0.5</span>)</span><br><span class="line">        self.who = (numpy.random.rand(self.onodes, self.hnodes) - <span class="number">0.5</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment">#learning rate</span></span><br><span class="line">        self.lr = learningrate</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">#导入scipy.special 才可以用</span></span><br><span class="line">        <span class="comment">#activation function is the sigmoid function</span></span><br><span class="line">        <span class="comment">#使用lambda来创建函数， 函数接受了X，返回了scipy.special.expit(x)，这就是S函数，使用lambda创建的匿名函数</span></span><br><span class="line">        self.activation_function = <span class="keyword">lambda</span> x: scipy.special.expit(x)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>其中，需要注意的地方有：</p>
<ul>
<li>函数名 __init__是前后两条“_” ,如果只有一条下划线的话会报错TypeError : object() takes no parameters</li>
</ul>
<p>参考链接：<a href="https://blog.csdn.net/qq_26489165/article/details/80595864" target="_blank" rel="noopener">https://blog.csdn.net/qq_26489165/article/details/80595864</a></p>
<ul>
<li>链接权重矩阵：此处wih的意思是 w:权重  i:input  h:hidden ,后面的whoy也是同理</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.wih = (numpy.random.rand(self.hnodes, self.inodes) - <span class="number">0.5</span>)</span><br><span class="line">self.who = (numpy.random.rand(self.onodes, self.hnodes) - <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用lambda来创建函数， 函数接受了X，返回了scipy.special.expit(x)，这就是S函数，使用lambda创建的匿名函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.activation_function = <span class="keyword">lambda</span> x: scipy.special.expit(x)</span><br></pre></td></tr></table></figure>

<h2 id="初始化网络–查询"><a href="#初始化网络–查询" class="headerlink" title="初始化网络–查询"></a>初始化网络–查询</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#convert inouts list to 2d array</span></span><br><span class="line">        inputs = numpy.array(inputs_list,ndmin= <span class="number">2</span> ) .T</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#calculate signals into hidden layer</span></span><br><span class="line">        hidden_inputs = numpy.dot(self.wih , inputs)</span><br><span class="line">        <span class="comment">#calculate the signals emerging from hidden layer</span></span><br><span class="line">        hidden_outputs = self.activation_function(hidden_inputs)</span><br><span class="line">        <span class="comment">#calculate signals into final output layer</span></span><br><span class="line">        final_inputs = numpy.dot(self.who , hidden_outputs)</span><br><span class="line">        <span class="comment">#calculate the signals emerging from final output layer</span></span><br><span class="line">        final_outputs = self.activation_function(final_inputs)</span><br><span class="line">        <span class="keyword">return</span> final_outputs</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="初始化网络–训练"><a href="#初始化网络–训练" class="headerlink" title="初始化网络–训练"></a>初始化网络–训练</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#train the neural network</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, input_list, targets_list)</span>:</span></span><br><span class="line">    <span class="comment">#可以发现下面的代码和query中的几乎完全一样。因为所使用的从输入层前馈信号到最终输出层完全一样。而多处理的targets 是用来训练样本的。</span></span><br><span class="line">    <span class="comment">#cober inputs list to 2d array</span></span><br><span class="line">    inputs = numpy.array(input_list,ndmin=<span class="number">2</span>).T</span><br><span class="line">    targets = numpy.array(targets_list,ndmin=<span class="number">2</span>).T</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#calculate signals into hidden layer</span></span><br><span class="line">    hidden_inputs = numpy.dot(self.wih , inputs)</span><br><span class="line">    <span class="comment">#calculate the signals emerging from hidden layer</span></span><br><span class="line">    hidden_outputs = self.activation_function(hidden_inputs)</span><br><span class="line">     <span class="comment">#calculate signals into final output layer</span></span><br><span class="line">    final_inputs = numpy.dot(self.who , hidden_outputs)</span><br><span class="line">    <span class="comment">#calculate the signals emerging from final output layer</span></span><br><span class="line">    final_outputs = self.activation_function(final_inputs)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#error is the (target -actual),即为反向传播的误差</span></span><br><span class="line">    output_errors = targets - final_outputs</span><br><span class="line">    <span class="comment">#hidden layer error is the output_errors , split by weights,recombined at hodden nodes</span></span><br><span class="line">    hidden_errors = numpy.dot(self.who.T , output_errors)</span><br><span class="line">    <span class="comment">#update the weights for the links between the hidden and output layers</span></span><br><span class="line">    <span class="comment">#其中，学习率是self.lr  利用numpy.dot进行矩阵的乘法</span></span><br><span class="line">    self.who += self.lr * numpy.dot((output_errors * final_outputs * (<span class="number">1.0</span> - final_outputs)), numpy.transpose(hidden_outputs))</span><br><span class="line">    <span class="comment">#update the weights for the links between the intput and hidden layers</span></span><br><span class="line">    self.wih += self.lr * numpy.dot((hidden_errors * hidden_outputs * (<span class="number">1.0</span> - hidden_outputs)), numpy.transpose(inputs))</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>其中，需要注意的是：</p>
<ol>
<li>可以发现下面的代码和query中的几乎完全一样。因为所使用的从输入层前馈信号到最终输出层完全一样。而多处理的targets 是用来训练样本的。</li>
<li>而error中error is the (target -actual),即为反向传播的误差</li>
<li>学习率是self.lr  利用numpy.dot进行矩阵的乘法</li>
</ol>
<h2 id="创建神经网络对象"><a href="#创建神经网络对象" class="headerlink" title="创建神经网络对象"></a>创建神经网络对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#number of input, hidden and output nodes</span></span><br><span class="line">input_nodes = <span class="number">784</span></span><br><span class="line">hidden_nodes = <span class="number">100</span></span><br><span class="line">output_nodes = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#learn rate is 0.3 （学习率）</span></span><br><span class="line">learning_rate = <span class="number">0.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#create instance of neural network</span></span><br><span class="line">n = neuralNetwork(input_nodes, hidden_nodes, output_nodes, learning_rate)</span><br></pre></td></tr></table></figure>

<p>为什么选择784个输入节点呢？请记住这是28*28的结果，即是组成手写数字图像的像素个数。</p>
<p>选择100个隐藏节点并没有固定规定，书中认为神经网络可以发现在输入中的特征或模式，这些模式或者特征可以使用比输入本身更简短的表达，因此没有和选择比784大的数字。选择比输入节点小的数量来强制网络尝试总结输入的主要特点。但选择太少的隐藏节点就限制了网络的能力。给定10个输出层的节点对应的是10个标签。</p>
<p>强调一点：对于一个问题，选择多少个隐藏层节点并不存在一份最佳方法。最好的办法就是进行实验，直到找到适合你解决问题的一个数字。</p>
<h2 id="测试网络"><a href="#测试网络" class="headerlink" title="测试网络"></a>测试网络</h2><ul>
<li>打开文件</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#load the mnist training data CSV file into a list</span></span><br><span class="line">training_data_file = open(<span class="string">"TestandTrain/mnist_train_100.csv"</span>,<span class="string">'r'</span>)</span><br><span class="line">training_data_list = training_data_file.readlines()</span><br><span class="line">training_data_file.close()</span><br></pre></td></tr></table></figure>

<p>将文件放在同目录下即可直接调用</p>
<ul>
<li>训练网络</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># train the neural network</span></span><br><span class="line"><span class="comment"># go through all records in the training data set </span></span><br><span class="line"><span class="keyword">for</span> record <span class="keyword">in</span> training_data_list:</span><br><span class="line">    <span class="comment"># split the record by the ',' commas</span></span><br><span class="line">    all_values = record.split(<span class="string">','</span>)</span><br><span class="line">    <span class="comment"># scale and shift the inputs</span></span><br><span class="line">    inputs = (numpy.asfarray(all_values[<span class="number">1</span>:]) / <span class="number">255.0</span> * <span class="number">0.99</span>) + <span class="number">0.01</span></span><br><span class="line">    targets = numpy.zeros(output_nodes) + <span class="number">0.01</span></span><br><span class="line">    <span class="comment"># all_values[0] is the target label for this record</span></span><br><span class="line">    targets[int(all_values[<span class="number">0</span>])] = <span class="number">0.99</span></span><br><span class="line">    n.train(inputs, targets)</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="查询网络"><a href="#查询网络" class="headerlink" title="查询网络"></a>查询网络</h2><ul>
<li>打开文件</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#load the mnist test data CSV file into a list</span></span><br><span class="line">test_data_file = open(<span class="string">"TestandTrain/mnist_test_10.csv"</span>,<span class="string">'r'</span>)</span><br><span class="line">test_data_list = test_data_file.readlines()</span><br><span class="line">test_data_file.close()</span><br></pre></td></tr></table></figure>

<ul>
<li>打印标签</li>
</ul>
<p>并进行matplotlib进行图形化显示并查看测试概率</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#get the first test record</span></span><br><span class="line">all_values = test_data_list[<span class="number">2</span>].split(<span class="string">','</span>)</span><br><span class="line"><span class="comment">#print the lable</span></span><br><span class="line"><span class="comment">#打印标签</span></span><br><span class="line">print(<span class="string">'label:'</span>,all_values[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">image_array = numpy.asfarray(all_values[<span class="number">1</span>:]).reshape((<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line">matplotlib.pyplot.imshow(image_array,cmap=<span class="string">'Greys'</span>,interpolation=<span class="string">'None'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n.query((numpy.asfarray(all_values[<span class="number">1</span>:])/ <span class="number">255.0</span> * <span class="number">0.99</span>) + <span class="number">0.01</span>)</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="comment">#scipy.special for the sigmoid function expit()</span></span><br><span class="line"><span class="keyword">import</span> scipy.special</span><br><span class="line"><span class="comment">#添加绘图库</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment">#neural network classdefinition</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">neuralNetwork</span>:</span></span><br><span class="line">    <span class="comment">#初始化网络</span></span><br><span class="line">    <span class="comment">#initialise the neural netwoak</span></span><br><span class="line">    <span class="comment">#注意！-----&gt;此处init前后均是双下划线，否则报错</span></span><br><span class="line">    <span class="comment">#TypeError: object() takes no parameters</span></span><br><span class="line">    <span class="comment">#参考链接：https://blog.csdn.net/qq_26489165/article/details/80595864</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self , inputnodes , hiddennodes , outputnodes , learningrate)</span>:</span>   </span><br><span class="line">        <span class="comment">#set number of nodes in each input, hidden, output layer</span></span><br><span class="line">    </span><br><span class="line">        self.inodes = inputnodes</span><br><span class="line">        self.hnodes = hiddennodes</span><br><span class="line">        self.onodes = outputnodes</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">#链接权重矩阵</span></span><br><span class="line">        <span class="comment">#link weight matrices, wih and who 注释：此处wih的意思是 w:权重  i:input  h:hidden ,后面的who同理</span></span><br><span class="line">        <span class="comment">#weights inside the arrays are w_i_j,where link is from node i to node j in the next layter</span></span><br><span class="line">        <span class="comment">#w11 w21</span></span><br><span class="line">        <span class="comment">#w12 w22 etc</span></span><br><span class="line">        self.wih = (numpy.random.rand(self.hnodes, self.inodes) - <span class="number">0.5</span>)</span><br><span class="line">        self.who = (numpy.random.rand(self.onodes, self.hnodes) - <span class="number">0.5</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment">#learning rate</span></span><br><span class="line">        self.lr = learningrate</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">#导入scipy.special 才可以用</span></span><br><span class="line">        <span class="comment">#activation function is the sigmoid function</span></span><br><span class="line">        <span class="comment">#使用lambda来创建函数， 函数接受了X，返回了scipy.special.expit(x)，这就是S函数，使用lambda创建的匿名函数</span></span><br><span class="line">        self.activation_function = <span class="keyword">lambda</span> x: scipy.special.expit(x)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#train the neural network</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, input_list, targets_list)</span>:</span></span><br><span class="line">        <span class="comment">#可以发现下面的代码和query中的几乎完全一样。因为所使用的从输入层前馈信号到最终输出层完全一样。而多处理的targets 是用来训练样本的。</span></span><br><span class="line">        <span class="comment">#cober inputs list to 2d array</span></span><br><span class="line">        inputs = numpy.array(input_list,ndmin=<span class="number">2</span>).T</span><br><span class="line">        targets = numpy.array(targets_list,ndmin=<span class="number">2</span>).T</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#calculate signals into hidden layer</span></span><br><span class="line">        hidden_inputs = numpy.dot(self.wih , inputs)</span><br><span class="line">        <span class="comment">#calculate the signals emerging from hidden layer</span></span><br><span class="line">        hidden_outputs = self.activation_function(hidden_inputs)</span><br><span class="line">         <span class="comment">#calculate signals into final output layer</span></span><br><span class="line">        final_inputs = numpy.dot(self.who , hidden_outputs)</span><br><span class="line">        <span class="comment">#calculate the signals emerging from final output layer</span></span><br><span class="line">        final_outputs = self.activation_function(final_inputs)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#error is the (target -actual),即为反向传播的误差</span></span><br><span class="line">        output_errors = targets - final_outputs</span><br><span class="line">        <span class="comment">#hidden layer error is the output_errors , split by weights,recombined at hodden nodes</span></span><br><span class="line">        hidden_errors = numpy.dot(self.who.T , output_errors)</span><br><span class="line">        <span class="comment">#update the weights for the links between the hidden and output layers</span></span><br><span class="line">        <span class="comment">#其中，学习率是self.lr  利用numpy.dot进行矩阵的乘法</span></span><br><span class="line">        self.who += self.lr * numpy.dot((output_errors * final_outputs * (<span class="number">1.0</span> - final_outputs)), numpy.transpose(hidden_outputs))</span><br><span class="line">        <span class="comment">#update the weights for the links between the intput and hidden layers</span></span><br><span class="line">        self.wih += self.lr * numpy.dot((hidden_errors * hidden_outputs * (<span class="number">1.0</span> - hidden_outputs)), numpy.transpose(inputs))</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#query the neural network</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self, inputs_list)</span>:</span></span><br><span class="line">        <span class="comment">#convert inouts list to 2d array</span></span><br><span class="line">        inputs = numpy.array(inputs_list,ndmin= <span class="number">2</span> ) .T</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#calculate signals into hidden layer</span></span><br><span class="line">        hidden_inputs = numpy.dot(self.wih , inputs)</span><br><span class="line">        <span class="comment">#calculate the signals emerging from hidden layer</span></span><br><span class="line">        hidden_outputs = self.activation_function(hidden_inputs)</span><br><span class="line">        <span class="comment">#calculate signals into final output layer</span></span><br><span class="line">        final_inputs = numpy.dot(self.who , hidden_outputs)</span><br><span class="line">        <span class="comment">#calculate the signals emerging from final output layer</span></span><br><span class="line">        final_outputs = self.activation_function(final_inputs)</span><br><span class="line">        <span class="keyword">return</span> final_outputs</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#number of input, hidden and output nodes</span></span><br><span class="line">input_nodes = <span class="number">784</span></span><br><span class="line">hidden_nodes = <span class="number">100</span></span><br><span class="line">output_nodes = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#learn rate is 0.3</span></span><br><span class="line">learning_rate = <span class="number">0.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#create instance of neural network</span></span><br><span class="line">n = neuralNetwork(input_nodes, hidden_nodes, output_nodes, learning_rate)</span><br><span class="line"><span class="comment">#load the mnist training data CSV file into a list</span></span><br><span class="line">training_data_file = open(<span class="string">"TestandTrain/mnist_train_100.csv"</span>,<span class="string">'r'</span>)</span><br><span class="line">training_data_list = training_data_file.readlines()</span><br><span class="line">training_data_file.close()</span><br><span class="line"><span class="comment"># train the neural network</span></span><br><span class="line"><span class="comment"># go through all records in the training data set </span></span><br><span class="line"><span class="keyword">for</span> record <span class="keyword">in</span> training_data_list:</span><br><span class="line">    <span class="comment"># split the record by the ',' commas</span></span><br><span class="line">    all_values = record.split(<span class="string">','</span>)</span><br><span class="line">    <span class="comment"># scale and shift the inputs</span></span><br><span class="line">    inputs = (numpy.asfarray(all_values[<span class="number">1</span>:]) / <span class="number">255.0</span> * <span class="number">0.99</span>) + <span class="number">0.01</span></span><br><span class="line">    targets = numpy.zeros(output_nodes) + <span class="number">0.01</span></span><br><span class="line">    <span class="comment"># all_values[0] is the target label for this record</span></span><br><span class="line">    targets[int(all_values[<span class="number">0</span>])] = <span class="number">0.99</span></span><br><span class="line">    n.train(inputs, targets)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="comment">#load the mnist test data CSV file into a list</span></span><br><span class="line">test_data_file = open(<span class="string">"TestandTrain/mnist_test_10.csv"</span>,<span class="string">'r'</span>)</span><br><span class="line">test_data_list = test_data_file.readlines()</span><br><span class="line">test_data_file.close()</span><br><span class="line"><span class="comment">#get the first test record</span></span><br><span class="line">all_values = test_data_list[<span class="number">2</span>].split(<span class="string">','</span>)</span><br><span class="line"><span class="comment">#print the lable</span></span><br><span class="line"><span class="comment">#打印标签</span></span><br><span class="line">print(<span class="string">'label:'</span>,all_values[<span class="number">0</span>])</span><br><span class="line"><span class="comment">#get the first test record</span></span><br><span class="line">all_values = test_data_list[<span class="number">2</span>].split(<span class="string">','</span>)</span><br><span class="line"><span class="comment">#print the lable</span></span><br><span class="line"><span class="comment">#打印标签</span></span><br><span class="line">print(<span class="string">'label:'</span>,all_values[<span class="number">0</span>])</span><br><span class="line">image_array = numpy.asfarray(all_values[<span class="number">1</span>:]).reshape((<span class="number">28</span>,<span class="number">28</span>))</span><br><span class="line">matplotlib.pyplot.imshow(image_array,cmap=<span class="string">'Greys'</span>,interpolation=<span class="string">'None'</span>)</span><br><span class="line">n.query((numpy.asfarray(all_values[<span class="number">1</span>:])/ <span class="number">255.0</span> * <span class="number">0.99</span>) + <span class="number">0.01</span>)</span><br></pre></td></tr></table></figure>

<p>记得给代码加上头文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="comment">#scipy.special for the sigmoid function expit()</span></span><br><span class="line"><span class="keyword">import</span> scipy.special</span><br><span class="line"><span class="comment">#添加绘图库</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Opencv将视频转换为字符视频</title>
    <url>/posts/43462.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：在Python课上学习了将图片转换为字符画的代码，想看看可不可以把视频转换为字符画视频，便有了此次为期一周陆陆续续写的视频画代码。</p>
<a id="more"></a>

<h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><ol>
<li>分离出构成视频的图片</li>
<li>对图片进行ASCII码的转换</li>
<li>将转换好的图片进行合成为视频</li>
<li>本次为了方便测试，未添加删除生成文件的代码，需要手动删除或者自己添加代码。</li>
</ol>
<h2 id="将像素转换为ASCII码"><a href="#将像素转换为ASCII码" class="headerlink" title="将像素转换为ASCII码"></a>将像素转换为ASCII码</h2><p>将像素转换为ASCII码是为了在后期上色以及转换为字符时加以区别。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_char</span><span class="params">(r,g,b,alpha = <span class="number">256</span>)</span>:</span></span><br><span class="line">    ascii_char = list(<span class="string">"#RMNHQODBWGPZ*@$C&amp;98?32I1&gt;!:-;. "</span>)</span><br><span class="line">    <span class="comment">#ascii_char = list("$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:oa+&gt;!:+. ")</span></span><br><span class="line">    <span class="keyword">if</span> alpha == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    length = len(ascii_char)</span><br><span class="line">    gray = int(<span class="number">0.2126</span> * r + <span class="number">0.7152</span> * g + <span class="number">0.0722</span> * b)</span><br><span class="line">    unit = (<span class="number">256.0</span>+<span class="number">1</span>)/len(ascii_char)</span><br><span class="line">    <span class="keyword">return</span> ascii_char[int(gray/unit)]</span><br></pre></td></tr></table></figure>

<p>​    此函数的输入的图片的三基色加上透明度，分别为R,G,B,ALPHA。此处会在后面用pixel = im.getpixel((j, i))来进行传递值。</p>
<p>​    其中ascii_char就是字符列表，用来将不同灰度的像素进行不同字符体替换的参照，大家可以参试用不同的字符来观察出最好的组合。ps:听说个数必须为32的倍数，我也没有进行尝试，有兴趣的小伙伴们可以探究下其中的原因。</p>
<p>​    alpha在为0的时候便是完全透明的图片，所以返回空，当他不为零时则将图片转换为灰度图像，此处运用    </p>
<p>​    gray = 0.2126 * r + 0.7152 * g + 0.0722 * b</p>
<p>来将图片转换为灰度图像进行下面的ASCII输出。</p>
<h2 id="将视频分隔成图片"><a href="#将视频分隔成图片" class="headerlink" title="将视频分隔成图片"></a>将视频分隔成图片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将视频转换为图片 并进行计数，返回总共生成了多少张图片！</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">video_to_pic</span><span class="params">(vp)</span>:</span></span><br><span class="line">    <span class="comment">#vp = cv2.VideoCapture(video_path)</span></span><br><span class="line">    number = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> vp.isOpened():</span><br><span class="line">        r,frame = vp.read()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'cache_pic'</span>):</span><br><span class="line">            os.mkdir(<span class="string">'cache_pic'</span>)</span><br><span class="line">        os.chdir(<span class="string">'cache_pic'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> r:</span><br><span class="line">        number += <span class="number">1</span></span><br><span class="line">        cv2.imwrite(str(number)+<span class="string">'.jpg'</span>,frame)</span><br><span class="line">        r,frame = vp.read()</span><br><span class="line">    print(<span class="string">'\n由视频一共生成了&#123;&#125;张图片！'</span>.format(number))</span><br><span class="line">    os.chdir(<span class="string">".."</span>)</span><br><span class="line">    <span class="keyword">return</span> number</span><br></pre></td></tr></table></figure>

<p>​    可以看出来函数的传入值是vp = cv2.VideoCapture(video_path) 我将其放在主函数来进行输入，怕某些小伙伴没看见所以下其下写了备注。</p>
<p>1.isOpened()的用来检测资源是否在 VideoCapture()函数中打开。</p>
<p>2.os.chdir在PYTHON中的方法是用于改变当前工作目录到指定的路径。此处直接进入新创建的文件夹将生成的图片直接存入文件夹中。</p>
<p>3.返回number方便于后面的使用。</p>
<h2 id="将图片转换为字符图片"><a href="#将图片转换为字符图片" class="headerlink" title="将图片转换为字符图片"></a>将图片转换为字符图片</h2><p>此处分为两个函数进行（明明放在一起可以省事，课当初太懒了，懒得改了555）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">star_to_char</span><span class="params">(number,save_pic_path)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'cache_char'</span>):</span><br><span class="line">        os.mkdir(<span class="string">'cache_char'</span>)</span><br><span class="line">    img_path_list = [save_pic_path + <span class="string">r'/&#123;&#125;.jpg'</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,number+<span class="number">1</span>)] <span class="comment">#生成目标图片文件的路径列表</span></span><br><span class="line">    task = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> image_path <span class="keyword">in</span> img_path_list:</span><br><span class="line">        img_width , img_height = Image.open(image_path).size   <span class="comment">#获取图片的分辨率</span></span><br><span class="line">        task += <span class="number">1</span></span><br><span class="line">        img_to_char(image_path, img_width , img_height, task)</span><br><span class="line">        print(<span class="string">'&#123;&#125;/&#123;&#125; is finished.'</span>.format(task,number))</span><br><span class="line">    print(<span class="string">'======================='</span>)</span><br><span class="line">    print(<span class="string">'All image was finished!'</span>)</span><br><span class="line">    print(<span class="string">'======================='</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>​    第一个函数相当于开始准备函数，其中传入的是上一个传出的总共生成多少个图片的统计number,还有字符图片存储的路径。</p>
<p>​    img_path_list 是用来存储图片相对路径的列表，采用内置for函数进行存储。</p>
<p>​    利用Image.open().size来获取图片大小，传入下面的转换函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_to_char</span><span class="params">(image_path,raw_width,raw_height,task)</span>:</span></span><br><span class="line">    width = int(raw_width/ <span class="number">6</span>)</span><br><span class="line">    height = int(raw_height / <span class="number">15</span>)</span><br><span class="line">    im = Image.open(image_path).convert(<span class="string">'RGB'</span>)<span class="comment">#必须以RGB模式打开</span></span><br><span class="line">    im = im.resize((width,height),Image.NEAREST)</span><br><span class="line">    </span><br><span class="line">    txt = <span class="string">''</span></span><br><span class="line">    color = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(height):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(width):</span><br><span class="line">            pixel = im.getpixel((j, i))</span><br><span class="line">            color.append((pixel[<span class="number">0</span>],pixel[<span class="number">1</span>],pixel[<span class="number">2</span>])) <span class="comment">#将颜色加入进行索引</span></span><br><span class="line">            <span class="keyword">if</span> len(pixel)==<span class="number">4</span> :</span><br><span class="line">                txt +=get_char(pixel[<span class="number">0</span>],pixel[<span class="number">1</span>],pixel[<span class="number">2</span>],pixel[<span class="number">3</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                txt +=get_char(pixel[<span class="number">0</span>],pixel[<span class="number">1</span>],pixel[<span class="number">2</span>])</span><br><span class="line">        txt += <span class="string">'\n'</span></span><br><span class="line">        color.append((<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br><span class="line"></span><br><span class="line">    im_txt = Image.new(<span class="string">"RGB"</span>,(raw_width,raw_height),(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br><span class="line">    dr = ImageDraw.Draw(im_txt)</span><br><span class="line">    <span class="comment">#font = ImageFont.truetype('consola.ttf', 10, encoding='unic') #改为这个字体会让图片比例改变</span></span><br><span class="line">    font = ImageFont.load_default().font</span><br><span class="line">    x,y = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    font_w,font_h=font.getsize(txt[<span class="number">1</span>])</span><br><span class="line">    font_h *= <span class="number">1.37</span> <span class="comment">#调整字体大小</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(txt)):</span><br><span class="line">        <span class="keyword">if</span>(txt[i]==<span class="string">'\n'</span>):</span><br><span class="line">            x += font_h</span><br><span class="line">            y = -font_w</span><br><span class="line">        dr.text((y,x),txt[i] ,fill = color[i])</span><br><span class="line">        y+=font_w</span><br><span class="line">    os.chdir(<span class="string">'cache_char'</span>)</span><br><span class="line">    im_txt.save(str(task)+<span class="string">'.jpg'</span>)</span><br><span class="line">    os.chdir(<span class="string">".."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>​    要提醒的是，看下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">width = int(raw_width/ 6)</span><br><span class="line">height = int(raw_height / 15)</span><br></pre></td></tr></table></figure>

<p>​    如果要将图片进行转换必须把图片大小进行转换，否则转换出的代码必定会出现乱码。</p>
<p>​    dr = ImageDraw.Draw(im_txt)是opencv中创建画板的函数。</p>
<p>​    font_h是将字体进行调整，可以让生成的字符画视频更加的好康。</p>
<p>​    下面 for i in range(len(txt)):就是遍历txt按行按列进行写入图片，当遇到\n时推出并进行上色，最后将图片进行输出。</p>
<h2 id="将图片合成为视频"><a href="#将图片合成为视频" class="headerlink" title="将图片合成为视频"></a>将图片合成为视频</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jpg_to_video</span><span class="params">(char_image_path,FPS)</span>:</span></span><br><span class="line">    video_fourcc=VideoWriter_fourcc(*<span class="string">"MP42"</span>)  <span class="comment"># 设置视频编码器,这里使用使用MP42编码器,可以生成更小的视频文件</span></span><br><span class="line">    char_img_path_list = [char_image_path + <span class="string">r'/&#123;&#125;.jpg'</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,number+<span class="number">1</span>)] <span class="comment">#生成目标字符图片文件的路径列表</span></span><br><span class="line">    char_img_test = Image.open(char_img_path_list[<span class="number">1</span>]).size   <span class="comment">#获取图片的分辨率</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'video'</span>):</span><br><span class="line">            os.mkdir(<span class="string">'video'</span>)</span><br><span class="line">    video_writter= VideoWriter(<span class="string">'video/new_char_video.avi'</span> , video_fourcc , FPS , char_img_test)</span><br><span class="line">    sum  = len(char_img_path_list)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> image_path <span class="keyword">in</span> char_img_path_list:</span><br><span class="line">        img = cv2.imread(image_path)</span><br><span class="line">        video_writter.write(img)</span><br><span class="line">        end_str = <span class="string">'100%'</span></span><br><span class="line">        count= count + <span class="number">1</span></span><br><span class="line">        process_bar(count/sum, start_str=<span class="string">''</span>, end_str=end_str, total_length=<span class="number">15</span>)</span><br><span class="line">    </span><br><span class="line">    video_writter.release()</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br><span class="line">    print(<span class="string">'======================='</span>)</span><br><span class="line">    print(<span class="string">'The video is finished!'</span>)</span><br><span class="line">    print(<span class="string">'======================='</span>)</span><br></pre></td></tr></table></figure>

<p>​    此处最需要注意的是第二行的视频编码器，我进行了大量的测试，发现MP42是可以生成较小并且较小的视频文件的编码方式，具体详细参数可以参考</p>
<p>[]: <a href="https://blog.csdn.net/Archger/article/details/102868923" target="_blank" rel="noopener">https://blog.csdn.net/Archger/article/details/102868923</a></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image,ImageFont,ImageDraw</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> cv2 <span class="keyword">import</span> VideoWriter, VideoWriter_fourcc, imread, resize</span><br><span class="line"><span class="comment">#=========================</span></span><br><span class="line"><span class="comment">#coding:UTF-8</span></span><br><span class="line"><span class="comment"># 视频转字符画含音频version-1</span></span><br><span class="line"><span class="comment">#参考1：https://blog.csdn.net/mp624183768/article/details/81161260</span></span><br><span class="line"><span class="comment">#参考2：https://blog.csdn.net/qq_42820064/article/details/90958577</span></span><br><span class="line"><span class="comment">#参考3：https://blog.csdn.net/zj360202/article/details/79026891</span></span><br><span class="line"><span class="comment">#=========================</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_char</span><span class="params">(r,g,b,alpha = <span class="number">256</span>)</span>:</span></span><br><span class="line">    ascii_char = list(<span class="string">"#RMNHQODBWGPZ*@$C&amp;98?32I1&gt;!:-;. "</span>)</span><br><span class="line">    <span class="comment">#ascii_char = list("$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:oa+&gt;!:+. ")</span></span><br><span class="line">    <span class="keyword">if</span> alpha == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    length = len(ascii_char)</span><br><span class="line">    gray = int(<span class="number">0.2126</span> * r + <span class="number">0.7152</span> * g + <span class="number">0.0722</span> * b)</span><br><span class="line">    unit = (<span class="number">256.0</span>+<span class="number">1</span>)/len(ascii_char)</span><br><span class="line">    <span class="keyword">return</span> ascii_char[int(gray/unit)]</span><br><span class="line"></span><br><span class="line"><span class="comment">#将视频转换为图片 并进行计数，返回总共生成了多少张图片！</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">video_to_pic</span><span class="params">(vp)</span>:</span></span><br><span class="line">    <span class="comment">#vp = cv2.VideoCapture(video_path)</span></span><br><span class="line">    number = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> vp.isOpened():</span><br><span class="line">        r,frame = vp.read()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'cache_pic'</span>):</span><br><span class="line">            os.mkdir(<span class="string">'cache_pic'</span>)</span><br><span class="line">        os.chdir(<span class="string">'cache_pic'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> r:</span><br><span class="line">        number += <span class="number">1</span></span><br><span class="line">        cv2.imwrite(str(number)+<span class="string">'.jpg'</span>,frame)</span><br><span class="line">        r,frame = vp.read()</span><br><span class="line">    print(<span class="string">'\n由视频一共生成了&#123;&#125;张图片！'</span>.format(number))</span><br><span class="line">    os.chdir(<span class="string">".."</span>)</span><br><span class="line">    <span class="keyword">return</span> number</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_to_char</span><span class="params">(image_path,raw_width,raw_height,task)</span>:</span></span><br><span class="line">    width = int(raw_width/ <span class="number">6</span>)</span><br><span class="line">    height = int(raw_height / <span class="number">15</span>)</span><br><span class="line">    im = Image.open(image_path).convert(<span class="string">'RGB'</span>)<span class="comment">#必须以RGB模式打开</span></span><br><span class="line">    im = im.resize((width,height),Image.NEAREST)</span><br><span class="line">    </span><br><span class="line">    txt = <span class="string">''</span></span><br><span class="line">    color = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(height):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(width):</span><br><span class="line">            pixel = im.getpixel((j, i))</span><br><span class="line">            color.append((pixel[<span class="number">0</span>],pixel[<span class="number">1</span>],pixel[<span class="number">2</span>])) <span class="comment">#将颜色加入进行索引</span></span><br><span class="line">            <span class="keyword">if</span> len(pixel)==<span class="number">4</span> :</span><br><span class="line">                txt +=get_char(pixel[<span class="number">0</span>],pixel[<span class="number">1</span>],pixel[<span class="number">2</span>],pixel[<span class="number">3</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                txt +=get_char(pixel[<span class="number">0</span>],pixel[<span class="number">1</span>],pixel[<span class="number">2</span>])</span><br><span class="line">        txt += <span class="string">'\n'</span></span><br><span class="line">        color.append((<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br><span class="line"></span><br><span class="line">    im_txt = Image.new(<span class="string">"RGB"</span>,(raw_width,raw_height),(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br><span class="line">    dr = ImageDraw.Draw(im_txt)</span><br><span class="line">    <span class="comment">#font = ImageFont.truetype('consola.ttf', 10, encoding='unic') #改为这个字体会让图片比例改变</span></span><br><span class="line">    font = ImageFont.load_default().font</span><br><span class="line">    x,y = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    font_w,font_h=font.getsize(txt[<span class="number">1</span>])</span><br><span class="line">    font_h *= <span class="number">1.37</span> <span class="comment">#调整字体大小</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(txt)):</span><br><span class="line">        <span class="keyword">if</span>(txt[i]==<span class="string">'\n'</span>):</span><br><span class="line">            x += font_h</span><br><span class="line">            y = -font_w</span><br><span class="line">        dr.text((y,x),txt[i] ,fill = color[i])</span><br><span class="line">        y+=font_w</span><br><span class="line">    os.chdir(<span class="string">'cache_char'</span>)</span><br><span class="line">    im_txt.save(str(task)+<span class="string">'.jpg'</span>)</span><br><span class="line">    os.chdir(<span class="string">".."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">star_to_char</span><span class="params">(number,save_pic_path)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'cache_char'</span>):</span><br><span class="line">        os.mkdir(<span class="string">'cache_char'</span>)</span><br><span class="line">    img_path_list = [save_pic_path + <span class="string">r'/&#123;&#125;.jpg'</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,number+<span class="number">1</span>)] <span class="comment">#生成目标图片文件的路径列表</span></span><br><span class="line">    task = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> image_path <span class="keyword">in</span> img_path_list:</span><br><span class="line">        img_width , img_height = Image.open(image_path).size   <span class="comment">#获取图片的分辨率</span></span><br><span class="line">        task += <span class="number">1</span></span><br><span class="line">        img_to_char(image_path, img_width , img_height, task)</span><br><span class="line">        print(<span class="string">'&#123;&#125;/&#123;&#125; is finished.'</span>.format(task,number))</span><br><span class="line">    print(<span class="string">'======================='</span>)</span><br><span class="line">    print(<span class="string">'All image was finished!'</span>)</span><br><span class="line">    print(<span class="string">'======================='</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_bar</span><span class="params">(percent, start_str=<span class="string">''</span>, end_str=<span class="string">''</span>, total_length=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="comment">#进度条</span></span><br><span class="line">    bar = <span class="string">''</span>.join(<span class="string">"■ "</span> * int(percent * total_length)) + <span class="string">''</span></span><br><span class="line">    bar = <span class="string">'\r'</span> + start_str + bar.ljust(total_length) + <span class="string">' &#123;:0&gt;4.1f&#125;%|'</span>.format(percent*<span class="number">100</span>) + end_str</span><br><span class="line">    print(bar, end=<span class="string">''</span>, flush=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jpg_to_video</span><span class="params">(char_image_path,FPS)</span>:</span></span><br><span class="line">    video_fourcc=VideoWriter_fourcc(*<span class="string">"MP42"</span>)  <span class="comment"># 设置视频编码器,这里使用使用MP42编码器,可以生成更小的视频文件</span></span><br><span class="line">    char_img_path_list = [char_image_path + <span class="string">r'/&#123;&#125;.jpg'</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,number+<span class="number">1</span>)] <span class="comment">#生成目标字符图片文件的路径列表</span></span><br><span class="line">    char_img_test = Image.open(char_img_path_list[<span class="number">1</span>]).size   <span class="comment">#获取图片的分辨率</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'video'</span>):</span><br><span class="line">            os.mkdir(<span class="string">'video'</span>)</span><br><span class="line">    video_writter= VideoWriter(<span class="string">'video/new_char_video.avi'</span> , video_fourcc , FPS , char_img_test)</span><br><span class="line">    sum  = len(char_img_path_list)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> image_path <span class="keyword">in</span> char_img_path_list:</span><br><span class="line">        img = cv2.imread(image_path)</span><br><span class="line">        video_writter.write(img)</span><br><span class="line">        end_str = <span class="string">'100%'</span></span><br><span class="line">        count= count + <span class="number">1</span></span><br><span class="line">        process_bar(count/sum, start_str=<span class="string">''</span>, end_str=end_str, total_length=<span class="number">15</span>)</span><br><span class="line">    </span><br><span class="line">    video_writter.release()</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br><span class="line">    print(<span class="string">'======================='</span>)</span><br><span class="line">    print(<span class="string">'The video is finished!'</span>)</span><br><span class="line">    print(<span class="string">'======================='</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    </span><br><span class="line">    video_path = <span class="string">'test.mp4'</span></span><br><span class="line">    save_pic_path = <span class="string">'cache_pic'</span></span><br><span class="line">    save_charpic_path = <span class="string">'cache_char'</span></span><br><span class="line"></span><br><span class="line">    vp = cv2.VideoCapture(video_path)</span><br><span class="line">    number = video_to_pic(vp)</span><br><span class="line">    FPS = vp.get(cv2.CAP_PROP_FPS)</span><br><span class="line">    star_to_char(number , save_pic_path)</span><br><span class="line">    vp.release()</span><br><span class="line">    jpg_to_video(save_charpic_path,FPS)</span><br></pre></td></tr></table></figure>

<p>注：转载请注明出处</p>
]]></content>
      <categories>
        <category>python</category>
        <category>Opencv</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>利用python的海龟素描出一张图片的内容</title>
    <url>/posts/turtle_draw_pic.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要： 这是一篇有关利用OpenCV+turtle根据图片来绘画出一副素描画的总结。</p>
<a id="more"></a>

<p>（拖延了好久！很抱歉@_@)</p>
<p>其实这是我在做车牌号识别的项目中玩OpenCV产生的灵感！想着turtle竟然可以读取坐标进行画图，那我将图片的坐标让海龟自动帮我画画岂不是很好吗！哈哈哈哈哈哈哈我可真是个小天才，老资本家了（狗头）</p>
<h2 id="视频效果展示："><a href="#视频效果展示：" class="headerlink" title="视频效果展示："></a>视频效果展示：</h2><iframe class="bilibili" src="//player.bilibili.com/player.html?aid=752975530&bvid=BV1Sk4y1r7mH&cid=182293755&page=1&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"> </iframe>

<h2 id="图片效果展示："><a href="#图片效果展示：" class="headerlink" title="图片效果展示："></a>图片效果展示：</h2><p><img src="https://gitee.com/hongcyu/image/raw/master/images/image.jpg" alt></p>
<p>变成</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/2313S1.PNG" alt="2313S1"></p>
<blockquote>
<p> tip: 根据[名为一无]小伙伴提出的建议做出说明：新版<a href="https://www.bilibili.com/read/cv2/" target="_blank" rel="noopener">cv2</a>这个库的findContours这个函数对比老版本返回值只有两个，另外优化上turtle设置成速度为0就已经是最大速度了，更快可以增加一个delay(0)以去掉绘画延迟</p>
</blockquote>
<h2 id="步骤拆解"><a href="#步骤拆解" class="headerlink" title="步骤拆解"></a>步骤拆解</h2><h3 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">image = cv2.imread(pic,<span class="number">0</span>)			<span class="comment">#读取图像</span></span><br><span class="line">edges = cv2.Canny(image,<span class="number">100</span>,<span class="number">200</span>)	<span class="comment">#进行边缘检测</span></span><br></pre></td></tr></table></figure>

<p>在 OpenCV 中只需要一个函数：cv2.Canny()，就可以完成。 让我们看如何使用这个函数。这个函数的第一个参数是输入图像。第二和第三 个分别是 minVal 和 maxVal。第三个参数设置用来计算图像梯度的 Sobel 卷积核的大小，默认值为 3。最后一个参数是 L2gradient，它可以用来设定 求梯度大小的方程。当为False时 使用方程：Edge−Gradient(G) = |G2 x | + |G2 y | 代替，默认值为 False。</p>
<p>效果图：<img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200816120840476.png" alt="image-20200816120840476"></p>
<p>很棒提取出来的边缘很不错的，各位可以试着调节minVal 和 maxVal来看看有什么区别！</p>
<h3 id="灰度处理"><a href="#灰度处理" class="headerlink" title="灰度处理"></a>灰度处理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">img_gray = cv2.cvtColor(edges,cv2.COLOR_BAYER_BG2GRAY)</span><br></pre></td></tr></table></figure>

<p>在 OpenCV 中有超过 150 中进行颜色空间转换的方法。但是你以后就会 发现我们经常用到的也就两种：BGR↔Gray 和 BGR↔HSV。 我们要用到的函数是：cv2.cvtColor(input_image，flag)，其中 flag 就是转换类型。 对于 BGR↔Gray 的转换，我们要使用的 flag 就是 cv2.COLOR_BGR2GRAY。 同样对于 BGR↔HSV 的转换，我们用的 flag 就是 cv2.COLOR_BGR2HSV。 </p>
<p>为什么已经变成黑白了还要进行灰度处理呢，这是为了更好的进行下一步（图像阈值）做准备，可以先来看看不进行灰度处理的效果：</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200816121319592.png" alt="image-20200816121319592"></p>
<p>点分布的不均匀，提取出来的点很少，增加灰度处理可以使得下一步图像阈值更好的进行处理。</p>
<h3 id="图像阈值"><a href="#图像阈值" class="headerlink" title="图像阈值"></a>图像阈值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ret, thresh = cv2.threshold(img_gray,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>与名字一样，这种方法非常简单。但像素值高于阈值时，我们给这个像素 赋予一个新值（可能是白色），否则我们给它赋予另外一种颜色（也许是黑色）。 这个函数就是 cv2.threshhold()。这个函数的第一个参数就是原图像，原图 像应该是灰度图。第二个参数就是用来对像素值进行分类的阈值。第三个参数 就是当像素值高于（有时是小于）阈值时应该被赋予的新的像素值。OpenCV 提供了多种不同的阈值方法，这是有第四个参数来决定的。这些方法包括： </p>
<p>• cv2.THRESH_BINARY </p>
<p>• cv2.THRESH_BINARY_INV </p>
<p>• cv2.THRESH_TRUNC </p>
<p>• cv2.THRESH_TOZERO </p>
<p>• cv2.THRESH_TOZERO_INV</p>
<blockquote>
<p> 这一步是为了提取出thresh为下一步提取坐标做准备，此处参数部分我也不是很懂，希望小伙伴可以帮我解答</p>
</blockquote>
<h3 id="提取目标轮廓坐标"><a href="#提取目标轮廓坐标" class="headerlink" title="提取目标轮廓坐标"></a>提取目标轮廓坐标</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#下面这句是老版本opencv的写法，如果运行报错可以将下句注释，取消下下句的注释</span><br><span class="line">image,contours,hierarchy = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">#contours,hierarchy = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)</span><br></pre></td></tr></table></figure>

<p>函数 cv2.findContours() 有三个参数，第一个是输入图像，第二个是 轮廓检索模式，第三个是轮廓近似方法。返回值有三个，第一个是图像，第二个 是轮廓，第三个是（轮廓的）层析结构。轮廓（第二个返回值）是一个 Python 列表，其中存储这图像中的所有轮廓。每一个轮廓都是一个 Numpy 数组，包 含对象边界点（x，y）的坐标。</p>
<p>从这里就可以发现，目标轮廓就在我们得到的contours里啦！</p>
<p>打印出contours会发现里面是很多的直矩阵的坐标：</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200816122814951.png" alt="image-20200816122814951"></p>
<p>接下来我们只要提取出坐标就大功告成了！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x,y,w,h = cv2.boundingRect(contours[i])</span><br></pre></td></tr></table></figure>

<p>直边界矩形 一个直矩形（就是没有旋转的矩形）。它不会考虑对象是否旋转。 所以边界矩形的面积不是最小的。可以使用函数 cv2.boundingRect() 查找得到。 （x，y）为矩形左上角的坐标，（w，h）是矩形的宽和高。</p>
<h3 id="小海龟该怎么写"><a href="#小海龟该怎么写" class="headerlink" title="小海龟该怎么写"></a>小海龟该怎么写</h3><p>其实turtle怎么写，多玩几遍就知道了，说实话我也经常忘记，但是我记得有这些步骤，我去看看语法怎么写就容易写出来（记性老差了）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(xy)</span>:</span></span><br><span class="line">    turtle.pensize(<span class="number">2</span>)		<span class="comment">#设置画笔大小</span></span><br><span class="line">    turtle.setup(width=<span class="number">0.6</span>,height=<span class="number">1.0</span>)	<span class="comment">#设置画布大小</span></span><br><span class="line">    turtle.speed(<span class="number">0</span>)	<span class="comment">#设置速度</span></span><br><span class="line">    <span class="keyword">for</span> array <span class="keyword">in</span> xy[::<span class="number">-1</span>]:	</span><br><span class="line">        turtle.penup()	<span class="comment">#提起画笔</span></span><br><span class="line">        turtle.goto((array[<span class="number">0</span>]/<span class="number">2</span>)<span class="number">-100</span>,-(array[<span class="number">1</span>]/<span class="number">2</span>)+<span class="number">250</span>)	<span class="comment">#到指定坐标</span></span><br><span class="line">        turtle.pendown()	<span class="comment">#放下画笔</span></span><br><span class="line">        turtle.forward(<span class="number">1</span>)	<span class="comment">#画多长长度</span></span><br><span class="line">        print(turtle.pos())	<span class="comment">#命令行显示出来，可以注释掉</span></span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    turtle.done()	<span class="comment">#保留画的图</span></span><br></pre></td></tr></table></figure>

<h2 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h2><p>下面是整体代码的实现</p>
<p>github:<a href="https://github.com/hongcyu/turtle_draw" target="_blank" rel="noopener">https://github.com/hongcyu/turtle_draw</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">array_pic</span><span class="params">(pic)</span>:</span></span><br><span class="line">    image = cv2.imread(pic,<span class="number">0</span>)</span><br><span class="line">    edges = cv2.Canny(image,<span class="number">100</span>,<span class="number">200</span>)</span><br><span class="line">    img_gray = cv2.cvtColor(edges,cv2.COLOR_BAYER_BG2GRAY)</span><br><span class="line">    ret, thresh = cv2.threshold(img_gray,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#下面这句是老版本opencv的写法，如果运行报错可以将下句注释，取消下下句的注释</span></span><br><span class="line">    image,contours,hierarchy = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">    <span class="comment">#contours,hierarchy = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)</span></span><br><span class="line">    xy = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(contours)):</span><br><span class="line">        x,y,w,h = cv2.boundingRect(contours[i])</span><br><span class="line">        list_xy = [x,y]</span><br><span class="line">        xy.append(list_xy)</span><br><span class="line">    <span class="keyword">return</span> xy</span><br><span class="line">    <span class="comment"># file = open("array.txt", mode="x")</span></span><br><span class="line">    <span class="comment"># file.writelines(str(contours))</span></span><br><span class="line">    <span class="comment"># file.close()</span></span><br><span class="line">    <span class="comment"># cv2.imshow("1.jpg",image)</span></span><br><span class="line">    <span class="comment"># cv2.waitKey(0)</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(xy)</span>:</span></span><br><span class="line">    turtle.pensize(<span class="number">2</span>)</span><br><span class="line">    turtle.setup(width=<span class="number">0.6</span>,height=<span class="number">1.0</span>)</span><br><span class="line">    turtle.speed(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> array <span class="keyword">in</span> xy[::<span class="number">-1</span>]:</span><br><span class="line">        turtle.penup()</span><br><span class="line">        turtle.goto((array[<span class="number">0</span>]/<span class="number">2</span>)<span class="number">-100</span>,-(array[<span class="number">1</span>]/<span class="number">2</span>)+<span class="number">250</span>)</span><br><span class="line">        turtle.pendown()</span><br><span class="line">        turtle.forward(<span class="number">1</span>)</span><br><span class="line">        print(turtle.pos())</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    turtle.done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    pic = <span class="string">"image.jpg"</span></span><br><span class="line">    xy = array_pic(pic)</span><br><span class="line">    draw(xy)</span><br></pre></td></tr></table></figure>

<h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><ol>
<li><p>你需要安装opencv，在cmd中输入：<strong>pip3 install opencv-python</strong></p>
</li>
<li><p>要使用需要将图片放置在和py文件同一个文件夹下，接着修改下面的pic后的参数为图片名字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line"> 	pic = &quot;image.jpg&quot;</span><br><span class="line"> 	xy = array_pic(pic)</span><br><span class="line">	 draw(xy)</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>turtle</tag>
      </tags>
  </entry>
  <entry>
    <title>城市观星指南——轻松找到北极星</title>
    <url>/posts/city-star1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：是不是憋在家里好久没出门放风了？在做好防护的前提下在空旷的楼下广场或自家阳台上看星星是缓解焦虑心情的好选择。</p>
<a id="more"></a>

<h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/city_star1.jpg" alt></p>
<p>北极星并不是某一特定的天体，而是指最靠近北天极的一颗星， 由于地球自转轴的漂移，产生了名为岁差的现象，岁差周期大概是26000年，在这段时间中，被称为北极星的天体也会不断更替。现阶段是由勾陈一代理北极星这一称号，但现在也还不是它最最靠近北天极的时候，预计在2100年时它会到达离北天极只有28′，然后，勾陈一就将逐渐远离北天极，而勾陈四也会逐渐成为下一任北极星。</p>
<p>下面我们看看小姐姐的视频：</p>
<iframe class="bilibili" src="//player.bilibili.com/player.html?aid=92102231&cid=157257711&page=1&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"> </iframe>

<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>北极星是古代航海、野外活动辨认方向的一个很重要指标，另外也是小至观星入门之辨认方向星座，大至天文摄影、观测室赤道仪的准确定位等皆为十分重要的作用。由于北极星最靠近正北的方位，千百年来地球上的人们也靠它的星光来导航。</p>
<p>在北半球的夜空中，位于北方天空的北斗七星十分显眼，这七颗恒星分别是大熊座的天枢（贪狼）、天璇（巨门）、天玑（禄存）、天权（文曲）、玉衡（廉贞）、开阳（武曲）以及瑶光（破军）。它们看起来比其他星星明亮，而且排列成勺子状。如果沿着天璇和天枢的方向延伸大约5倍，可以找到另一颗亮星，这就是北极星。无论在什么时候观测北斗七星和北极星，都会观测到这样的现象。在我国古代，北斗七星被用来“定四时，分寒暑”——“斗柄东指，天下皆春；斗柄南指，天下皆夏；斗柄西指，天下皆秋；斗柄北指，天下皆冬。”通过北斗七星的斗柄方向变化，可以知道季节更替。</p>
<h2 id="个人感想"><a href="#个人感想" class="headerlink" title="个人感想"></a>个人感想</h2><p>我已经很久没有抬头看看星星了，忽然看到这个视频，产生了很大的感触。</p>
<p>人有的时候停下来休息，抬头看看星空也未免不是一种感受宁静的方式。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>观星</tag>
      </tags>
  </entry>
  <entry>
    <title>利用you-get下载全网的视频</title>
    <url>/posts/download_video.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：发现了一个python写的下载小工具，可以下载近乎全网的视频，特来分享一下。</p>
<a id="more"></a>

<h2 id="you-get"><a href="#you-get" class="headerlink" title="you-get"></a>you-get</h2><blockquote>
<p>you-get 是 <a href="https://github.com/soimort/you-get" target="_blank" rel="noopener">https://github.com/soimort/you-get</a> 上的一个开源项目，搭建可以通过这个项目下载大多数网站的音视频文件。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200301095544.png" alt></p>
<p>you-get支持的网站非常多，我们可以先来看一部分：</p>
<p>支持网站：（包括国外网站和国内网站）</p>
<table>
<thead>
<tr>
<th>Site</th>
<th>URL</th>
<th>Videos?</th>
<th>Images?</th>
<th>Audios?</th>
</tr>
</thead>
<tbody><tr>
<td><strong>YouTube</strong></td>
<td><a href="https://www.youtube.com/" target="_blank" rel="noopener">https://www.youtube.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Twitter</strong></td>
<td><a href="https://twitter.com/" target="_blank" rel="noopener">https://twitter.com/</a></td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>VK</td>
<td><a href="http://vk.com/" target="_blank" rel="noopener">http://vk.com/</a></td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>Vine</td>
<td><a href="https://vine.co/" target="_blank" rel="noopener">https://vine.co/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Vimeo</td>
<td><a href="https://vimeo.com/" target="_blank" rel="noopener">https://vimeo.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Vidto</td>
<td><a href="http://vidto.me/" target="_blank" rel="noopener">http://vidto.me/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Videomega</td>
<td><a href="http://videomega.tv/" target="_blank" rel="noopener">http://videomega.tv/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Veoh</td>
<td><a href="http://www.veoh.com/" target="_blank" rel="noopener">http://www.veoh.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Tumblr</strong></td>
<td><a href="https://www.tumblr.com/" target="_blank" rel="noopener">https://www.tumblr.com/</a></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>TED</td>
<td><a href="http://www.ted.com/" target="_blank" rel="noopener">http://www.ted.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>SoundCloud</td>
<td><a href="https://soundcloud.com/" target="_blank" rel="noopener">https://soundcloud.com/</a></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td>SHOWROOM</td>
<td><a href="https://www.showroom-live.com/" target="_blank" rel="noopener">https://www.showroom-live.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Pinterest</td>
<td><a href="https://www.pinterest.com/" target="_blank" rel="noopener">https://www.pinterest.com/</a></td>
<td></td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>MusicPlayOn</td>
<td><a href="http://en.musicplayon.com/" target="_blank" rel="noopener">http://en.musicplayon.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>MTV81</td>
<td><a href="http://www.mtv81.com/" target="_blank" rel="noopener">http://www.mtv81.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Mixcloud</td>
<td><a href="https://www.mixcloud.com/" target="_blank" rel="noopener">https://www.mixcloud.com/</a></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td>Metacafe</td>
<td><a href="http://www.metacafe.com/" target="_blank" rel="noopener">http://www.metacafe.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Magisto</td>
<td><a href="http://www.magisto.com/" target="_blank" rel="noopener">http://www.magisto.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Khan Academy</td>
<td><a href="https://www.khanacademy.org/" target="_blank" rel="noopener">https://www.khanacademy.org/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Internet Archive</td>
<td><a href="https://archive.org/" target="_blank" rel="noopener">https://archive.org/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Instagram</strong></td>
<td><a href="https://instagram.com/" target="_blank" rel="noopener">https://instagram.com/</a></td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>InfoQ</td>
<td><a href="http://www.infoq.com/presentations/" target="_blank" rel="noopener">http://www.infoq.com/presentations/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Imgur</td>
<td><a href="http://imgur.com/" target="_blank" rel="noopener">http://imgur.com/</a></td>
<td></td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>Heavy Music Archive</td>
<td><a href="http://www.heavy-music.ru/" target="_blank" rel="noopener">http://www.heavy-music.ru/</a></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td><strong>Google+</strong></td>
<td><a href="https://plus.google.com/" target="_blank" rel="noopener">https://plus.google.com/</a></td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>Freesound</td>
<td><a href="http://www.freesound.org/" target="_blank" rel="noopener">http://www.freesound.org/</a></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td>Flickr</td>
<td><a href="https://www.flickr.com/" target="_blank" rel="noopener">https://www.flickr.com/</a></td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>FC2 Video</td>
<td><a href="http://video.fc2.com/" target="_blank" rel="noopener">http://video.fc2.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Facebook</td>
<td><a href="https://www.facebook.com/" target="_blank" rel="noopener">https://www.facebook.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>eHow</td>
<td><a href="http://www.ehow.com/" target="_blank" rel="noopener">http://www.ehow.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Dailymotion</td>
<td><a href="http://www.dailymotion.com/" target="_blank" rel="noopener">http://www.dailymotion.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Coub</td>
<td><a href="http://coub.com/" target="_blank" rel="noopener">http://coub.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CBS</td>
<td><a href="http://www.cbs.com/" target="_blank" rel="noopener">http://www.cbs.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Bandcamp</td>
<td><a href="http://bandcamp.com/" target="_blank" rel="noopener">http://bandcamp.com/</a></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td>AliveThai</td>
<td><a href="http://alive.in.th/" target="_blank" rel="noopener">http://alive.in.th/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>interest.me</td>
<td><a href="http://ch.interest.me/tvn" target="_blank" rel="noopener">http://ch.interest.me/tvn</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>755ナナゴーゴー</strong></td>
<td><a href="http://7gogo.jp/" target="_blank" rel="noopener">http://7gogo.jp/</a></td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td><strong>niconicoニコニコ動画</strong></td>
<td><a href="http://www.nicovideo.jp/" target="_blank" rel="noopener">http://www.nicovideo.jp/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>163网易视频网易云音乐</strong></td>
<td><a href="http://v.163.com/" target="_blank" rel="noopener">http://v.163.com/</a> <a href="http://music.163.com/" target="_blank" rel="noopener">http://music.163.com/</a></td>
<td>✓</td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td>56网</td>
<td><a href="http://www.56.com/" target="_blank" rel="noopener">http://www.56.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>AcFun</strong></td>
<td><a href="http://www.acfun.tv/" target="_blank" rel="noopener">http://www.acfun.tv/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Baidu百度贴吧</strong></td>
<td><a href="http://tieba.baidu.com/" target="_blank" rel="noopener">http://tieba.baidu.com/</a></td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>爆米花网</td>
<td><a href="http://www.baomihua.com/" target="_blank" rel="noopener">http://www.baomihua.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>bilibili哔哩哔哩</strong></td>
<td><a href="http://www.bilibili.com/" target="_blank" rel="noopener">http://www.bilibili.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>豆瓣</td>
<td><a href="http://www.douban.com/" target="_blank" rel="noopener">http://www.douban.com/</a></td>
<td>✓</td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td>斗鱼</td>
<td><a href="http://www.douyutv.com/" target="_blank" rel="noopener">http://www.douyutv.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Panda 熊猫</td>
<td><a href="http://www.panda.tv/" target="_blank" rel="noopener">http://www.panda.tv/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>凤凰视频</td>
<td><a href="http://v.ifeng.com/" target="_blank" rel="noopener">http://v.ifeng.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>风行网</td>
<td><a href="http://www.fun.tv/" target="_blank" rel="noopener">http://www.fun.tv/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>iQIYI 爱奇艺</td>
<td><a href="http://www.iqiyi.com/" target="_blank" rel="noopener">http://www.iqiyi.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>激动网</td>
<td><a href="http://www.joy.cn/" target="_blank" rel="noopener">http://www.joy.cn/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>酷6网</td>
<td><a href="http://www.ku6.com/" target="_blank" rel="noopener">http://www.ku6.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>酷狗音乐</td>
<td><a href="http://www.kugou.com/" target="_blank" rel="noopener">http://www.kugou.com/</a></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td>酷我音乐</td>
<td><a href="http://www.kuwo.cn/" target="_blank" rel="noopener">http://www.kuwo.cn/</a></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td>乐视网</td>
<td><a href="http://www.le.com/" target="_blank" rel="noopener">http://www.le.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>荔枝FM</td>
<td><a href="http://www.lizhi.fm/" target="_blank" rel="noopener">http://www.lizhi.fm/</a></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td>秒拍</td>
<td><a href="http://www.miaopai.com/" target="_blank" rel="noopener">http://www.miaopai.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>MioMio弹幕网</td>
<td><a href="http://www.miomio.tv/" target="_blank" rel="noopener">http://www.miomio.tv/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>痞客邦</td>
<td><a href="https://www.pixnet.net/" target="_blank" rel="noopener">https://www.pixnet.net/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PPTV聚力</td>
<td><a href="http://www.pptv.com/" target="_blank" rel="noopener">http://www.pptv.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>齐鲁网</td>
<td><a href="http://v.iqilu.com/" target="_blank" rel="noopener">http://v.iqilu.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>QQ 腾讯视频</td>
<td><a href="http://v.qq.com/" target="_blank" rel="noopener">http://v.qq.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>企鹅直播</td>
<td><a href="http://live.qq.com/" target="_blank" rel="noopener">http://live.qq.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Sina 新浪视频 微博秒拍视频</td>
<td><a href="http://video.sina.com.cn/" target="_blank" rel="noopener">http://video.sina.com.cn/</a> <a href="http://video.weibo.com/" target="_blank" rel="noopener">http://video.weibo.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Sohu 搜狐视频</td>
<td><a href="http://tv.sohu.com/" target="_blank" rel="noopener">http://tv.sohu.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Tudou土豆</strong></td>
<td><a href="http://www.tudou.com/" target="_blank" rel="noopener">http://www.tudou.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>虾米</td>
<td><a href="http://www.xiami.com/" target="_blank" rel="noopener">http://www.xiami.com/</a></td>
<td>✓</td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td>阳光卫视</td>
<td><a href="http://www.isuntv.com/" target="_blank" rel="noopener">http://www.isuntv.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>音悦Tai</strong></td>
<td><a href="http://www.yinyuetai.com/" target="_blank" rel="noopener">http://www.yinyuetai.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Youku优酷</strong></td>
<td><a href="http://www.youku.com/" target="_blank" rel="noopener">http://www.youku.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>战旗TV</td>
<td><a href="http://www.zhanqi.tv/lives" target="_blank" rel="noopener">http://www.zhanqi.tv/lives</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>央视网</td>
<td><a href="http://www.cntv.cn/" target="_blank" rel="noopener">http://www.cntv.cn/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Naver 네이버</td>
<td><a href="http://tvcast.naver.com/" target="_blank" rel="noopener">http://tvcast.naver.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>芒果TV</td>
<td><a href="http://www.mgtv.com/" target="_blank" rel="noopener">http://www.mgtv.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>火猫TV</td>
<td><a href="http://www.huomao.com/" target="_blank" rel="noopener">http://www.huomao.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>阳光宽频网</td>
<td><a href="http://www.365yg.com/" target="_blank" rel="noopener">http://www.365yg.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>西瓜视频</td>
<td><a href="https://www.ixigua.com/" target="_blank" rel="noopener">https://www.ixigua.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>快手</td>
<td><a href="https://www.kuaishou.com/" target="_blank" rel="noopener">https://www.kuaishou.com/</a></td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>抖音</td>
<td><a href="https://www.douyin.com/" target="_blank" rel="noopener">https://www.douyin.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>TikTok</td>
<td><a href="https://www.tiktok.com/" target="_blank" rel="noopener">https://www.tiktok.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>中国体育(TV)</td>
<td><a href="http://v.zhibo.tv/" target="_blank" rel="noopener">http://v.zhibo.tv/</a> <a href="http://video.zhibo.tv/" target="_blank" rel="noopener">http://video.zhibo.tv/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>知乎</td>
<td><a href="https://www.zhihu.com/" target="_blank" rel="noopener">https://www.zhihu.com/</a></td>
<td>✓</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在官方文档内可以很清楚的看到安装需要些什么</p>
<p>The following dependencies are necessary:</p>
<ul>
<li><strong>Python</strong>  3.2 or above</li>
<li><strong>FFmpeg</strong> 1.0 or above</li>
<li>(Optional) <a href="https://rtmpdump.mplayerhq.hu/" target="_blank" rel="noopener">RTMPDump</a></li>
</ul>
<p>官方还提供了很多下载使用的方式，不过我就在这里简述一下我使用的方式：</p>
<ol>
<li><p>安装python3.2及以上的版本</p>
<p>百度  <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 会告诉你怎么安装。</p>
</li>
<li><p>打开CMD（win+R）输入cmd，点击确定</p>
<p>就是进入Windows命令行窗口啦！</p>
</li>
<li><p>安装you-get工具</p>
<p><code>pip3 install you-get</code></p>
<p>会看到如下提示即为安装成功：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200301100302.png" alt></p>
</li>
<li><p>测试</p>
<p>打开想要下载的视频，复制链接：</p>
<p>举个栗子：<a href="https://www.bilibili.com/video/av81148317" target="_blank" rel="noopener">https://www.bilibili.com/video/av81148317</a></p>
<p>在命令行工具中输入<code>you-get 视频地址</code>再按下回车即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200301100631.png" alt></p>
<blockquote>
<p> 这里的下载速度是按照自己网络的情况来决定的。</p>
</blockquote>
<p>默认会下载到C:\Users\ &lt;你自己的用户名&gt;</p>
</li>
</ol>
<p>   当然还可以加入不同的参数来修改下载的方式：</p>
<blockquote>
<p>比如可以用带参数 -o 将视频下载到指定位置：</p>
</blockquote>
<p>   <img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200301101633.jpg" alt></p>
<blockquote>
<p>带参数 -i 查看视频下载的画质等信息</p>
</blockquote>
<p>   <img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200301102014.png" alt></p>
<p>   然后根据提示就可以下载任意画质啦~</p>
<p>   <img src="https://cdn.jsdelivr.net/gh/hongcyu/image/images/20200301102451.png" alt></p>
<p>   大家可以多多测试一下,更多参数可以查阅官方文档~</p>
<p>​    参考：<a href="https://bestzuo.cn/posts/5a881936.html" target="_blank" rel="noopener">https://bestzuo.cn/posts/5a881936.html</a></p>
]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>下载</tag>
      </tags>
  </entry>
  <entry>
    <title>如何更好地理解KMP算法(C+Python)</title>
    <url>/posts/KMP_C_and_Python.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：本文通过讲解next数组的生成以及如何使用next数组来实现KMP算法，采取C和Python进行编写。</p>
<a id="more"></a>

<p>正文：</p>
<p>关于KMP主要难点是next[]数组，模式串的下一个匹配位k及模式串向右移动的距离m,以下我分三步并结合例子讲解三个难点。</p>
<h3 id="明确概念"><a href="#明确概念" class="headerlink" title="明确概念"></a>明确概念</h3><ul>
<li>”前缀”和”后缀”：“前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。例如”ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D].</li>
<li>最大公共前后缀：基于前缀，和后缀概念，在一个字符串中，最长的相同的前缀和后缀称为最长公共前后缀，有的称之为最长首尾串。</li>
<li>Next[]数组：Next数组主要用来存放最大公共前后缀的长度值，此值定义为K值，即Next[]数组存储一组k值</li>
</ul>
<p>举例：</p>
<blockquote>
<p>字符串”A”的前缀和后缀都为空，共有元素的长度为0；<br>字符串”AB”的前缀为[A]，后缀为[B]，无共有元素，长度为0；<br>字符串”ABA”的前缀为[A, AB]，后缀为[BA, A]，共有元素”A”,长度1；<br>字符串”ABAB”的前缀为[A, AB, ABA]，后缀为[BAB, AB, B]，共有元素”AB”,长度为2；<br>字符串”ABABA”的前缀为[A, AB, ABA, ABAB]，后缀为[BABA, ABA, BA, A]，共有元素为”ABA”，长度为3；<br>字符串”ABABAA”的前缀为[A, AB, ABA, ABAB, ABABA]，后缀为[BABAA, ABAA, BAA, AA, A]，共有元素为”A”，长度为1；<br>综合以上，由字符串”A”、“AB”、“ABA”、“ABAB”、“ABABA”、“ABABAA”六个字符串组成的Next[]数组的值为：“001231”<br>即Next[]={0,0,1,2,3,1}</p>
</blockquote>
<h3 id="开始匹配"><a href="#开始匹配" class="headerlink" title="开始匹配"></a>开始匹配</h3><p>主串S和模式串T进行匹配时的起始位置：均为0</p>
<p><img src="https://img-blog.csdnimg.cn/20200226182802869.png" alt="img"></p>
<ul>
<li>模式串下一匹配位：定义为k，即下一次匹配时，主串i不变，模式串的新j值为j=k,即S[i]与T[k]进行比较。</li>
<li>K如何取值：k=next[j-1]，为何用next[j-1]标识，之所以这样是为了更好的理解，j-1的含义是当j=5，i=10，T[5]!=S[10]时，需要取模式串”ABABAA”的next[]数组的第j-1=4位的数组值，此时Next[]={0,0,1,2,3,1}”，在此next[]数组中，next[4]=3，即k=3。</li>
<li>注:还可以用另一个方法计算k，模式串j前面（不包括j），即从位置0开始，到4(j-1=4)结束的字符串”ABABA”的最长公共前后缀为”ABA”，它的长度值为3，即k=3，如下图：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200226182846623.png" alt="img"></p>
<ul>
<li><p>模式串T向右滑动的最大距离：定义为m，m=j-k（当j&gt;0时，j为模式串的序号）</p>
</li>
<li><p>字符串模式匹配时存在的两种情况：</p>
<p>1.当模式串j=0时，即T[0]与主串S<a href="https://blog.csdn.net/helloworldchina/article/details/i=0,1..." target="_blank" rel="noopener">i</a>且T[0]!=S[i]时，主串S位置加1，T向右滑动1位，此时j=0，T[0]将与主串S<a href="https://blog.csdn.net/helloworldchina/article/details/i=1,2..." target="_blank" rel="noopener">i</a>继续比较。</p>
<p>2.当模式串j&gt;0时，即T[j]与主串S<a href="https://blog.csdn.net/helloworldchina/article/details/i=1,2..." target="_blank" rel="noopener">i</a>且T[j]!=S[i]时，此时会用到KMP算法。</p>
</li>
</ul>
<h3 id="举例KMP算法"><a href="#举例KMP算法" class="headerlink" title="举例KMP算法"></a>举例KMP算法</h3><p>1.初始时，i =0，j=0；S[0]=”C”，T[0]=”A”，S[i]!=T[j]，匹配失败，此时需要主串S位置加1，模式串T向右移动1位。</p>
<p><img src="https://img-blog.csdnimg.cn/20200226182920291.png" alt="img"></p>
<p>2.当 i =1,2,3,4时，均匹配失败；此时需要主串S位置加1，模式串T向右移动1位。</p>
<p><img src="https://img-blog.csdnimg.cn/2020022618295817.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200226183024963.png" alt="img"></p>
<p>3.当i=5,6,7,8,9，j=0,1,2,3,4时，匹配成功，此时主串S位置加1，模式串T位置加1位。</p>
<p><img src="https://img-blog.csdnimg.cn/20200226183056850.png" alt="img"></p>
<p>4.当i=10，j=5时，匹配失败，S[10]=“F”， T[5]=“A”，S[10]!=T[5]，见下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200226183147546.png" alt="img"></p>
<p>5.在上图，i=10，j=5，接下来继续匹配时，需要主串中S[i]位置不变（i=10），模式串位置变为T[k]，现在需要求k值。根据公式k=next[j-1]，需要取模式串”ABABAA”的next[]数组的第j-1=5-1=4位的数组值，此时Next[]={0,0,1,2,3,1}”，在此next[]数组中，next[4]=3，即k=3（j前面字符串”ABABA”的最长公共前后缀为”ABA”，它的长度值为3，即k=3）；此时，根据KMP算法，i=10不变，模式串T向右滑动m=j-k=5-3=2位，模式串新的j值为j=k=3，见下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200226183225862.png" alt="img"></p>
<p>6.在上图，i=10，j=3，S[i]=S[10]=”F” ，T[j]=T[3]=”B”，S[10]!=T[3]，接下来继续匹配时，需要主串中S[i]位置不变（i=10），模式串位置变为T[k]，现在需要求k值。根据公式k=next[j-1]，需要取模式串”ABABAA”的next[]数组的第j-1=3-1=2位的数组值，此时Next[]={0,0,1,2,3,1}”，在此next[]数组中，next[2]=1，即k=1（j前面字符串”ABA”的最长公共前后缀为”A”，它的长度值为1，即k=1）；此时，根据KMP算法，i=10不变，模式串T向右滑动m=j-k=3-1=2位，模式串新的j值为j=k=1，见下：</p>
<p><img src="https://img-blog.csdnimg.cn/2020022618324744.png" alt="img"></p>
<p>依此类推：接下来，当i=12,13,14,15,16，j=1,2,3,4,5，匹配成功，模式串T在主串中的位置为11。</p>
<p><img src="https://img-blog.csdnimg.cn/20200226183451301.png" alt="img"></p>
<h3 id="C语言版代码"><a href="#C语言版代码" class="headerlink" title="C语言版代码"></a>C语言版代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">char</span> *str)</span>	<span class="comment">//这个函数是用来计算字符串的长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;str[i]!=<span class="string">'\0'</span>;++i)</span><br><span class="line">        ++cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">KMPnext</span><span class="params">(<span class="keyword">char</span> *str)</span>	<span class="comment">//定义kmp算法的next数组生成函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = length(str);</span><br><span class="line">    <span class="keyword">int</span> *next = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*len);</span><br><span class="line">    <span class="built_in">memset</span>(next,<span class="number">0</span>,<span class="keyword">sizeof</span>(next));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,k=<span class="number">0</span>;j &lt; len;++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; str[j] != str[k])</span><br><span class="line">            k = next[k<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(str[k] == str[j])</span><br><span class="line">            ++k;</span><br><span class="line">        next[j] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">char</span> *s,<span class="keyword">char</span> *t,<span class="keyword">int</span> *next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//s为主串，t为模式串</span></span><br><span class="line">    <span class="keyword">int</span> s_len = length(s);</span><br><span class="line">    <span class="keyword">int</span> t_len = length(t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>; i &lt;s_len;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != t[j])</span><br><span class="line">            j = next[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == t[j])</span><br><span class="line">            ++j;</span><br><span class="line">        <span class="keyword">if</span>(j==t_len)</span><br><span class="line">            <span class="keyword">return</span> i-j+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">30</span>] = <span class="string">"CDFGFABABAFABABAAAQWEDC"</span>;</span><br><span class="line">    <span class="keyword">char</span> t[<span class="number">10</span>] = <span class="string">"ABABAA"</span>;</span><br><span class="line">    <span class="keyword">int</span> local;</span><br><span class="line">    <span class="keyword">int</span> *next;</span><br><span class="line">    next = KMPnext(t);  <span class="comment">//将模式串传入函数求得next数组</span></span><br><span class="line">    local = KMP(s,t,next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,length(s));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"next数组："</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length(t);++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>,next[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n匹配的位置是：%d"</span>,local);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Python版代码"><a href="#Python版代码" class="headerlink" title="Python版代码"></a>Python版代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#python版KMP算法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">KMP_next</span><span class="params">(str: str)</span>-&gt;[int]:</span>          <span class="comment">#定义next数组</span></span><br><span class="line">    next = [<span class="number">0</span>] * len(str)</span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(str)):</span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> str[j] != str[k]:</span><br><span class="line">            k = next[k<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> str[j] == str[k]:</span><br><span class="line">            k+=<span class="number">1</span></span><br><span class="line">        next[j] = k</span><br><span class="line">    <span class="keyword">return</span> next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">KMP</span><span class="params">(s : str, t : str,next : [int])</span> -&gt; int:</span></span><br><span class="line">    <span class="comment">#s为主串,t为模式串,next为数组</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(s)):</span><br><span class="line">        <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> s[i] != t[j]:</span><br><span class="line">            j = next[j <span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> s[i] == t[j]:</span><br><span class="line">            j = j+ <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j == len(t):</span><br><span class="line">            <span class="keyword">return</span> i-j+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    s = <span class="string">"CDFGFABABAFABABAAAQWEDC"</span></span><br><span class="line">    t = <span class="string">"ABABADA"</span></span><br><span class="line">    next = KMP_next(t)</span><br><span class="line">    print(<span class="string">'NEXT数组：'</span>,next)</span><br><span class="line">    ans = KMP(s,t,next)</span><br><span class="line">    <span class="keyword">if</span> ans != <span class="number">-1</span>:</span><br><span class="line">        print(<span class="string">'匹配到模式串的位置为：'</span>,ans) </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'未匹配到模式串'</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>python</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>初入密码学之置换加密与暴力破解</title>
    <url>/posts/19315.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：此为学习现代密码学的一次作业，能进行不是较大文本量的txt文本周期性置换加密，并进行密文的暴力破解。</p>
<a id="more"></a>

<h2 id="文件解释"><a href="#文件解释" class="headerlink" title="文件解释"></a>文件解释</h2><p>1.将文件放在同一个python文件夹下使用</p>
<p>2.encryption.py为加密程序，decrypt为暴力破解程序</p>
<p>3.plain.txt为初始待加密文本，cipher.txt为加密后生成的文本，DecryptWoed.txt为暴力破解后生成的文本。</p>
<p>4.若要运行可删除 (3)中的三个文本重新运行。</p>
<h2 id="加密程序运行解释"><a href="#加密程序运行解释" class="headerlink" title="加密程序运行解释"></a>加密程序运行解释</h2><p>1.首先输入置换加密密钥的位数。</p>
<p>2.输入置换加密的密钥。若加密密钥为(1 5 6 2 3 )则将其代换后输入 531462</p>
<p>3.将待加密文本重命名为plain.txt</p>
<p>4.等待加密后生成cipher.txt</p>
<h2 id="解密程序运行解释"><a href="#解密程序运行解释" class="headerlink" title="解密程序运行解释"></a>解密程序运行解释</h2><p>1.输入密钥长度即可进行暴力破解</p>
<p>2.采用的是深度搜索来遍历密钥的所有可能。</p>
<p>3.等待解密后生成DecryptWoed.txt。</p>
<p>4.其中所以可能会在DecryptWoed.txt以回车进行分隔。</p>
<h2 id="加密程序"><a href="#加密程序" class="headerlink" title="加密程序"></a>加密程序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#将txt文本存入word1</span></span><br><span class="line">    file = open(<span class="string">'plain.txt'</span>,<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    word1 = file.read()</span><br><span class="line">    file.close</span><br><span class="line">    <span class="comment">#将txt文本转换只剩下英文单词</span></span><br><span class="line">    word=<span class="string">''</span></span><br><span class="line">    word2 = re.findall(<span class="string">'[a-zA-Z]+'</span>, word1)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> word2:</span><br><span class="line">        word = word + i</span><br><span class="line">    <span class="keyword">return</span> word</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encryption</span><span class="params">(wordlist,deltalist)</span>:</span></span><br><span class="line">    <span class="comment">#进行置换加密</span></span><br><span class="line">    NewWordlist = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> wordlist:</span><br><span class="line">        con = <span class="string">''</span></span><br><span class="line">        str = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> deltalist:</span><br><span class="line">            con = con + str[ j <span class="number">-1</span> ]</span><br><span class="line">        NewWordlist.append(con)</span><br><span class="line">    <span class="keyword">return</span> NewWordlist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(word)</span>:</span></span><br><span class="line">    file2 = open(<span class="string">'cipher.txt'</span>,<span class="string">'a'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> word:</span><br><span class="line">        file2.write(i)</span><br><span class="line"></span><br><span class="line">    file2.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    deltasize = int(input(<span class="string">"请输入您的密钥位数："</span>))</span><br><span class="line">    delta = input(<span class="string">"请输入您的密钥："</span>)</span><br><span class="line">    deltalist=[]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> delta:</span><br><span class="line">        deltalist.append(int(j))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#将word存入wordlist列表中</span></span><br><span class="line">    word = translate()</span><br><span class="line">    wordlist = []</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    str = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> word :</span><br><span class="line">        <span class="keyword">if</span>(j &lt; deltasize):</span><br><span class="line">            str = str +i</span><br><span class="line">            j=j+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(j == deltasize ):</span><br><span class="line">            wordlist.append(str)</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            str = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> wordlist:</span><br><span class="line">        str = i</span><br><span class="line">        print(str)</span><br><span class="line">    NewWordlist = []</span><br><span class="line">    NewWordlist = encryption(wordlist,deltalist)</span><br><span class="line">    <span class="comment">#用save函数存入cipher.txt中</span></span><br><span class="line">    save(NewWordlist)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

<h2 id="暴力破解代码"><a href="#暴力破解代码" class="headerlink" title="暴力破解代码"></a>暴力破解代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def save(word):</span><br><span class="line">    #存储</span><br><span class="line">    file2 = open(&apos;DecryptWoed.txt&apos;,&apos;a&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">    for i in word:</span><br><span class="line">        file2.write(i)</span><br><span class="line">    file2.write((&quot;\n&quot;))</span><br><span class="line">    file2.close()</span><br><span class="line"></span><br><span class="line">def decrypt(wordlist,deltalist):</span><br><span class="line">    #进行置换解密</span><br><span class="line">    NewWordlist = []</span><br><span class="line">    for i in wordlist:</span><br><span class="line">        con = &apos;&apos;</span><br><span class="line">        str = i</span><br><span class="line">        for j in deltalist:</span><br><span class="line">            con = con + str[ j -1 ]</span><br><span class="line">        NewWordlist.append(con)</span><br><span class="line">    return NewWordlist</span><br><span class="line"></span><br><span class="line">def DFS(p,delta,token,newdelta,wordlist):</span><br><span class="line">    #深度搜索密钥的所以可能性</span><br><span class="line">    if p == len(delta):</span><br><span class="line">        print(newdelta)</span><br><span class="line">        save(decrypt(wordlist,newdelta))</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for index in range(len(delta)):</span><br><span class="line">        if token[index] == True:</span><br><span class="line">            newdelta[p] = delta[index]</span><br><span class="line">            token[index] = False</span><br><span class="line">            DFS(p+1,delta,token,newdelta,wordlist)</span><br><span class="line">            token[index] = True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    deltasize = int(input(&quot;输入密钥位数：&quot;))</span><br><span class="line">    delta =[]</span><br><span class="line">    for i in range(1, deltasize + 1):</span><br><span class="line">        delta.append(i)</span><br><span class="line">    token = [True for i in range(len(delta))]   #用来深度搜索判断</span><br><span class="line">    newdelta = [&apos;&apos; for i in range(0, len(delta))]  #引用来存储一次深度优先后的结果</span><br><span class="line">    file = open(&apos;cipher.txt&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">    word = file.read()</span><br><span class="line">    #将word存入wordlist列表中</span><br><span class="line">    wordlist = []</span><br><span class="line">    j = 0</span><br><span class="line">    str = &apos;&apos;</span><br><span class="line">    for i in word :</span><br><span class="line">        if(j &lt; deltasize):</span><br><span class="line">            str = str +i</span><br><span class="line">            j=j+1</span><br><span class="line">        if(j == deltasize ):</span><br><span class="line">            wordlist.append(str)</span><br><span class="line">            j = 0</span><br><span class="line">            str = &apos;&apos;</span><br><span class="line"></span><br><span class="line">    DFS(0,delta,token,newdelta,wordlist)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>现代密码学</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>现代密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统——几种常见的调度算法</title>
    <url>/posts/os-1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：总结一下在操作系统学习中遇到的几种常见的调度算法，以供参考。</p>
<a id="more"></a>

<h2 id="处理机调度相关基本概念"><a href="#处理机调度相关基本概念" class="headerlink" title="处理机调度相关基本概念"></a>处理机调度相关基本概念</h2><h3 id="调度方式和调度算法的若干准则"><a href="#调度方式和调度算法的若干准则" class="headerlink" title="调度方式和调度算法的若干准则"></a>调度方式和调度算法的若干准则</h3><p>1.面向用户的准则：周转时间短（CPU执行用时Ts、周转时间T=Ts+Tw、带权周转时间W= T/Ts）、响应时间快、均衡性、截止时间的保证、优先权准则。</p>
<p>2.面向系统的准则：系统吞吐量高、处理机利用率好、各类资源的平衡利用</p>
<p>3.批处理系统为照顾为数众多的短作业，应采用短作业优先的调度算法；分时系统为保证系统具有合理的响应时间，应采用轮转法进行调度</p>
<h2 id="常用调度算法"><a href="#常用调度算法" class="headerlink" title="常用调度算法"></a>常用调度算法</h2><h3 id="先来先服务调度算法FCFS"><a href="#先来先服务调度算法FCFS" class="headerlink" title="先来先服务调度算法FCFS"></a><strong>先来先服务调度算法FCFS</strong></h3><p>1.按照作业提交，或进程变为就绪状态的先后次序分派CPU。</p>
<p>2.新作业只有当当前作业或进程执行完或阻塞才获得CPU运行。</p>
<p>3.被唤醒的作业或进程不立即恢复执行，通常等到当前作业或进程出让CPU（所以，默认即是非抢占方式）。</p>
<p>4.有利于CPU繁忙型的作业，而不利于I/O繁忙的作业（进程）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/operating_system/FCFS.png" alt></p>
<h3 id="短作业（进程）优先调度算法SJF（非抢占）-SPF（抢占）"><a href="#短作业（进程）优先调度算法SJF（非抢占）-SPF（抢占）" class="headerlink" title="短作业（进程）优先调度算法SJF（非抢占）/SPF（抢占）"></a><strong>短作业（进程）优先调度算法SJF（非抢占）/SPF（抢占）</strong></h3><p>1.平均周转时间、平均带权周转时间都有明显改善。SJF/SPF调度算法能有效的降低作业的平均等待时间，提高系统吞吐量。</p>
<p>2.未考虑作业的紧迫程度，因而不能保证紧迫性作业（进程）的及时处理、对长作业的不利、作业（进程）的长短含主观因素，不一定能真正做到短作业优先。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/operating_system/SJF_SPF.png" alt></p>
<h3 id="高优先权优先调度算法HPF"><a href="#高优先权优先调度算法HPF" class="headerlink" title="高优先权优先调度算法HPF"></a>高优先权优先调度算法HPF</h3><p>1.<strong>两种方式</strong>：非抢占式优先权算法、抢占式优先权算法（关键点：新作业产生时）<br>2.<strong>类型</strong>:静态优先权：创建进程时确定，整个运行期间保持不变。动态优先权：创建进程时赋予的优先权可随进程的推进或随其等待时间的增加而改变。</p>
<p>最具有代表性的就是<strong>高响应比优先调度算法HRRN</strong>：</p>
<p>HRRN为每个作业引入动态优先权，使作业的优先级随着等待时间的增加而以速率a提高：优先权 =（等待时间+要求服务时间)/要求服务时间= 响应时间 / 要求服务时间。<br>什么时候计算各进程的响应比优先权？（作业完成时、新作业产生时（抢占、非抢占）、时间片完成时、进程阻塞时）</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/operating_system/HRNN.png" alt></p>
<h3 id="基于时间片的轮转调度算法RR"><a href="#基于时间片的轮转调度算法RR" class="headerlink" title="基于时间片的轮转调度算法RR"></a><strong>基于时间片的轮转调度算法RR</strong></h3><h3 id="时间片轮转算法"><a href="#时间片轮转算法" class="headerlink" title="时间片轮转算法"></a>时间片轮转算法</h3><p>过程：</p>
<p>1.排成一个队列。</p>
<p>2.每次调度时将CPU分派给队首进程。</p>
<p>3.时间片结束时，发生时钟中断。</p>
<p>4.暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前就绪的队首进程。<br>说明：</p>
<p>1.进程阻塞情况发生时，未用完时间片也要出让CPU。</p>
<p>2.能够及时响应，但没有考虑作业长短等问题。</p>
<p>3.系统的处理能力和系统的负载状态影响时间片长度。</p>
<h3 id="多级反馈队列算法FB"><a href="#多级反馈队列算法FB" class="headerlink" title="多级反馈队列算法FB"></a><strong>多级反馈队列算法FB</strong></h3><p>过程：</p>
<p>1.准备调度：先将它放入第一个队列的末尾，按FCFS原则排队等待调度。</p>
<p>2.IF时间片内完成，便可准备撤离系统。</p>
<p>3.IF时间片内未能完成，调度程序便将该进程转入第二队列的末尾等待再次被调度执行。</p>
<p>4.当第一队列中的进程都执行完，系统再按FCFS原则调度第二队列。在第二队列的稍放长些的时间片内仍未完成，再依次将它放入第三队列。</p>
<p>5.依次降到第n队列后，在第n队列中便采取按时间片轮转的方式运行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/operating_system/FB.png" alt></p>
<p>说明:</p>
<p>1.设置多个就绪队列，各队列有不同的优先级,优先级从第一个队列依次降低。</p>
<p>2.赋予各队列进程执行时间片大小不同, 优先权越高，时间片越短。</p>
<p>3.仅当优先权高的队列（如第一队列）空闲时，调度程序才调度第二队列中的进程运行。</p>
<p>4.高优先级抢占时，被抢占的进程放回原就绪队列末尾。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://cdn.jsdelivr.net/gh/hongcyu/image/operating_system/summary.png" alt></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>调度算法</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统——缺页中断及页面置换算法</title>
    <url>/posts/os-2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：在这里将缺页中断进行简单的描述和页面置换算法的题目进行分析和记录，以供参考。</p>
<a id="more"></a>

<h2 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a><strong>缺页中断</strong></h2><p>​        在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。<br>　　缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤： </p>
<ol>
<li><p>保护CPU现场 </p>
</li>
<li><p>分析中断原因 </p>
</li>
<li><p>转入缺页中断处理程序进行处理 </p>
</li>
<li><p>恢复CPU现场，继续执行</p>
<p>但是缺页中断时由于所要访问的页面不存在与内存时，有硬件所产生的一种特殊的中断，因此，</p>
</li>
</ol>
<p>　　<div class="note warning">与一般的中断存在<strong>区别</strong>:</div></p>
<ol start="5">
<li><p>在指令执行期间产生和处理缺页中断信号 </p>
</li>
<li><p>一条指令在执行期间，可能产生多次缺页中断 </p>
</li>
<li><p>缺页中断返回时，执行产生中断的那一条指令，而一般的中断返回时，执行下一条指令</p>
</li>
</ol>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a><strong>页面置换算法</strong></h2><h3 id="最佳置换算法（Optimal-OPT）"><a href="#最佳置换算法（Optimal-OPT）" class="headerlink" title="最佳置换算法（Optimal,OPT）"></a>最佳置换算法（Optimal,OPT）</h3><ol>
<li><p>基本思想</p>
<p>​        置换以后不再访问，或者在将来最迟才会被访问的页面，缺页中断率最低。但是该算法需要依据以后各页的使用情况，而当一个进程还未完成的时候，很难估计哪个页面是以后不再使用或者最长时间以后才会用到的页面。所以该算法是不能实现的。但还算法任然具有意义，作为衡量其他算法优劣的一个标准。</p>
</li>
<li><p>算例</p>
<p>​        采用固定分配局部置换的策略，嘉定系统为某进程在内存中分配了3个物理块，页面访问顺序为2、3、2、1、5、2、4、5、3、2、5、2。假定系统未采用<strong>预调页策略</strong>，即未事先调入任何页面。进程运行时，一次将2、3、1三个页面调入内存，发生3次缺页中断。当第一次访问页面5时，产生第4次缺页中断，根据OPT算法，淘汰页面1，因为它在以后不会在使用了；第5次缺页中断时，淘汰页面2，因为它在5、3、2三个页面中，是在将来最迟才会被页面访问的页面。以此类推：<br>　　注意：第4次中断时将最后不会访问的1剔除，将最后才访问的3放入最下面的内存块中，以后的调度过程中，最后不会访问或最后才被访问的页面总是放在最下面的内存块中。内存块从上到下依次存放最先访问的页面。<br>　　中断次数为6，缺页中断率为6/12*100% = 50%。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">P:</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">5</th>
<th align="center">2</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">5</th>
<th align="center">2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">M=3</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">F=6</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center"></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center"></td>
<td align="center">Y</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">Y</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="先进先出置换算法（First-In-First-Out-FIFO"><a href="#先进先出置换算法（First-In-First-Out-FIFO" class="headerlink" title="先进先出置换算法（First In First Out, FIFO)"></a>先进先出置换算法（First In First Out, FIFO)</h3><ol>
<li><p>基本思想</p>
<p>​        置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成<strong>队列</strong>，从队尾进入，从队首删除。但是该算法会淘汰经常访问的页面，不适应进程实际运行的规律，目前已经<strong>很少使用</strong>。</p>
</li>
<li><p>算例</p>
<p>​        中断次数为6，缺页中断率为9/12*100% = 75%。</p>
<table>
<thead>
<tr>
<th align="center">P:</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">5</th>
<th align="center">2</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">5</th>
<th align="center">2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">M=3</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">5</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">F=9</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center"></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center"></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center"></td>
<td align="center">Y</td>
</tr>
</tbody></table>
</li>
<li><p>Belady异常</p>
<p>​        一般来说，分配给进程的物理块越多，运行时的缺页次数应该越少，使用FIFO时，可能存在相反情况，分配4个物理块的缺页竟然比3个物理块的缺页次数还多！<br>​        例如：进程访问顺序为0、2、1、3、0、2、4、0、2、1、3、4。 </p>
<p>M=3时，缺页中断9次。缺页中断率9/12*100% = 75%。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">P:</th>
<th align="center">0</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">3</th>
<th align="center">0</th>
<th align="center">2</th>
<th align="center">4</th>
<th align="center">0</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">3</th>
<th align="center">4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">M=3</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">F=9</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>​        Ｍ=4时，缺页中断10次。缺页中断率10/12*100% = 83.3%。</p>
<table>
<thead>
<tr>
<th align="center">P:</th>
<th align="center">0</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">3</th>
<th align="center">0</th>
<th align="center">2</th>
<th align="center">4</th>
<th align="center">0</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">3</th>
<th align="center">4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">M=4</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">F=10</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
</tr>
</tbody></table>
<h3 id="最近最久未使用置换算法（Least-Recently-Used，-LRU）"><a href="#最近最久未使用置换算法（Least-Recently-Used，-LRU）" class="headerlink" title="最近最久未使用置换算法（Least Recently Used， LRU）"></a>最近最久未使用置换算法（Least Recently Used， LRU）</h3><ol>
<li><p>基本思想</p>
<p>​        置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。<br>　　LRU算法普偏地适用于各种类型的程序，但是系统要时时刻刻对各页的访问历史情况加以记录和更新，开销太大，因此LRU算法必须要有硬件的支持。</p>
</li>
<li><p>算例</p>
<p>​        仍然以OPT算例为例子。<br>　　中断次数为6，缺页中断率为7/12*100% = 58.3%。</p>
<table>
<thead>
<tr>
<th align="center">P:</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">5</th>
<th align="center">2</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">5</th>
<th align="center">2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">M=3</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">4</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">F=7</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center"></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center"></td>
<td align="center">Y</td>
<td align="center"></td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>中断</tag>
        <tag>页面置换算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——单链表</title>
    <url>/posts/50394.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：单链表的基本操作，由于太久没有复习数据结构了，导致该忘的都忘了，所以在这里记录重新学习数据结构的笔记，以备以后查看。</p>
<a id="more"></a>

<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>链表是一种链式存取的数据结构，用一组地址任意的<a href="https://baike.baidu.com/item/存储单元/8727749" target="_blank" rel="noopener">存储单元</a>存放线性表中的<a href="https://baike.baidu.com/item/数据元素/715313" target="_blank" rel="noopener">数据元素</a>。链表中的数据是以结点来表示的，每个结点的构成：元素(<a href="https://baike.baidu.com/item/数据元素/715313" target="_blank" rel="noopener">数据元素</a>的映象) + <a href="https://baike.baidu.com/item/指针/2878304" target="_blank" rel="noopener">指针</a>(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。</p>
<h3 id="单链表节点定义"><a href="#单链表节点定义" class="headerlink" title="单链表节点定义"></a>单链表节点定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode;</span><br></pre></td></tr></table></figure>

<p>此处定义了一个单链表的结构体，里面包含数据以及下一个数据的单链表指针。</p>
<h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">create_LNode</span><span class="params">(ElemType data)</span></span>&#123;</span><br><span class="line">    LNode *ret = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    ret-&gt;data = data; <span class="comment">//C中将NULL作为空指针之用，C++用nullptr</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处可以直接传入数据进行创建节点，当创建头节点时可以用NULL进行数据传入；</p>
<h3 id="头插法创建单链表"><a href="#头插法创建单链表" class="headerlink" title="头插法创建单链表"></a>头插法创建单链表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_link_head</span><span class="params">(LNode *L,ElemType data[],<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">//传入头结点，数组，数组元素的个数</span></span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        p = create_LNode(data[i]);</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200616173642497.png" alt="image-20200616173642497"></p>
<p>tips：</p>
<p>因为是头插法，所以插入后的顺序是数组的倒序。</p>
<h3 id="尾插法创建单链表"><a href="#尾插法创建单链表" class="headerlink" title="尾插法创建单链表"></a>尾插法创建单链表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_link_tail</span><span class="params">(LNode *L,ElemType data[],<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">//n为插入的个数</span></span><br><span class="line">    LNode *p,*q;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;data = <span class="literal">NULL</span>;         <span class="comment">//申请L为头节点</span></span><br><span class="line">    q = L;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; n ;i++)&#123;</span><br><span class="line">        p = create_LNode(data[i]);</span><br><span class="line">        q -&gt;next = p;</span><br><span class="line">        q = q-&gt;next;    <span class="comment">//p = q;</span></span><br><span class="line">    &#125;</span><br><span class="line">    q -&gt;next = <span class="literal">NULL</span>;    <span class="comment">//将最后一个节点指为NULL</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取链表的长度"><a href="#获取链表的长度" class="headerlink" title="获取链表的长度"></a>获取链表的长度</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_length</span><span class="params">(LNode *L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">while</span>(L-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        ret++;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取链表中指定位置的节点指针"><a href="#获取链表中指定位置的节点指针" class="headerlink" title="获取链表中指定位置的节点指针"></a>获取链表中指定位置的节点指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">get_node</span><span class="params">(LNode *L,<span class="keyword">int</span> p)</span></span>&#123; <span class="comment">//p的范围是（1~N）不包含头结点</span></span><br><span class="line">    LNode* ret;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ret = L-&gt;next;</span></span><br><span class="line">    ret = L;</span><br><span class="line">    <span class="keyword">while</span>( ret != <span class="literal">NULL</span> &amp;&amp; count&lt; p)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        ret = ret-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取单链表中data值第一次出现的节点指针"><a href="#获取单链表中data值第一次出现的节点指针" class="headerlink" title="获取单链表中data值第一次出现的节点指针"></a>获取单链表中data值第一次出现的节点指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">get_first_elem_node</span><span class="params">(LNode *L,ElemType data)</span></span>&#123;</span><br><span class="line">    LNode* ret = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(ret != <span class="literal">NULL</span> &amp;&amp; ret-&gt;data != data)&#123;</span><br><span class="line">        ret = ret-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在指定的节点后插入节点"><a href="#在指定的节点后插入节点" class="headerlink" title="在指定的节点后插入节点"></a>在指定的节点后插入节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert_elem</span><span class="params">(LNode *L,<span class="keyword">int</span> p,ElemType data)</span></span>&#123;</span><br><span class="line">    LNode *m = <span class="literal">NULL</span>;</span><br><span class="line">    LNode *n = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;<span class="number">0</span> || L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    m = get_node(L,p);</span><br><span class="line">    n = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    n-&gt;next = m-&gt;next;</span><br><span class="line">    n-&gt;data = data;</span><br><span class="line">    m-&gt;next = n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>删除某个下标的节点,并返回被删除的节点的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">delete_node</span><span class="params">(LNode *L,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    LNode *ret = <span class="literal">NULL</span>;</span><br><span class="line">    LNode *m = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; <span class="number">1</span> || get_length(L)==<span class="number">0</span> ) <span class="comment">//当删除的节点位置小于1或者长度为0时</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    m = get_node(L,p<span class="number">-1</span>);</span><br><span class="line">    ret = m-&gt;next;</span><br><span class="line">    m-&gt;next = m-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并表"><a href="#合并表" class="headerlink" title="合并表"></a>合并表</h3><p>合并两个元素递增的单链表到一个新的单链表且依然有序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LNode* <span class="title">merge_link</span><span class="params">(LNode* A,LNode* B,LNode* C)</span></span>&#123;</span><br><span class="line">    LNode *p = A-&gt;next;</span><br><span class="line">    LNode *q = B-&gt;next;</span><br><span class="line">    LNode *r;</span><br><span class="line">    C = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    C-&gt;data=<span class="literal">NULL</span>;</span><br><span class="line">    r = C;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&lt;=q-&gt;data)&#123;</span><br><span class="line">            r-&gt;next=p;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            r-&gt;next = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面的操作是另一个不为空的表剩下都归并到新的表的后面</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        r-&gt;next = q;</span><br><span class="line">    <span class="keyword">if</span>(q==<span class="literal">NULL</span>)</span><br><span class="line">        r-&gt;next = p;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打印单链表"><a href="#打印单链表" class="headerlink" title="打印单链表"></a>打印单链表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void print_link(LNode *L)&#123;</span><br><span class="line">    while(L-&gt;next)&#123;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        printf(&quot;%3d&quot;,L-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整的函数（包含测试部分）"><a href="#完整的函数（包含测试部分）" class="headerlink" title="完整的函数（包含测试部分）"></a>完整的函数（包含测试部分）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化节点</span></span><br><span class="line"><span class="function">LNode *<span class="title">create_LNode</span><span class="params">(ElemType data)</span></span>&#123;</span><br><span class="line">    LNode *ret = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    ret-&gt;data = data; <span class="comment">//C中将NULL作为空指针之用，C++用nullptr</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法建立单链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_link_tail</span><span class="params">(LNode *L,ElemType data[],<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">//n为插入的个数</span></span><br><span class="line">    LNode *p,*q;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;data = <span class="literal">NULL</span>;         <span class="comment">//申请L为头节点</span></span><br><span class="line">    q = L;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; n ;i++)&#123;</span><br><span class="line">        p = create_LNode(data[i]);</span><br><span class="line">        q -&gt;next = p;</span><br><span class="line">        q = q-&gt;next;    <span class="comment">//p = q;</span></span><br><span class="line">    &#125;</span><br><span class="line">    q -&gt;next = <span class="literal">NULL</span>;    <span class="comment">//将最后一个节点指为NULL</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头插法建立单链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_link_head</span><span class="params">(LNode *L,ElemType data[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    L = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    L-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        p = create_LNode(data[i]);</span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取单链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_length</span><span class="params">(LNode *L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">while</span>(L-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        ret++;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取链表中指定位置的节点指针</span></span><br><span class="line"><span class="function">LNode *<span class="title">get_node</span><span class="params">(LNode *L,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    LNode* ret;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ret = L-&gt;next;</span></span><br><span class="line">    ret = L;</span><br><span class="line">    <span class="keyword">while</span>( ret != <span class="literal">NULL</span> &amp;&amp; count&lt; p)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        ret = ret-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取单链表中data值第一次出现的节点指针</span></span><br><span class="line"><span class="function">LNode *<span class="title">get_first_elem_node</span><span class="params">(LNode *L,ElemType data)</span></span>&#123;</span><br><span class="line">    LNode* ret = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(ret != <span class="literal">NULL</span> &amp;&amp; ret-&gt;data != data)&#123;</span><br><span class="line">        ret = ret-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在指定的节点后插入节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert_elem</span><span class="params">(LNode *L,<span class="keyword">int</span> p,ElemType data)</span></span>&#123;</span><br><span class="line">    LNode *m = <span class="literal">NULL</span>;</span><br><span class="line">    LNode *n = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;<span class="number">0</span> || L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    m = get_node(L,p);</span><br><span class="line">    n = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    n-&gt;next = m-&gt;next;</span><br><span class="line">    n-&gt;data = data;</span><br><span class="line">    m-&gt;next = n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除某个下标的节点,并返回被删除的节点</span></span><br><span class="line"><span class="function">LNode *<span class="title">delete_node</span><span class="params">(LNode *L,<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    LNode *ret = <span class="literal">NULL</span>;</span><br><span class="line">    LNode *m = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; <span class="number">1</span> || get_length(L)==<span class="number">0</span> ) <span class="comment">//当删除的节点位置小于1或者长度为0时</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    m = get_node(L,p<span class="number">-1</span>);</span><br><span class="line">    ret = m-&gt;next;</span><br><span class="line">    m-&gt;next = m-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并两个元素递增的单链表到一个新的单链表且依然有序</span></span><br><span class="line"><span class="function">LNode* <span class="title">merge_link</span><span class="params">(LNode* A,LNode* B,LNode* C)</span></span>&#123;</span><br><span class="line">    LNode *p = A-&gt;next;</span><br><span class="line">    LNode *q = B-&gt;next;</span><br><span class="line">    LNode *r;</span><br><span class="line">    C = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    C-&gt;data=<span class="literal">NULL</span>;</span><br><span class="line">    r = C;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; q!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data&lt;=q-&gt;data)&#123;</span><br><span class="line">            r-&gt;next=p;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            r=r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            r-&gt;next = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        r-&gt;next = q;</span><br><span class="line">    <span class="keyword">if</span>(q==<span class="literal">NULL</span>)</span><br><span class="line">        r-&gt;next = p;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印单链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_link</span><span class="params">(LNode *L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(L-&gt;next)&#123;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,L-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *A,*B,*C;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    LNode* LOCAL;</span><br><span class="line">    <span class="keyword">int</span> data1[<span class="number">5</span>]=&#123;<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> data2[<span class="number">7</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>&#125;;</span><br><span class="line">    A = create_link_head(A,data1,<span class="number">5</span>);</span><br><span class="line">    B = create_link_tail(B,data2,<span class="number">7</span>);</span><br><span class="line">    print_link(A);</span><br><span class="line">    print_link(B);</span><br><span class="line"></span><br><span class="line">    i = get_length(A);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nA的长度为:%d\n\n"</span>,i);</span><br><span class="line"></span><br><span class="line">    LOCAL = get_first_elem_node(A,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"A的第一次出现元素3的指针为：%d\n"</span>,LOCAL);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"验证LOCAL的data为：%d\n\n"</span>,LOCAL-&gt;data);</span><br><span class="line"></span><br><span class="line">    LOCAL = <span class="literal">NULL</span>;</span><br><span class="line">    LOCAL = get_node(A,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"A的第2位的指针为：%d\n"</span>,LOCAL);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"验证LOCAL的data为：%d\n\n"</span>,LOCAL-&gt;data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在指定的节点后插入节点</span></span><br><span class="line">    insert_elem(B,<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">    print_link(B);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    LOCAL = <span class="literal">NULL</span>;</span><br><span class="line">    LOCAL= delete_node(B,<span class="number">3</span>);</span><br><span class="line">    print_link(B);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"验证被删除的LOCAL-&gt;data为：%d\n\n"</span>,LOCAL-&gt;data);</span><br><span class="line">    <span class="comment">//合并两个单链表</span></span><br><span class="line">    C=merge_link(A,B,C);</span><br><span class="line">    print_link(C);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tips:</p>
<blockquote>
<p>在函数中创建的节点要传出才能使用噢</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>单链表</tag>
        <tag>表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——双链表和循环链表</title>
    <url>/posts/60331.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：由于太久没有复习数据结构了，导致该忘的都忘了，所以在这里记录重新学习数据结构的笔记，以备以后查看。</p>
<a id="more"></a>

<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>双向链表也叫<a href="https://baike.baidu.com/item/双链表/5827945" target="_blank" rel="noopener">双链表</a>，是链表的一种，它的每个数据结点中都有两个<a href="https://baike.baidu.com/item/指针/2878304" target="_blank" rel="noopener">指针</a>，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向<a href="https://baike.baidu.com/item/循环链表/3228465" target="_blank" rel="noopener">循环链表</a>。</p>
<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span> *<span class="title">prior</span>;</span>   <span class="comment">//指向前驱的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span> *<span class="title">next</span>;</span>    <span class="comment">//指向后继的指针</span></span><br><span class="line">&#125;DLNode;</span><br></pre></td></tr></table></figure>

<p>与单链表的区别就是定义了一个指向前驱的指针。</p>
<h3 id="初始化结点"><a href="#初始化结点" class="headerlink" title="初始化结点"></a>初始化结点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DLNode *<span class="title">create_node</span><span class="params">(ElemType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLNode *ret = (DLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">    ret-&gt;data = data;</span><br><span class="line">    ret-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    ret-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="尾插法创建双链表"><a href="#尾插法创建双链表" class="headerlink" title="尾插法创建双链表"></a>尾插法创建双链表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DLNode *<span class="title">create_link_tail</span><span class="params">(DLNode *L,ElemType data[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLNode *s,*r;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    L = create_node(<span class="literal">NULL</span>);</span><br><span class="line">    r = L;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n ; i++)&#123;</span><br><span class="line">        s = create_node(data[i]);</span><br><span class="line">        s-&gt;prior = r;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找结点某个位置的指针"><a href="#查找结点某个位置的指针" class="headerlink" title="查找结点某个位置的指针"></a>查找结点某个位置的指针</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找某个位置的结点的指针</span></span><br><span class="line"><span class="function">DLNode *<span class="title">find_elem_node</span><span class="params">(DLNode *L,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,count = <span class="number">0</span>;</span><br><span class="line">    DLNode *ret = L-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;<span class="number">0</span> || p &gt; link_length(L))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt; p ; i++)&#123;</span><br><span class="line">        ret = ret-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">//这样写如果未找到也会返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在某个结点后面插入结点"><a href="#在某个结点后面插入结点" class="headerlink" title="在某个结点后面插入结点"></a>在某个结点后面插入结点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//在某个结点后面插入结点</span><br><span class="line">int insert_elem(DLNode *L,ElemType data,int index)</span><br><span class="line">&#123;</span><br><span class="line">    DLNode *s,*p;</span><br><span class="line">    if(index &lt; 0|| index&gt;link_length(L))</span><br><span class="line">        return 0;</span><br><span class="line">    p = find_elem_node(L,index);</span><br><span class="line">    s = create_node(data);</span><br><span class="line">    if(index != link_length(L))&#123;</span><br><span class="line">        s-&gt;next = p-&gt;next;</span><br><span class="line">        s-&gt;prior = p;</span><br><span class="line">        p-&gt;next = s;</span><br><span class="line">        s-&gt;next-&gt;prior = s;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        p-&gt;next = s;</span><br><span class="line">        s-&gt;prior=p;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处记得判断是否是最后一个结点插入。</p>
<h3 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除某个结点并返回</span></span><br><span class="line"><span class="function">DLNode *<span class="title">delete_node</span><span class="params">(DLNode *L,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLNode *ret;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span>|| index&gt;link_length(L))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ret = find_elem_node(L,index);</span><br><span class="line">    <span class="keyword">if</span>(index != link_length(L))&#123;</span><br><span class="line">        ret-&gt;next-&gt;prior = ret-&gt;prior;</span><br><span class="line">        ret-&gt;prior-&gt;next = ret-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ret-&gt;prior-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取链表长度"><a href="#获取链表长度" class="headerlink" title="获取链表长度"></a>获取链表长度</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link_length</span><span class="params">(DLNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(L-&gt;next)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        L = L -&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打印双链表"><a href="#打印双链表" class="headerlink" title="打印双链表"></a>打印双链表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf_link</span><span class="params">(DLNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(L-&gt;next)&#123;</span><br><span class="line">        L = L -&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,L-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整函数（包含测试）"><a href="#完整函数（包含测试）" class="headerlink" title="完整函数（包含测试）"></a>完整函数（包含测试）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="comment">//定义双链表的节点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span> *<span class="title">prior</span>;</span>   <span class="comment">//指向前驱的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span> *<span class="title">next</span>;</span>    <span class="comment">//指向后继的指针</span></span><br><span class="line">&#125;DLNode;</span><br><span class="line"></span><br><span class="line"><span class="function">DLNode *<span class="title">create_node</span><span class="params">(ElemType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLNode *ret = (DLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">    ret-&gt;data = data;</span><br><span class="line">    ret-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    ret-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="function">DLNode *<span class="title">create_link_tail</span><span class="params">(DLNode *L,ElemType data[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLNode *s,*r;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    L = create_node(<span class="literal">NULL</span>);</span><br><span class="line">    r = L;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n ; i++)&#123;</span><br><span class="line">        s = create_node(data[i]);</span><br><span class="line">        s-&gt;prior = r;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找某个位置的结点的指针</span></span><br><span class="line"><span class="function">DLNode *<span class="title">find_elem_node</span><span class="params">(DLNode *L,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,count = <span class="number">0</span>;</span><br><span class="line">    DLNode *ret = L-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;<span class="number">0</span> || p &gt; link_length(L))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt; p ; i++)&#123;</span><br><span class="line">        ret = ret-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">//这样写如果未找到也会返回NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在某个结点后面插入结点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert_elem</span><span class="params">(DLNode *L,ElemType data,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLNode *s,*p;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span>|| index&gt;link_length(L))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    p = find_elem_node(L,index);</span><br><span class="line">    s = create_node(data);</span><br><span class="line">    <span class="keyword">if</span>(index != link_length(L))&#123;</span><br><span class="line">        s-&gt;next = p-&gt;next;</span><br><span class="line">        s-&gt;prior = p;</span><br><span class="line">        p-&gt;next = s;</span><br><span class="line">        s-&gt;next-&gt;prior = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        p-&gt;next = s;</span><br><span class="line">        s-&gt;prior=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除某个结点并返回</span></span><br><span class="line"><span class="function">DLNode *<span class="title">delete_node</span><span class="params">(DLNode *L,<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLNode *ret;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span>|| index&gt;link_length(L))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ret = find_elem_node(L,index);</span><br><span class="line">    <span class="keyword">if</span>(index != link_length(L))&#123;</span><br><span class="line">        ret-&gt;next-&gt;prior = ret-&gt;prior;</span><br><span class="line">        ret-&gt;prior-&gt;next = ret-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ret-&gt;prior-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双链表长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link_length</span><span class="params">(DLNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(L-&gt;next)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        L = L -&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印双链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf_link</span><span class="params">(DLNode *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(L-&gt;next)&#123;</span><br><span class="line">        L = L -&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,L-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLNode *A;</span><br><span class="line">    DLNode *local;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    ElemType data1[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//尾插法</span></span><br><span class="line">    A = create_link_tail(A,data1,<span class="number">5</span>);</span><br><span class="line">    printf_link(A);</span><br><span class="line">    <span class="comment">//长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"A链表长度为：%d.\n\n"</span>,link_length(A));</span><br><span class="line">    <span class="comment">//查找结点</span></span><br><span class="line">    local = find_elem_node(A,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"查找到第2位结点为：%d.\n\n"</span>,local-&gt;data);</span><br><span class="line">    <span class="comment">//指定结点后插入元素</span></span><br><span class="line">    insert_elem(A,<span class="number">6</span>,<span class="number">5</span>);</span><br><span class="line">    printf_link(A);</span><br><span class="line">    <span class="comment">//删除某个结点</span></span><br><span class="line">    local = delete_node(A,<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除的结点为：%d\n\n"</span>,local-&gt;data);</span><br><span class="line">    printf_link(A);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>循环单链表和循环双链表是由对应的单链表和双链表改造而来，只需要在终点结点和头结点间建立联系即可。循环单链表终端结点的next结点指针指向头结点。循环双链表终端结点的next指针指向表头结点，头节点的prior指针指向表尾节点即可。</p>
<p>tips：</p>
<p>如果P指针沿着循环链表行走，则判断p走到尾节点的条件是p-&gt;next == head。循环链表的操作均与非循环链表类似。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>表</tag>
        <tag>双链表</tag>
        <tag>循环链表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——栈和队列</title>
    <url>/posts/51797.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：栈和队列的基本概念、顺序栈/队列、链栈/队列的构成方法。</p>
<a id="more"></a>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h3><ol>
<li><p>定义</p>
<p>栈是一种只能在一段进行插入和删除操作的线性表。其中允许进行插入或者删除操作的一端称为栈顶（top）。栈顶由一个称为栈顶指针的位置指示器（其中就是一个变量，对于顺序栈，就是进行记录栈顶元素所在数组位置标号的一个整型变量。对于链式栈，就是记录栈顶元素所在的结点地址的指针）来指示的，它是动态变化的。表的另一端称为栈底，栈底固定不变。栈的插入和删除操作一般称为入栈和出栈。</p>
</li>
<li><p>栈的特点</p>
<p>由栈的定义，栈的特点是FILO。栈中的元素就好比开进死胡同的车队。</p>
</li>
<li><p>栈的存储结构</p>
<p>可以用顺序表和链表来存储栈，栈可以依照存储结构分为两种：顺序栈和链式栈。在栈的定义中已经说明，栈是一种在操作上稍加限制的线性表，即栈本质上是一个线性表，而线性表由两种主要的存储结构——顺序表和链表，因此栈也同样有对应的两种存储结构。</p>
</li>
<li><p>栈的数学性质</p>
<p>当n个元素以某种顺序进栈，并且可以在任意时刻出栈时，所获得的元素排列的数目N恰好满足Catalan（）的计算：</p>
<blockquote>
<p>N = 1/（n+1）* C （上标n下标2n）组合</p>
</blockquote>
</li>
</ol>
<h3 id="队列的基本概念"><a href="#队列的基本概念" class="headerlink" title="队列的基本概念"></a>队列的基本概念</h3><ol>
<li><p>队列的定义</p>
<p>队列简称队，它也是一种操作受限的线性表，其限制为仅允许在表的一段进行插入，在表的另一端进行删除。可进行插入的一端称为队尾（rear），可进行删除的一端策划归称为队头（front）。向队列中插入新的元素称为进队，新元素进队后就称为了新的队尾元素，从队列中删除元素称为出队，元素出队后，其后继元素就成为新的队头元素。</p>
</li>
<li><p>队列的特点</p>
<p>队列的特点概况起来就是FIFO。</p>
</li>
<li><p>队列的存储结构</p>
<p>可用顺序表和链表来存储队列，队列按存储结构可分为顺序队和链队两种。</p>
</li>
</ol>
<h2 id="栈和队列的存储结构、算法和应用"><a href="#栈和队列的存储结构、算法和应用" class="headerlink" title="栈和队列的存储结构、算法和应用"></a>栈和队列的存储结构、算法和应用</h2><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><ol>
<li><p>顺序栈的要素</p>
<p>对于顺序栈st，一共有四个要素，包括两个特殊状态和两个操作。</p>
<blockquote>
<p>1） 栈空状态</p>
<p>st.top== -1，这里暂时这么定义，这样不会浪费一个元素大小的空间。</p>
</blockquote>
<blockquote>
<p>2）栈满状态</p>
<p>st.top == max_size -1。max_size为栈中最大元素个数，则max_size-1为栈满时栈顶元素在数组中的位置，因为数组下标从0开始，所以定义top为-1时栈空，即top==0的数组位置也可以存放数据元素。</p>
</blockquote>
<blockquote>
<p>3）非法状态（上溢和下溢）</p>
<p>栈满的时候继续入栈就会上溢，栈空的时候出栈就会下溢。</p>
</blockquote>
<blockquote>
<p>4）元素x进栈的操作： ++（st.top); st.data[st.top] =x; 。既然规定了top为-1时栈空，则元素进栈操作必须是先移动指针，再进入元素，因为不存在下标为-1的数组。</p>
</blockquote>
<blockquote>
<p>5）元素x出栈的操作： x = st.data[st.top]; –(st.top); 。进栈操作次序决定了出栈操作次序，由于进栈操作是先变动栈顶指针，再存入元素，因此出栈的操作必须为先取出元素再变动指针。如果上述进栈操作不变的情况下先动指针，再取出元素，则栈顶元素则会丢失，取出的是栈顶下边的元素。</p>
</blockquote>
<p>顺序栈定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[max_size];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;sq_stack;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>   初始化：</p>
   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initStack</span><span class="params">(sq_stack *st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st-&gt;top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>   判定栈是否为空：</p>
   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isEmpty</span><span class="params">(sq_stack *st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(st-&gt;top == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈为空栈！\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈不为空！\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>   进栈以及出栈操作：</p>
   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进栈操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(sq_stack *st,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(st-&gt;top == max_size<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈已经满了！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++(st-&gt;top);</span><br><span class="line">    st-&gt;data[st-&gt;top]=x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(sq_stack *st, <span class="keyword">int</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(st-&gt;top == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈已经空了！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *x = st-&gt;data[st-&gt;top];</span><br><span class="line">    --(st-&gt;top);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>   全部代码：</p>
   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_size 128</span></span><br><span class="line"><span class="comment">//顺序栈的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[max_size];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;sq_stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下为顺序栈的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initStack</span><span class="params">(sq_stack *st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st-&gt;top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isEmpty</span><span class="params">(sq_stack *st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(st-&gt;top == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈为空栈！\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈不为空！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进栈操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(sq_stack *st,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(st-&gt;top == max_size<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈已经满了！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++(st-&gt;top);</span><br><span class="line">    st-&gt;data[st-&gt;top]=x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(sq_stack *st, <span class="keyword">int</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(st-&gt;top == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈已经空了！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *x = st-&gt;data[st-&gt;top];</span><br><span class="line">    --(st-&gt;top);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sq_stack *st;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    st = (sq_stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(sq_stack));</span><br><span class="line">    initStack(st);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"初始化后栈顶指针为：%d\n"</span>,st-&gt;top);</span><br><span class="line">    isEmpty(st);</span><br><span class="line">    push(st,x);</span><br><span class="line">    isEmpty(st);</span><br><span class="line">    pop(st,&amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"y的值为：%d\n"</span>,y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="2">
<li><p>简化操作</p>
<p>其中值得说的是，顺序栈其实可以很简单的定义以及进出栈：</p>
<blockquote>
<p>定义一个栈并初始化</p>
<p>int stack[max_size];</p>
<p>int top = -1;</p>
</blockquote>
<blockquote>
<p>元素进栈</p>
<p>stack[++top] = x;</p>
</blockquote>
<blockquote>
<p>元素出栈</p>
<p>stack[top–] = x;</p>
</blockquote>
<p>其中元素进出栈要根据具体情况按需判断栈的空或满；</p>
<p>tips:</p>
<p>在自增操作中 ++a;总是比a++;来得执行效率更加高效，因此独立的自增操作总是用++a;。自减也是同样的道理。</p>
</li>
</ol>
<h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><ol>
<li><p>链栈的要素</p>
<p>和顺序栈对应，链栈也有4个要素，包括两个特殊状态和两个操作。</p>
<p>（1）两个状态</p>
<blockquote>
<p>栈空状态：</p>
<p>lst-&gt;next == NULL;</p>
</blockquote>
<blockquote>
<p>栈满状态：</p>
<p>不存在栈满状态（假设内存无限大）</p>
</blockquote>
<p>（2）两个操作</p>
<blockquote>
<p>元素（由指针p所指）进栈操作</p>
<p>p-&gt;next = lst-&gt;next;</p>
<p>lst-&gt;next = p;</p>
<p>其实就是头插法建立链表的插入操作。</p>
</blockquote>
<blockquote>
<p>出栈操作（出栈元素保存在x中）</p>
<p>p = lst-&gt;next;</p>
<p>x = p-&gt;data;</p>
<p>lst-&gt;next = p-&gt;next;</p>
<p>free(p);</p>
<p>其实就是单链表的删除操作。</p>
</blockquote>
</li>
<li><p>基本操作</p>
<p>链栈结点定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链栈结点的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode;</span><br></pre></td></tr></table></figure>

<p>初始化链栈：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化链栈</span></span><br><span class="line"><span class="function">LNode *<span class="title">initStack</span><span class="params">(LNode *lst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lst = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//制造一个头结点</span></span><br><span class="line">    lst-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> lst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断栈空：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isEmpty</span><span class="params">(LNode *lst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lst-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈为空栈！\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈不为空！\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进出栈：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(LNode *lst,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    p-&gt;data = x;</span><br><span class="line">    p-&gt;next = lst-&gt;next;</span><br><span class="line">    lst-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(LNode * lst,<span class="keyword">int</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">if</span>(lst-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈为空栈！\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = lst-&gt;next;</span><br><span class="line">        *x = p-&gt;data;</span><br><span class="line">        lst-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//链栈结点的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode;</span><br><span class="line"><span class="comment">//初始化链栈</span></span><br><span class="line"><span class="function">LNode *<span class="title">initStack</span><span class="params">(LNode *lst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lst = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//制造一个头结点</span></span><br><span class="line">    lst-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> lst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isEmpty</span><span class="params">(LNode *lst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lst-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈为空栈！\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈不为空！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(LNode *lst,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    p-&gt;data = x;</span><br><span class="line">    p-&gt;next = lst-&gt;next;</span><br><span class="line">    lst-&gt;next = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(LNode * lst,<span class="keyword">int</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="keyword">if</span>(lst-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈为空栈！\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = lst-&gt;next;</span><br><span class="line">        *x = p-&gt;data;</span><br><span class="line">        lst-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LNode *lst;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    lst = initStack(lst);</span><br><span class="line">    isEmpty(lst);</span><br><span class="line">    push(lst,x);</span><br><span class="line">    isEmpty(lst);</span><br><span class="line">    pop(lst,&amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"y的值为：%d\n"</span>,y);</span><br><span class="line">    isEmpty(lst);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="顺序队"><a href="#顺序队" class="headerlink" title="顺序队"></a>顺序队</h3><ol>
<li><p>循环队列</p>
<p>front代表头指针；    rear代表尾指针；</p>
<p>要实现指针在递增的过程中沿着环形道路行走，就拿front举例子，可以循环执行语句front= （front+1)%max_size    (max_size指的是数组长度)。</p>
</li>
<li><p>两个状态</p>
<blockquote>
<p>队空状态</p>
<p>qu.rear == qu.front</p>
</blockquote>
<blockquote>
<p>队满状态</p>
<p>(qu.rear+1)%max_size == qu.front</p>
</blockquote>
</li>
<li><p>两个操作</p>
<blockquote>
<p>元素x进队操作（移动队尾指针）</p>
<p>qu.rear = (qu.rear + 1)%max_size;</p>
<p>qu.data[qu.rear] = x;</p>
</blockquote>
<blockquote>
<p>元素x出队操作（移动队首指针）</p>
<p>qu.front = (qu.front + 1)%max_size;</p>
<p>x = qu.data[qu.front];</p>
</blockquote>
<p>tips:</p>
<p>元素入队先移动指针，后存入元素，对应元素出队时，先移动指针，再取出元素。可能有的方式不同，但是归根究底本质是一样的。</p>
</li>
<li><p>顺序队的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[max_size];</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125;sq_queue;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化队列以及判断队列是否为空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_sq_queue</span><span class="params">(sq_queue *qu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qu-&gt;front = qu-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断队空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(sq_queue *qu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(qu-&gt;front == qu-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进队以及出队</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">in_queue</span><span class="params">(sq_queue *qu,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((qu-&gt;rear+<span class="number">1</span>)%max_size == qu-&gt;front)<span class="comment">//判断队列是否为满</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列已满！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    qu-&gt;rear = (qu-&gt;rear + <span class="number">1</span>)%max_size;</span><br><span class="line">    qu-&gt;data[qu.rear] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">out_queue</span><span class="params">(sq_queue *qu,<span class="keyword">int</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(qu-&gt;rear == qu-&gt;front)<span class="comment">//判断队列是否为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列为空！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    qu-&gt;front = (qu-&gt;front + <span class="number">1</span>)%max_size;</span><br><span class="line">    *x = qu-&gt;data[qu.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>全部代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_size 128</span></span><br><span class="line"><span class="comment">//顺序队定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[max_size];</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125;sq_queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_sq_queue</span><span class="params">(sq_queue *qu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qu-&gt;front = qu-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断队空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isEmpty</span><span class="params">(sq_queue *qu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(qu-&gt;front == qu-&gt;rear)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列为空！\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列不为空！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进队</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">in_queue</span><span class="params">(sq_queue *qu,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((qu-&gt;rear+<span class="number">1</span>)%max_size == qu-&gt;front)<span class="comment">//判断队列是否为满</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列已满！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    qu-&gt;rear = (qu-&gt;rear + <span class="number">1</span>)%max_size;</span><br><span class="line">    qu-&gt;data[qu-&gt;rear] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">out_queue</span><span class="params">(sq_queue *qu,<span class="keyword">int</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(qu-&gt;rear == qu-&gt;front)<span class="comment">//判断队列是否为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队列为空！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    qu-&gt;front = (qu-&gt;front + <span class="number">1</span>)%max_size;</span><br><span class="line">    *x = qu-&gt;data[qu-&gt;front];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sq_queue *qu;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    qu = (sq_queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(sq_queue));</span><br><span class="line">    isEmpty(qu);</span><br><span class="line">    x = <span class="number">5</span>;</span><br><span class="line">    in_queue(qu,x);</span><br><span class="line">    isEmpty(qu);</span><br><span class="line">    out_queue(qu,&amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"出队的元素y = %d\n"</span>,y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链队定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——顺序表</title>
    <url>/posts/48384.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：由于太久没有复习数据结构了，导致该忘的都忘了，所以在这里记录重新学习数据结构的笔记，以备以后查看。</p>
<a id="more"></a>

<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><p>顺序表是在计算机内存中以<a href="https://baike.baidu.com/item/数组/3794097" target="_blank" rel="noopener">数组</a>的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元依次存储线性表中的各个元素、使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系，采用顺序存储结构的线性表通常称为顺序表。顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中。</p>
<h3 id="构建一个简单的顺序表"><a href="#构建一个简单的顺序表" class="headerlink" title="构建一个简单的顺序表"></a>构建一个简单的顺序表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_size 128</span></span><br><span class="line"><span class="comment">//采取动态分配的方式创建顺序表</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> struct <span class="title">LinkList</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *data;</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">&#125;Link;</span><br></pre></td></tr></table></figure>

<p>这就很简单的构建了一个顺序表的结构了。</p>
<h3 id="初始化顺序表"><a href="#初始化顺序表" class="headerlink" title="初始化顺序表"></a>初始化顺序表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Link *<span class="title">create_link</span><span class="params">(<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">	Link *ret = (Link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link));</span><br><span class="line">	ret-&gt;data = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link)*len);</span><br><span class="line">	ret-&gt;length = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以很简单的初始化顺序表了，其中初始化data空间，以及将length(表长)置为0。</p>
<h3 id="寻找对应元素的下标"><a href="#寻找对应元素的下标" class="headerlink" title="寻找对应元素的下标"></a>寻找对应元素的下标</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_elem_p</span><span class="params">(Link *L,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; L-&gt;length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(x &lt;= L-&gt;data[i])</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这句话中，从头开始寻找，当length == 0 时，会直接返回0，否则就是查找返回一个比x大的值的下标，若没有找到则返回最后一个元素下标+1。</p>
<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert_elem</span><span class="params">(Link *L, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p,i;</span><br><span class="line">	p = find_elem_p(L,x);</span><br><span class="line">	<span class="keyword">if</span>(L-&gt;length ==<span class="number">0</span>)&#123;</span><br><span class="line">		L-&gt;data[<span class="number">0</span>] = x;</span><br><span class="line">		++(L-&gt;length);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i = L-&gt;length<span class="number">-1</span>;i &gt; p ; i--)</span><br><span class="line">		L-&gt;data[i+<span class="number">1</span>] = L-&gt;data[i];</span><br><span class="line">	L-&gt;data[p] = x;</span><br><span class="line">	++(L-&gt;length);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入元素体现的是如果顺序表长度为0，则对data[0]赋值，若长度不为0，则将查询到需要插入的下标之后的元素整体向后位移一位，接着再将该元素插入。</p>
<p>tips:</p>
<blockquote>
<p>切记边界的判断，我在这卡壳一天就是因为没有理解好边界值的正确取法。</p>
</blockquote>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete_elem</span><span class="params">(Link *L,<span class="keyword">int</span> p,<span class="keyword">int</span> *e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">if</span>(p&lt;<span class="number">0</span> || p &gt; L-&gt;length <span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	*e = L-&gt;data[p];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i = p; i &lt; L-&gt;length<span class="number">-1</span>;i++)</span><br><span class="line">		L-&gt;data[i]=L-&gt;data[i+<span class="number">1</span>];</span><br><span class="line">	</span><br><span class="line">	--(L-&gt;length);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除元素即把原来的元素取出到e中，并把所有后面一个元素向前位移一位，最后将length减去一即可。</p>
<p>（这里有个疑问，最后一位向前移位后需要将原来的最后一位释放掉（free(L-&gt;data[i])，会对以后的程序产生错误嘛，留待大家给我解答）</p>
<h3 id="获取下标对应的元素"><a href="#获取下标对应的元素" class="headerlink" title="获取下标对应的元素"></a>获取下标对应的元素</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_elem_p</span><span class="params">(Link *L,<span class="keyword">int</span> p,<span class="keyword">int</span>* e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; <span class="number">0</span> || p &gt; L-&gt;length<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *e = L-&gt;data[p];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打印顺序表"><a href="#打印顺序表" class="headerlink" title="打印顺序表"></a>打印顺序表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_link</span><span class="params">(Link* L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L-&gt;length;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,L-&gt;data[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放表"><a href="#释放表" class="headerlink" title="释放表"></a>释放表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_link</span><span class="params">(Link* L)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(L-&gt;data);</span><br><span class="line">	<span class="built_in">free</span>(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主函数部分"><a href="#主函数部分" class="headerlink" title="主函数部分"></a>主函数部分</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Link  *link1 = <span class="number">0</span>;</span><br><span class="line">	link1 = create_link_list(max_size);</span><br><span class="line">	<span class="comment">//初始以及创建的方式，很简单</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_size 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动态分配空间</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> *data;</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">&#125;Link;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建顺序表</span></span><br><span class="line"><span class="function">Link * <span class="title">create_link_list</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	Link* ret = (Link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link));</span><br><span class="line">	ret-&gt;data = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Link)*len);</span><br><span class="line">	ret-&gt;length = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//寻找元素对应的下标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_elem</span><span class="params">(Link* L, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L-&gt;length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x &lt;= L-&gt;data[i])</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert_elem</span><span class="params">(Link *L, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p, i;</span><br><span class="line">	p = find_elem(L, x);</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;length == <span class="number">0</span>) &#123;</span><br><span class="line">		L-&gt;data[<span class="number">0</span>] = x;</span><br><span class="line">		++(L-&gt;length);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = L-&gt;length<span class="number">-1</span> ; i &gt; p; --i) &#123;</span><br><span class="line">		L-&gt;data[i + <span class="number">1</span>] = L-&gt;data[i];</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;data[p] = x;</span><br><span class="line">	++(L-&gt;length);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">delete_elem</span><span class="params">(Link *L,<span class="keyword">int</span> p,<span class="keyword">int</span>* e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; <span class="number">0</span> || p &gt; L-&gt;length<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    *e = L-&gt;data[p];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = p;i &lt; L-&gt;length<span class="number">-1</span>;i++)</span><br><span class="line">        L-&gt;data[i]=L-&gt;data[i+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//free(L-&gt;data[i]);</span></span><br><span class="line">    --(L-&gt;length);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取下标的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_elem_p</span><span class="params">(Link *L,<span class="keyword">int</span> p,<span class="keyword">int</span>* e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; <span class="number">0</span> || p &gt; L-&gt;length<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *e = L-&gt;data[p];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_link</span><span class="params">(Link* L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L-&gt;length;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%3d"</span>,L-&gt;data[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_link</span><span class="params">(Link* L)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(L-&gt;data);</span><br><span class="line">	<span class="built_in">free</span>(L);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> e;</span><br><span class="line">	Link* link1 = <span class="literal">NULL</span>;</span><br><span class="line">	link1 = create_link_list(max_size);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">	insert_elem(link1, i);</span><br><span class="line">	&#125;</span><br><span class="line">	print_link(link1);</span><br><span class="line"></span><br><span class="line">	delete_elem(link1,<span class="number">2</span>,&amp;e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"被删除的元素：%d\n"</span>,e);</span><br><span class="line">    print_link(link1);</span><br><span class="line"></span><br><span class="line">	free_link(link1);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>表</tag>
        <tag>顺序表</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试——编写测试用例</title>
    <url>/posts/software_testing_2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：为特定测试目标或者测试条件而制定的一组测试集合。</p>
<a id="more"></a>

<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>为特定测试目标或测试条件而制定的一组输入值、执行入口条件、预期结果和执行出口条件的集合</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200606200733790.png" alt="image-20200606200733790"></p>
<h3 id="测试用例文档"><a href="#测试用例文档" class="headerlink" title="测试用例文档"></a>测试用例文档</h3><ul>
<li>功能性测试</li>
<li>安全性测试</li>
<li>XSS攻击</li>
<li>sql注入</li>
<li>暴力破解</li>
<li>密码加密</li>
</ul>
<h3 id="完整的测试用例"><a href="#完整的测试用例" class="headerlink" title="完整的测试用例"></a>完整的测试用例</h3><ul>
<li>测试用例的设计角度</li>
<li>功能性</li>
<li>安全性</li>
<li>压测性</li>
<li>兼容性</li>
<li>全覆盖性</li>
</ul>
<p>举个例子：</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200607112431355.png" alt="image-20200607112431355"></p>
<p>等价类设计测试用例：</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200607113404449.png" alt="image-20200607113404449"></p>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
        <tag>测试用例</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试——自动化测试</title>
    <url>/posts/Software_testing_1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：自动化测试是可以代替大量的重复机械劳动，自动的检测、处理、判断、操纵等，以实现预期目标</p>
<a id="more"></a>

<h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><p>由及其设备在没有人为干预或者较少干预的情况下，按照认为人为的设计要求，自动的检测、处理、判断、操纵等，以实现预期目标的过程</p>
<h2 id="自动化测试优点"><a href="#自动化测试优点" class="headerlink" title="自动化测试优点"></a>自动化测试优点</h2><ul>
<li>自动化测试可以代替大量的重复性机械劳动，测试工程师可以有更多时间测试新的业务功能</li>
<li>自动化测试可以大幅度提升回归测试的效率</li>
<li>当有人类无法执行的任务时，自动化测试的作用更加强烈，例如24小时长时间的进行压力测试</li>
</ul>
<h2 id="自动化测试缺点"><a href="#自动化测试缺点" class="headerlink" title="自动化测试缺点"></a>自动化测试缺点</h2><ul>
<li>自动化测试无法解决所有的手动测试，大多数情况用于解决重复性高，机械化的事情</li>
<li>自动化测试其实比较脆弱，比如，由于开发人员的一个手误，写错了一处代码，测试工程师并不知道，费好大劲写好了测试脚本，人家改一处代码， 测试可能重写测试脚本，脚本维护成本较高</li>
<li>自动化测试是按部就班的完成预先定义好的步骤，因此不存在“智能”，遇见问题没有处理能力</li>
<li>只有人为的功能测试，才能够发现更多的软件缺陷，自动化测试优势在回归测试</li>
<li>自动化测试脚本编写需要具备编程能力，传统的手工测试I程师需要付出较多的努力</li>
</ul>
<h2 id="自动化测试的场景"><a href="#自动化测试的场景" class="headerlink" title="自动化测试的场景"></a>自动化测试的场景</h2><ul>
<li><p>图形化测试</p>
</li>
<li><p>移动端测试</p>
</li>
<li><p>并发场景</p>
</li>
</ul>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>软件缺陷报告与JIRA的使用</title>
    <url>/posts/44793.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：记录了测试中的软件缺陷报告以及JIRA的使用。</p>
<a id="more"></a>

<h2 id="软件缺陷的信息"><a href="#软件缺陷的信息" class="headerlink" title="软件缺陷的信息"></a>软件缺陷的信息</h2><h3 id="软件缺陷报告的样例"><a href="#软件缺陷报告的样例" class="headerlink" title="软件缺陷报告的样例"></a>软件缺陷报告的样例</h3><p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200607195526051.png" alt="image-20200607195526051"></p>
<h3 id="软件缺陷的基本内容"><a href="#软件缺陷的基本内容" class="headerlink" title="软件缺陷的基本内容"></a>软件缺陷的基本内容</h3><ol>
<li>缺陷的标题</li>
<li>预置条件</li>
<li>重现步骤</li>
<li>期望结果</li>
<li>实际结果</li>
</ol>
<h3 id="软件缺陷的状态"><a href="#软件缺陷的状态" class="headerlink" title="软件缺陷的状态"></a>软件缺陷的状态</h3><blockquote>
<p>新建 –&gt; 打开 –&gt;  修复 –&gt; 关闭</p>
</blockquote>
<h3 id="软件缺陷的严重程度"><a href="#软件缺陷的严重程度" class="headerlink" title="软件缺陷的严重程度"></a>软件缺陷的严重程度</h3><p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200607200036217.png" alt="image-20200607200036217"></p>
<h3 id="软件缺陷的优先级"><a href="#软件缺陷的优先级" class="headerlink" title="软件缺陷的优先级"></a>软件缺陷的优先级</h3><p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200607200118372.png" alt="image-20200607200118372"></p>
<p>根据具体情况确定优先级的高低</p>
<h3 id="软件缺陷的类型"><a href="#软件缺陷的类型" class="headerlink" title="软件缺陷的类型"></a>软件缺陷的类型</h3><ol>
<li>代码错误</li>
<li>设计缺陷</li>
<li>性能问题</li>
<li>安全相关</li>
</ol>
<h2 id="软件缺陷的跟踪流程"><a href="#软件缺陷的跟踪流程" class="headerlink" title="软件缺陷的跟踪流程"></a>软件缺陷的跟踪流程</h2><blockquote>
<p> 提交 –&gt; 确认 –&gt; 打开 –&gt; 修复 –&gt; 回归 –&gt; 关闭</p>
</blockquote>
<h2 id="JIRA的基本使用"><a href="#JIRA的基本使用" class="headerlink" title="JIRA的基本使用"></a>JIRA的基本使用</h2><h3 id="jira中的问题概念"><a href="#jira中的问题概念" class="headerlink" title="jira中的问题概念"></a>jira中的问题概念</h3><p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200607200923327.png" alt="image-20200607200923327"></p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/image-20200607200958199.png" alt="image-20200607200958199"></p>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
        <tag>JIRA</tag>
      </tags>
  </entry>
  <entry>
    <title>软件过程模型</title>
    <url>/posts/Software_model.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>摘要：所谓软件过程模型就是一种开发策略，这种策略针对软件工程的各个阶段提供了一套范形，使工程的进展达到预期的目的。</p>
<a id="more"></a>

<h2 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h2><p>瀑布模型(Waterfall Model)又称流水式过程模型，它将软件开发过程模仿旅游景点的阶梯瀑布，由上向下一个阶梯一个阶梯地倾泻下来，最后进入一个风平浪尽的大湖，这个大湖就是软件企业的产品库。</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/ad9e993ad8a04774ac6f4205cbbc4ad7.png" alt></p>
<h3 id="模型特点"><a href="#模型特点" class="headerlink" title="模型特点"></a>模型特点</h3><ul>
<li>前一个阶段的工作完成之后，才能开始后一段工作。</li>
<li>每个阶段需要完成规定的文档。</li>
<li>上一个阶段的输出文档是下一个阶段的输入文档</li>
<li>每个阶段都要对文档镜像评估，以便更早的查清问题</li>
</ul>
<h3 id="模型优点"><a href="#模型优点" class="headerlink" title="模型优点"></a>模型优点</h3><ul>
<li>开发的阶段性，各阶段具有顺序性和依赖性</li>
<li>强调早期调研和需求分析</li>
<li>提供了一个模板，这个模板使得分析、设计、编码、测试和支持的方法可以在该模板下有一个共同的指导</li>
</ul>
<h3 id="模型局限"><a href="#模型局限" class="headerlink" title="模型局限"></a>模型局限</h3><ul>
<li>瀑布模型是一个线性模型，对项目的推进有着严格的要求，必须等到所有开发工作后才能实现产品的交付，不能对软件系统进行快速构建，对于基于交付的开发不方便</li>
<li>瀑布模型适用于需求明确且无大的需求变更的开发，对于需求模糊的项目并不适用。</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>适用于需求确定，无大的需求变更，工作能够采用线性的方式完成的软件</p>
<h2 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h2><p>增量模型（Incremental Model）融合了瀑布模型的基本成分和原型实现的迭代特征，它对软件的过程按照：整体上按瀑布迷信的流程实施开发，以便对项目的管理，但在实际开发过程中，则将软件系统按功能多增减构件，以逐个地创建与交付，直到全部增量构件创建完成，并集成到系统之中交付用户使用。</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/2.png" alt="2"></p>
<h3 id="模型特点-1"><a href="#模型特点-1" class="headerlink" title="模型特点"></a>模型特点</h3><ul>
<li>当使用增量模型时，第一个增量往往是核心产品</li>
<li>客户对每个增量的使用和评估都是下一个增量发布的新功能</li>
<li>采用随时间进展交互进行，使得每个线性序列产生软件的一个可发布“增量”</li>
</ul>
<h3 id="模型优点-1"><a href="#模型优点-1" class="headerlink" title="模型优点"></a>模型优点</h3><ul>
<li>第一个可交付的成本和时间较少</li>
<li>开发的增量表示的小系统的风险较小</li>
<li>运行增量的投资，可以在项目才开始的时候对一两个增量投资</li>
</ul>
<h3 id="模型局限-1"><a href="#模型局限-1" class="headerlink" title="模型局限"></a>模型局限</h3><ul>
<li>管理发生的成本或者进度等可能会超出组织能力</li>
<li>没有对用户的变更要求进行规划，那么产出的出事增量可能造成后来增量的不稳定性</li>
<li>如果需求不像早期思考的稳定，就需要重新发布不稳定的增量</li>
</ul>
<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><p>项目在既定的商业要求期限之前不可能找到足够的开发人员的情况。</p>
<h2 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h2><p>对于复杂的大型软件，开发一个原型往往达不到要求。螺旋模型将瀑布模型和演化模型结合起来，加入了两种模型均忽略的风险分析，弥补了这两种模型的不足。</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/4.png" alt="4"></p>
<h3 id="模型特点-2"><a href="#模型特点-2" class="headerlink" title="模型特点"></a>模型特点</h3><ul>
<li>与瀑布模型相比，螺旋模型支持用户需求的动态变化，为用户参与软件开发的所有关键决策提供了方便；</li>
<li>使用螺旋模型进行软件开发，需要开发人员具有相当丰富的风险评估经验和专门知识。</li>
</ul>
<h3 id="模型优点-2"><a href="#模型优点-2" class="headerlink" title="模型优点"></a>模型优点</h3><ul>
<li>关注软件的重用；</li>
<li>关注早期错误的消除；</li>
<li>将质量目标放在首位；</li>
<li>将开发阶段与维护阶段结合在一起。</li>
</ul>
<h3 id="模型局限-2"><a href="#模型局限-2" class="headerlink" title="模型局限"></a>模型局限</h3><ul>
<li>开发人员需要有较强的风险评估的经验；</li>
<li>契约开发通常需要事先指定过程模型和发布产品。</li>
</ul>
<h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><p>螺旋模型强调风险分析，使得开发人员和用户对每个演化层出现的风险有所了解，从而做出应有的反应。因此，该模型适合用于庞大、复杂并且具有高风险的系统。</p>
<h2 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h2><p>喷泉模型（Water Fountain Model）是专门针对面向对象软件开发方法而提出的。“喷泉”一词用于形象地表达面向对象软件开发过程中的迭代和无缝过渡。</p>
<p>在面向对象方法中，对象既是对现实问题中实体的抽象，也是构造软件系统的基本元素。 因此，建立对象模型在面向对象方法中，既可以用于分析，也可以用于设计，而且分析阶段所获得的对象框架模型可以无缝过渡到设计阶段，以作为软件实现的依据。</p>
<p>喷泉模型的过程方法所考虑的是，基于面向对象方法所带来的便利，对软件的分析、设计和实现按照迭代的方式交替进行，并通过进化的方式，使软件分阶段逐渐完整、逐步求精。</p>
<p><img src="https://gitee.com/hongcyu/image/raw/master/images/5.png" alt="5"></p>
<h3 id="模型特点-3"><a href="#模型特点-3" class="headerlink" title="模型特点"></a>模型特点</h3><ul>
<li>喷泉模型是一种以用户需求为动力，以对象作为驱动力的模型，适合面向对象的开发方法</li>
<li>碰巧模型使得开发过程具有迭代性和无缝衔接，在迭代过程中不断地完善软件系统</li>
</ul>
<h3 id="模型优点-3"><a href="#模型优点-3" class="headerlink" title="模型优点"></a>模型优点</h3><p>喷泉模型的各个阶段没有明显的界线，开发人员可以同步进行，节省开发时间</p>
<h3 id="模型局限-3"><a href="#模型局限-3" class="headerlink" title="模型局限"></a>模型局限</h3><ul>
<li>由于喷泉模型在各个开发阶段是重叠的，在开发过程中需要大量的开发人员，不利于项目的管理；</li>
<li>喷泉模型要求严格管理文档，使得审核的难度加大。</li>
</ul>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
