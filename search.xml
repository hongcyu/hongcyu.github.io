<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[利用Opencv将视频转换为字符视频]]></title>
    <url>%2F2019%2F11%2F17%2F%E5%88%A9%E7%94%A8Opencv%E5%B0%86%E8%A7%86%E9%A2%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[摘要：在Python课上学习了将图片转换为字符画的代码，想看看可不可以把视频转换为字符画视频，便有了此次为期一周陆陆续续写的视频画代码。 整体思路 分离出构成视频的图片 对图片进行ASCII码的转换 将转换好的图片进行合成为视频 本次为了方便测试，未添加删除生成文件的代码，需要手动删除或者自己添加代码。 将像素转换为ASCII码将像素转换为ASCII码是为了在后期上色以及转换为字符时加以区别。 123456789def get_char(r,g,b,alpha = 256): ascii_char = list("#RMNHQODBWGPZ*@$C&amp;98?32I1&gt;!:-;. ") #ascii_char = list("$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:oa+&gt;!:+. ") if alpha == 0: return '' length = len(ascii_char) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = (256.0+1)/len(ascii_char) return ascii_char[int(gray/unit)] ​ 此函数的输入的图片的三基色加上透明度，分别为R,G,B,ALPHA。此处会在后面用pixel = im.getpixel((j, i))来进行传递值。 ​ 其中ascii_char就是字符列表，用来将不同灰度的像素进行不同字符体替换的参照，大家可以参试用不同的字符来观察出最好的组合。ps:听说个数必须为32的倍数，我也没有进行尝试，有兴趣的小伙伴们可以探究下其中的原因。 ​ alpha在为0的时候便是完全透明的图片，所以返回空，当他不为零时则将图片转换为灰度图像，此处运用$$gray = 0.2126 * r + 0.7152 * g + 0.0722 * b$$来将图片转换为灰度图像进行下面的ASCII输出。 将视频分隔成图片123456789101112131415161718#将视频转换为图片 并进行计数，返回总共生成了多少张图片！def video_to_pic(vp): #vp = cv2.VideoCapture(video_path) number = 0 if vp.isOpened(): r,frame = vp.read() if not os.path.exists('cache_pic'): os.mkdir('cache_pic') os.chdir('cache_pic') else: r = False while r: number += 1 cv2.imwrite(str(number)+'.jpg',frame) r,frame = vp.read() print('\n由视频一共生成了&#123;&#125;张图片！'.format(number)) os.chdir("..") return number ​ 可以看出来函数的传入值是vp = cv2.VideoCapture(video_path) 我将其放在主函数来进行输入，怕某些小伙伴没看见所以下其下写了备注。 1.isOpened()的用来检测资源是否在 VideoCapture()函数中打开。 2.os.chdir在PYTHON中的方法是用于改变当前工作目录到指定的路径。此处直接进入新创建的文件夹将生成的图片直接存入文件夹中。 3.返回number方便于后面的使用。 将图片转换为字符图片此处分为两个函数进行（明明放在一起可以省事，课当初太懒了，懒得改了555） 1234567891011121314def star_to_char(number,save_pic_path): if not os.path.exists('cache_char'): os.mkdir('cache_char') img_path_list = [save_pic_path + r'/&#123;&#125;.jpg'.format(i) for i in range(1,number+1)] #生成目标图片文件的路径列表 task = 0 for image_path in img_path_list: img_width , img_height = Image.open(image_path).size #获取图片的分辨率 task += 1 img_to_char(image_path, img_width , img_height, task) print('&#123;&#125;/&#123;&#125; is finished.'.format(task,number)) print('=======================') print('All image was finished!') print('=======================') return 0 ​ 第一个函数相当于开始准备函数，其中传入的是上一个传出的总共生成多少个图片的统计number,还有字符图片存储的路径。 ​ img_path_list 是用来存储图片相对路径的列表，采用内置for函数进行存储。 ​ 利用Image.open().size来获取图片大小，传入下面的转换函数。 123456789101112131415161718192021222324252627282930313233343536def img_to_char(image_path,raw_width,raw_height,task): width = int(raw_width/ 6) height = int(raw_height / 15) im = Image.open(image_path).convert('RGB')#必须以RGB模式打开 im = im.resize((width,height),Image.NEAREST) txt = '' color = [] for i in range(height): for j in range(width): pixel = im.getpixel((j, i)) color.append((pixel[0],pixel[1],pixel[2])) #将颜色加入进行索引 if len(pixel)==4 : txt +=get_char(pixel[0],pixel[1],pixel[2],pixel[3]) else: txt +=get_char(pixel[0],pixel[1],pixel[2]) txt += '\n' color.append((255,255,255)) im_txt = Image.new("RGB",(raw_width,raw_height),(255,255,255)) dr = ImageDraw.Draw(im_txt) #font = ImageFont.truetype('consola.ttf', 10, encoding='unic') #改为这个字体会让图片比例改变 font = ImageFont.load_default().font x,y = 0,0 font_w,font_h=font.getsize(txt[1]) font_h *= 1.37 #调整字体大小 for i in range(len(txt)): if(txt[i]=='\n'): x += font_h y = -font_w dr.text((y,x),txt[i] ,fill = color[i]) y+=font_w os.chdir('cache_char') im_txt.save(str(task)+'.jpg') os.chdir("..") return 0 ​ 要提醒的是，看下面代码： 12width = int(raw_width/ 6)height = int(raw_height / 15) ​ 如果要将图片进行转换必须把图片大小进行转换，否则转换出的代码必定会出现乱码。 ​ dr = ImageDraw.Draw(im_txt)是opencv中创建画板的函数。 ​ font_h是将字体进行调整，可以让生成的字符画视频更加的好康。 ​ 下面 for i in range(len(txt)):就是遍历txt按行按列进行写入图片，当遇到\n时推出并进行上色，最后将图片进行输出。 将图片合成为视频123456789101112131415161718192021def jpg_to_video(char_image_path,FPS): video_fourcc=VideoWriter_fourcc(*"MP42") # 设置视频编码器,这里使用使用MP42编码器,可以生成更小的视频文件 char_img_path_list = [char_image_path + r'/&#123;&#125;.jpg'.format(i) for i in range(1,number+1)] #生成目标字符图片文件的路径列表 char_img_test = Image.open(char_img_path_list[1]).size #获取图片的分辨率 video_writter= VideoWriter('video/new_char_video.avi' , video_fourcc , FPS , char_img_test) load = 'loading.' count = 0 #用来清空load进度条的计数 for image_path in char_img_path_list: img = cv2.imread(image_path) video_writter.write(img) load = load + '.' count += 1 if count % 50 == 0 : load = 'loading' print() print('\r',load,end='') video_writter.release() print('\n') print('=======================') print('The video is finished!') print('=======================') ​ 此处最需要注意的是第二行的视频编码器，我进行了大量的测试，发现MP42是可以生成较小并且较小的视频文件的编码方式，具体详细参数可以参考 []: https://blog.csdn.net/Archger/article/details/102868923 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128import cv2 from PIL import Image,ImageFont,ImageDrawimport osfrom cv2 import VideoWriter, VideoWriter_fourcc, imread, resize#=========================#coding:UTF-8# 视频转字符画含音频version-1#参考1：https://blog.csdn.net/mp624183768/article/details/81161260#参考2：https://blog.csdn.net/qq_42820064/article/details/90958577#参考3：https://blog.csdn.net/zj360202/article/details/79026891#=========================def get_char(r,g,b,alpha = 256): ascii_char = list("#RMNHQODBWGPZ*@$C&amp;98?32I1&gt;!:-;. ") #ascii_char = list("$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:oa+&gt;!:+. ") if alpha == 0: return '' length = len(ascii_char) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = (256.0+1)/len(ascii_char) return ascii_char[int(gray/unit)]#将视频转换为图片 并进行计数，返回总共生成了多少张图片！def video_to_pic(vp): #vp = cv2.VideoCapture(video_path) number = 0 if vp.isOpened(): r,frame = vp.read() if not os.path.exists('cache_pic'): os.mkdir('cache_pic') os.chdir('cache_pic') else: r = False while r: number += 1 cv2.imwrite(str(number)+'.jpg',frame) r,frame = vp.read() print('\n由视频一共生成了&#123;&#125;张图片！'.format(number)) os.chdir("..") return numberdef img_to_char(image_path,raw_width,raw_height,task): width = int(raw_width/ 6) height = int(raw_height / 15) im = Image.open(image_path).convert('RGB')#必须以RGB模式打开 im = im.resize((width,height),Image.NEAREST) txt = '' color = [] for i in range(height): for j in range(width): pixel = im.getpixel((j, i)) color.append((pixel[0],pixel[1],pixel[2])) #将颜色加入进行索引 if len(pixel)==4 : txt +=get_char(pixel[0],pixel[1],pixel[2],pixel[3]) else: txt +=get_char(pixel[0],pixel[1],pixel[2]) txt += '\n' color.append((255,255,255)) im_txt = Image.new("RGB",(raw_width,raw_height),(255,255,255)) dr = ImageDraw.Draw(im_txt) #font = ImageFont.truetype('consola.ttf', 10, encoding='unic') #改为这个字体会让图片比例改变 font = ImageFont.load_default().font x,y = 0,0 font_w,font_h=font.getsize(txt[1]) font_h *= 1.37 #调整字体大小 for i in range(len(txt)): if(txt[i]=='\n'): x += font_h y = -font_w dr.text((y,x),txt[i] ,fill = color[i]) y+=font_w os.chdir('cache_char') im_txt.save(str(task)+'.jpg') os.chdir("..") return 0def star_to_char(number,save_pic_path): if not os.path.exists('cache_char'): os.mkdir('cache_char') img_path_list = [save_pic_path + r'/&#123;&#125;.jpg'.format(i) for i in range(1,number+1)] #生成目标图片文件的路径列表 task = 0 for image_path in img_path_list: img_width , img_height = Image.open(image_path).size #获取图片的分辨率 task += 1 img_to_char(image_path, img_width , img_height, task) print('&#123;&#125;/&#123;&#125; is finished.'.format(task,number)) print('=======================') print('All image was finished!') print('=======================') return 0def jpg_to_video(char_image_path,FPS): video_fourcc=VideoWriter_fourcc(*"MP42") # 设置视频编码器,这里使用使用MP42编码器,可以生成更小的视频文件 char_img_path_list = [char_image_path + r'/&#123;&#125;.jpg'.format(i) for i in range(1,number+1)] #生成目标字符图片文件的路径列表 char_img_test = Image.open(char_img_path_list[1]).size #获取图片的分辨率 video_writter= VideoWriter('video/new_char_video.avi' , video_fourcc , FPS , char_img_test) load = 'loading.' count = 0 #用来清空load进度条的计数 for image_path in char_img_path_list: img = cv2.imread(image_path) video_writter.write(img) load = load + '.' count += 1 if count % 50 == 0 : load = 'loading' print() print('\r',load,end='') video_writter.release() print('\n') print('=======================') print('The video is finished!') print('=======================')if __name__ == '__main__': video_path = 'video/test.mp4' save_pic_path = 'cache_pic' save_charpic_path = 'cache_char' vp = cv2.VideoCapture(video_path) number = video_to_pic(vp) FPS = vp.get(cv2.CAP_PROP_FPS) star_to_char(number , save_pic_path) vp.release() jpg_to_video(save_charpic_path,FPS) 注：转载请注明出处]]></content>
      <categories>
        <category>python</category>
        <category>Opencv</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初入密码学之置换加密与破解破解]]></title>
    <url>%2F2019%2F09%2F21%2F%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B9%8B%E7%BD%AE%E6%8D%A2%E5%8A%A0%E5%AF%86%E4%B8%8E%E7%A0%B4%E8%A7%A3%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[摘要：此为学习现代密码学的一次作业，能进行不是较大文本量的txt文本周期性置换加密，并进行密文的暴力破解。 文件解释1.将文件放在同一个python文件夹下使用 2.encryption.py为加密程序，decrypt为暴力破解程序 3.plain.txt为初始待加密文本，cipher.txt为加密后生成的文本，DecryptWoed.txt为暴力破解后生成的文本。 4.若要运行可删除 (3)中的三个文本重新运行。 加密程序运行解释1.首先输入置换加密密钥的位数。 2.输入置换加密的密钥。若加密密钥为(1 5 6 2 3 )则将其代换后输入 531462 3.将待加密文本重命名为plain.txt 4.等待加密后生成cipher.txt 解密程序运行解释1.输入密钥长度即可进行暴力破解 2.采用的是深度搜索来遍历密钥的所有可能。 3.等待解密后生成DecryptWoed.txt。 4.其中所以可能会在DecryptWoed.txt以回车进行分隔。 加密程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import redef translate(): #将txt文本存入word1 file = open('plain.txt','r',encoding='utf-8') word1 = file.read() file.close #将txt文本转换只剩下英文单词 word='' word2 = re.findall('[a-zA-Z]+', word1) for i in word2: word = word + i return worddef encryption(wordlist,deltalist): #进行置换加密 NewWordlist = [] for i in wordlist: con = '' str = i for j in deltalist: con = con + str[ j -1 ] NewWordlist.append(con) return NewWordlistdef save(word): file2 = open('cipher.txt','a',encoding='utf-8') for i in word: file2.write(i) file2.close()def main(): deltasize = int(input("请输入您的密钥位数：")) delta = input("请输入您的密钥：") deltalist=[] for j in delta: deltalist.append(int(j)) #将word存入wordlist列表中 word = translate() wordlist = [] j = 0 str = '' for i in word : if(j &lt; deltasize): str = str +i j=j+1 if(j == deltasize ): wordlist.append(str) j = 0 str = '' for i in wordlist: str = i print(str) NewWordlist = [] NewWordlist = encryption(wordlist,deltalist) #用save函数存入cipher.txt中 save(NewWordlist)main() 暴力破解代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061def save(word): #存储 file2 = open(&apos;DecryptWoed.txt&apos;,&apos;a&apos;,encoding=&apos;utf-8&apos;) for i in word: file2.write(i) file2.write((&quot;\n&quot;)) file2.close()def decrypt(wordlist,deltalist): #进行置换解密 NewWordlist = [] for i in wordlist: con = &apos;&apos; str = i for j in deltalist: con = con + str[ j -1 ] NewWordlist.append(con) return NewWordlistdef DFS(p,delta,token,newdelta,wordlist): #深度搜索密钥的所以可能性 if p == len(delta): print(newdelta) save(decrypt(wordlist,newdelta)) return for index in range(len(delta)): if token[index] == True: newdelta[p] = delta[index] token[index] = False DFS(p+1,delta,token,newdelta,wordlist) token[index] = Truedef main(): deltasize = int(input(&quot;输入密钥位数：&quot;)) delta =[] for i in range(1, deltasize + 1): delta.append(i) token = [True for i in range(len(delta))] #用来深度搜索判断 newdelta = [&apos;&apos; for i in range(0, len(delta))] #引用来存储一次深度优先后的结果 file = open(&apos;cipher.txt&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;) word = file.read() #将word存入wordlist列表中 wordlist = [] j = 0 str = &apos;&apos; for i in word : if(j &lt; deltasize): str = str +i j=j+1 if(j == deltasize ): wordlist.append(str) j = 0 str = &apos;&apos; DFS(0,delta,token,newdelta,wordlist)main()]]></content>
      <categories>
        <category>现代密码学</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>现代密码学</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建神经网络并进行训练和查询]]></title>
    <url>%2F2019%2F08%2F03%2F%E5%88%9B%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%B9%B6%E8%BF%9B%E8%A1%8C%E8%AE%AD%E7%BB%83%E5%92%8C%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[摘要：通过对神经网络编程这本书的内容，模仿其中的代码，对初次学习神经网络进行熟悉，并逐步完成神经网络的搭建，完成对手写数字的识别。 神经网络的三大步骤 初始化函数–设定输入节点、隐藏节点和输出节点的数量。 训练–学习给定的训练集样本后，优化权重。 查询–给定输入，从输出的节点给出答案。 初始化网络–输入1234567891011121314151617181920212223242526def __init__(self , inputnodes , hiddennodes , outputnodes , learningrate): #set number of nodes in each input, hidden, output layer self.inodes = inputnodes self.hnodes = hiddennodes self.onodes = outputnodes #链接权重矩阵 #link weight matrices, wih and who 注释：此处wih的意思是 w:权重 i:input h:hidden ,后面的who同理 #weights inside the arrays are w_i_j,where link is from node i to node j in the next layter #w11 w21 #w12 w22 etc self.wih = (numpy.random.rand(self.hnodes, self.inodes) - 0.5) self.who = (numpy.random.rand(self.onodes, self.hnodes) - 0.5) #learning rate self.lr = learningrate #导入scipy.special 才可以用 #activation function is the sigmoid function #使用lambda来创建函数， 函数接受了X，返回了scipy.special.expit(x)，这就是S函数，使用lambda创建的匿名函数 self.activation_function = lambda x: scipy.special.expit(x) pass 其中，需要注意的地方有： 函数名 __init__是前后两条“_” ,如果只有一条下划线的话会报错TypeError : object() takes no parameters 参考链接：https://blog.csdn.net/qq_26489165/article/details/80595864 链接权重矩阵：此处wih的意思是 w:权重 i:input h:hidden ,后面的whoy也是同理 12self.wih = (numpy.random.rand(self.hnodes, self.inodes) - 0.5)self.who = (numpy.random.rand(self.onodes, self.hnodes) - 0.5) 使用lambda来创建函数， 函数接受了X，返回了scipy.special.expit(x)，这就是S函数，使用lambda创建的匿名函数 1self.activation_function = lambda x: scipy.special.expit(x) 初始化网络–查询12345678910111213#convert inouts list to 2d array inputs = numpy.array(inputs_list,ndmin= 2 ) .T #calculate signals into hidden layer hidden_inputs = numpy.dot(self.wih , inputs) #calculate the signals emerging from hidden layer hidden_outputs = self.activation_function(hidden_inputs) #calculate signals into final output layer final_inputs = numpy.dot(self.who , hidden_outputs) #calculate the signals emerging from final output layer final_outputs = self.activation_function(final_inputs) return final_outputs pass 初始化网络–训练1234567891011121314151617181920212223242526#train the neural networkdef train(self, input_list, targets_list): #可以发现下面的代码和query中的几乎完全一样。因为所使用的从输入层前馈信号到最终输出层完全一样。而多处理的targets 是用来训练样本的。 #cober inputs list to 2d array inputs = numpy.array(input_list,ndmin=2).T targets = numpy.array(targets_list,ndmin=2).T #calculate signals into hidden layer hidden_inputs = numpy.dot(self.wih , inputs) #calculate the signals emerging from hidden layer hidden_outputs = self.activation_function(hidden_inputs) #calculate signals into final output layer final_inputs = numpy.dot(self.who , hidden_outputs) #calculate the signals emerging from final output layer final_outputs = self.activation_function(final_inputs) #error is the (target -actual),即为反向传播的误差 output_errors = targets - final_outputs #hidden layer error is the output_errors , split by weights,recombined at hodden nodes hidden_errors = numpy.dot(self.who.T , output_errors) #update the weights for the links between the hidden and output layers #其中，学习率是self.lr 利用numpy.dot进行矩阵的乘法 self.who += self.lr * numpy.dot((output_errors * final_outputs * (1.0 - final_outputs)), numpy.transpose(hidden_outputs)) #update the weights for the links between the intput and hidden layers self.wih += self.lr * numpy.dot((hidden_errors * hidden_outputs * (1.0 - hidden_outputs)), numpy.transpose(inputs)) pass 其中，需要注意的是： 可以发现下面的代码和query中的几乎完全一样。因为所使用的从输入层前馈信号到最终输出层完全一样。而多处理的targets 是用来训练样本的。 而error中error is the (target -actual),即为反向传播的误差 学习率是self.lr 利用numpy.dot进行矩阵的乘法 创建神经网络对象12345678910#number of input, hidden and output nodesinput_nodes = 784hidden_nodes = 100output_nodes = 10#learn rate is 0.3 （学习率）learning_rate = 0.3#create instance of neural networkn = neuralNetwork(input_nodes, hidden_nodes, output_nodes, learning_rate) 为什么选择784个输入节点呢？请记住这是28*28的结果，即是组成手写数字图像的像素个数。 选择100个隐藏节点并没有固定规定，书中认为神经网络可以发现在输入中的特征或模式，这些模式或者特征可以使用比输入本身更简短的表达，因此没有和选择比784大的数字。选择比输入节点小的数量来强制网络尝试总结输入的主要特点。但选择太少的隐藏节点就限制了网络的能力。给定10个输出层的节点对应的是10个标签。 强调一点：对于一个问题，选择多少个隐藏层节点并不存在一份最佳方法。最好的办法就是进行实验，直到找到适合你解决问题的一个数字。 测试网络 打开文件 1234#load the mnist training data CSV file into a listtraining_data_file = open("TestandTrain/mnist_train_100.csv",'r')training_data_list = training_data_file.readlines()training_data_file.close() 将文件放在同目录下即可直接调用 训练网络 123456789101112# train the neural network# go through all records in the training data set for record in training_data_list: # split the record by the ',' commas all_values = record.split(',') # scale and shift the inputs inputs = (numpy.asfarray(all_values[1:]) / 255.0 * 0.99) + 0.01 targets = numpy.zeros(output_nodes) + 0.01 # all_values[0] is the target label for this record targets[int(all_values[0])] = 0.99 n.train(inputs, targets) pass 查询网络 打开文件 1234#load the mnist test data CSV file into a listtest_data_file = open("TestandTrain/mnist_test_10.csv",'r')test_data_list = test_data_file.readlines()test_data_file.close() 打印标签 并进行matplotlib进行图形化显示并查看测试概率 1234567891011#get the first test recordall_values = test_data_list[2].split(',')#print the lable#打印标签print('label:',all_values[0])image_array = numpy.asfarray(all_values[1:]).reshape((28,28))matplotlib.pyplot.imshow(image_array,cmap='Greys',interpolation='None')n.query((numpy.asfarray(all_values[1:])/ 255.0 * 0.99) + 0.01) 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127import numpy#scipy.special for the sigmoid function expit()import scipy.special#添加绘图库import matplotlib.pyplot%matplotlib inline#neural network classdefinitionclass neuralNetwork: #初始化网络 #initialise the neural netwoak #注意！-----&gt;此处init前后均是双下划线，否则报错 #TypeError: object() takes no parameters #参考链接：https://blog.csdn.net/qq_26489165/article/details/80595864 def __init__(self , inputnodes , hiddennodes , outputnodes , learningrate): #set number of nodes in each input, hidden, output layer self.inodes = inputnodes self.hnodes = hiddennodes self.onodes = outputnodes #链接权重矩阵 #link weight matrices, wih and who 注释：此处wih的意思是 w:权重 i:input h:hidden ,后面的who同理 #weights inside the arrays are w_i_j,where link is from node i to node j in the next layter #w11 w21 #w12 w22 etc self.wih = (numpy.random.rand(self.hnodes, self.inodes) - 0.5) self.who = (numpy.random.rand(self.onodes, self.hnodes) - 0.5) #learning rate self.lr = learningrate #导入scipy.special 才可以用 #activation function is the sigmoid function #使用lambda来创建函数， 函数接受了X，返回了scipy.special.expit(x)，这就是S函数，使用lambda创建的匿名函数 self.activation_function = lambda x: scipy.special.expit(x) pass #train the neural network def train(self, input_list, targets_list): #可以发现下面的代码和query中的几乎完全一样。因为所使用的从输入层前馈信号到最终输出层完全一样。而多处理的targets 是用来训练样本的。 #cober inputs list to 2d array inputs = numpy.array(input_list,ndmin=2).T targets = numpy.array(targets_list,ndmin=2).T #calculate signals into hidden layer hidden_inputs = numpy.dot(self.wih , inputs) #calculate the signals emerging from hidden layer hidden_outputs = self.activation_function(hidden_inputs) #calculate signals into final output layer final_inputs = numpy.dot(self.who , hidden_outputs) #calculate the signals emerging from final output layer final_outputs = self.activation_function(final_inputs) #error is the (target -actual),即为反向传播的误差 output_errors = targets - final_outputs #hidden layer error is the output_errors , split by weights,recombined at hodden nodes hidden_errors = numpy.dot(self.who.T , output_errors) #update the weights for the links between the hidden and output layers #其中，学习率是self.lr 利用numpy.dot进行矩阵的乘法 self.who += self.lr * numpy.dot((output_errors * final_outputs * (1.0 - final_outputs)), numpy.transpose(hidden_outputs)) #update the weights for the links between the intput and hidden layers self.wih += self.lr * numpy.dot((hidden_errors * hidden_outputs * (1.0 - hidden_outputs)), numpy.transpose(inputs)) pass #query the neural network def query(self, inputs_list): #convert inouts list to 2d array inputs = numpy.array(inputs_list,ndmin= 2 ) .T #calculate signals into hidden layer hidden_inputs = numpy.dot(self.wih , inputs) #calculate the signals emerging from hidden layer hidden_outputs = self.activation_function(hidden_inputs) #calculate signals into final output layer final_inputs = numpy.dot(self.who , hidden_outputs) #calculate the signals emerging from final output layer final_outputs = self.activation_function(final_inputs) return final_outputs pass #number of input, hidden and output nodesinput_nodes = 784hidden_nodes = 100output_nodes = 10#learn rate is 0.3learning_rate = 0.3#create instance of neural networkn = neuralNetwork(input_nodes, hidden_nodes, output_nodes, learning_rate)#load the mnist training data CSV file into a listtraining_data_file = open("TestandTrain/mnist_train_100.csv",'r')training_data_list = training_data_file.readlines()training_data_file.close()# train the neural network# go through all records in the training data set for record in training_data_list: # split the record by the ',' commas all_values = record.split(',') # scale and shift the inputs inputs = (numpy.asfarray(all_values[1:]) / 255.0 * 0.99) + 0.01 targets = numpy.zeros(output_nodes) + 0.01 # all_values[0] is the target label for this record targets[int(all_values[0])] = 0.99 n.train(inputs, targets) pass #load the mnist test data CSV file into a listtest_data_file = open("TestandTrain/mnist_test_10.csv",'r')test_data_list = test_data_file.readlines()test_data_file.close()#get the first test recordall_values = test_data_list[2].split(',')#print the lable#打印标签print('label:',all_values[0])#get the first test recordall_values = test_data_list[2].split(',')#print the lable#打印标签print('label:',all_values[0])image_array = numpy.asfarray(all_values[1:]).reshape((28,28))matplotlib.pyplot.imshow(image_array,cmap='Greys',interpolation='None')n.query((numpy.asfarray(all_values[1:])/ 255.0 * 0.99) + 0.01) 记得给代码加上头文件 123456import numpy#scipy.special for the sigmoid function expit()import scipy.special#添加绘图库import matplotlib.pyplot%matplotlib inline]]></content>
      <categories>
        <category>python</category>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora极简教程]]></title>
    <url>%2F2019%2F07%2F27%2FTypora%E6%9E%81%E7%AE%80%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[摘要： Markdown 是一种轻量级标记语言，创始人是约翰·格鲁伯（John Gruber）。它允许人们 “使用易读易写的纯文本格式编写文档，然后转换成有效的 HTML 文档。” 下载Typora官方下载：https://www.typora.io/#download 常用快捷键 加粗： Ctrl/Cmd + B 标题： Ctrl/Cmd + H 插入链接： Ctrl/Cmd + K 插入代码： Ctrl/Cmd + Shift + C 行内代码： Ctrl/Cmd + Shift + K 插入图片： Ctrl/Cmd + Shift + I 无序列表： Ctrl/Cmd + Shift + L 撤销： Ctrl/Cmd + Z 一级标题：快捷键为Ctrl + 1，以此类推 引用文字1234&gt; + 空格 + 引用文字&gt; 引用内容1&gt; 引用内容2&gt;&gt; 引用内容3 引用内容1引用内容2 引用内容3 列表输入 列表内容 将创建一个无序列表，该符号可以替换为+或-。 无序列表123* 无序列表1+ 无序列表2- 无序列表3 无序列表1 无序列表2 无序列表3 有序列表1231. 有序列表12. 有序列表23. 有序列表3 有序列表1 有序列表2 有序列表3 多行无序列表123* 多行无序列表1TAB * 多行无序列表2TAB TAB * 多行无序列表3 多行无序列表1 多行无序列表2 多行无序列表3 任务列表123-[ ] 不抽烟-[x] 不喝酒-[ ] 不烫头 -[ ] 不抽烟-[x] 不喝酒-[ ] 不烫头 表格123456|姓名|性别|年龄|手机号||:---|:--:|:--:|---:||居左|居中|居中|居右||张三|男|21|18975346876||李四|女|23|17789548964||王五|男|25|15876513546| 姓名 性别 年龄 手机号 居左 居中 居中 居右 张三 男 21 18975346876 李四 女 23 17789548964 王五 男 25 15876513546 链接图片本地图片1[图片上传失败...(image-61fd19-1520850984854)] 网络图片1![pikachu.jpg](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1564157419510&amp;di=e96d9359d9cba4b936ed55eb804c54bb&amp;imgtype=0&amp;src=http%3A%2F%2Fdata.whicdn.com%2Fimages%2F3045613%2Flarge.jpg) 超链接行内式链接1[我的博客][https://hongcyu.github.io] [我的博客][https://hongcyu.github.io] 参考式链接12[CSDN][CSDN网址][CSDN网址]:https://www.csdn.net/ CSDN 自动链接123&lt;https://www.github.com&gt;或https://www.github.com https://www.github.com https://www.github.com 其他斜体12*斜体*_斜体_ 斜体斜体 加粗12**加粗**__加粗__ 加粗加粗 下划线1&lt;u&gt;下划线&lt;/u&gt; 下划线 删除线1~~删除线~~ 删除线 分隔线123***---___ 注脚12Typora[^1][^1]A markdown editor Typora[^1][^1]A markdown editor 符号的输入123456789101112\\ 反斜线\` 反引号\* 星号\_ 底线\&#123; \&#125; 花括号\[ \] 方括号\( \) 括弧\# 井字号\+ 加号\- 减号\. 英文句点\! 惊叹号 \ 反斜线` 反引号* 星号_ 底线{ } 花括号[ ] 方括号( ) 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 特殊字符1234567891011121314151617181920&amp;copy; 版权 &amp;reg; 注册商标&amp;trade; 商标&amp;nbsp; 空格&amp;amp; 和号&amp;quot; 引号&amp;apos; 撇号&amp;lt; 小于号&amp;gt; 大于号&amp;ne; 不等号&amp;le; 小于等于&amp;ge; 大于等于&amp;cent; 分&amp;pound; 磅&amp;euro; 欧元&amp;yen; 元&amp;sect; 节&amp;times; 乘号&amp;divide; 除号&amp;plusmn; 正负号 &copy; 版权&reg; 注册商标&trade; 商标&nbsp; 空格&amp; 和号&quot; 引号&apos; 撇号&lt; 小于号&gt; 大于号&ne; 不等号&le; 小于等于&ge; 大于等于&cent; 分&pound; 磅&euro; 欧元&yen; 元&sect; 节&times; 乘号&divide; 除号&plusmn; 正负号 附件：[HTML特殊字符编码对照表][https://www.jb51.net/onlineread/htmlchar.htm] 插入音乐和视频音乐1）直接用 HTML 的标签，写法如下： 1&lt;audio src=&quot;https://什么什么什么.mp3&quot; style=&quot;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;&quot; controls=&quot;controls&quot; loop=&quot;loop&quot; preload=&quot;meta&quot;&gt;Your browser does not support the audio tag.&lt;/audio&gt; 2）用插件，有显示歌词功能，也美观。首先在站点文件夹根目录安装插件： 1npm install hexo-tag-aplayer --save 然后文章中的写法： 1&#123;% aplayer &quot;歌曲名&quot; &quot;歌手名&quot; &quot;https://什么什么什么.mp3&quot; &quot;https://封面图.jpg&quot; &quot;lrc:https://歌词.lrc&quot; %&#125; 另外可以支持歌单： 1234567891011121314151617181920212223&#123;% aplayerlist %&#125;&#123; &quot;autoplay&quot;: false, &quot;showlrc&quot;: 3, &quot;mutex&quot;: true, &quot;music&quot;: [ &#123; &quot;title&quot;: &quot;歌曲名&quot;, &quot;author&quot;: &quot;歌手名&quot;, &quot;url&quot;: &quot;https://什么什么什么.mp3&quot;, &quot;pic&quot;: &quot;https://封面图.jpg&quot;, &quot;lrc&quot;: &quot;https://歌词.lrc&quot; &#125;, &#123; &quot;title&quot;: &quot;歌曲名&quot;, &quot;author&quot;: &quot;歌手名&quot;, &quot;url&quot;: &quot;https://什么什么什么.mp3&quot;, &quot;pic&quot;: &quot;https://封面图.jpg&quot;, &quot;lrc&quot;: &quot;https://歌词.lrc&quot; &#125; ]&#125;&#123;% endaplayerlist %&#125; 里面的详细参数见 README 和这插件的「母亲」Aplayer 的官方文档。关于 LRC歌词，可以用工具下载网易云音乐的歌词，另发现暂时不支持offset参数。当然，如果那歌词很操蛋，有错误（比如字母大小写和标点符号乱加）或者时间完全对不上，然后你也和我一样是个完美主义者，那接下来就是令人窒息的操作了，一句一句自己查看修改…… 什么，你想把网易云的几百首歌手动同步到博客？慢慢慢，有一种非常简单的方法，此这种方法也支持单曲，将参数里的playlist更改为song即可，非常建议食用！更多功能请仔细阅读 README。 视频1）直接用 HTML 的标签，写法如下： 1&lt;video poster=&quot;https://封面图.jpg&quot; src=&quot;https://什么什么什么.mp4&quot; style=&quot;max-height :100%; max-width: 100%; display: block; margin-left: auto; margin-right: auto;&quot; controls=&quot;controls&quot; loop=&quot;loop&quot; preload=&quot;meta&quot;&gt;Your browser does not support the video tag.&lt;/video&gt; 2）用插件，可支持弹幕，首先在站点文件夹根目录安装插件： 1npm install hexo-tag-dplayer --save 然后文章中的写法： 1&#123;% dplayer &quot;url=https://什么什么什么.mp4&quot; &quot;https://封面图.jpg&quot; &quot;api=https://api.prprpr.me/dplayer/&quot; &quot;id=&quot; &quot;loop=false&quot; %&#125; 要使用弹幕，必须有api和id两项，并且若使用的是官方的 api 地址（即上面的），id 的值不能与这个列表的值一样。id 的值自己随便取，唯一要求就是前面这点。如果唯一要求难倒了你，可以使用这个工具将一段与众不同的文字生成一段看起来毫无意义的哈希值，这样看起来是不是好多了。 当然，这个插件的功能还有很多，可以去 README 和这插件的「母亲」Dplayer 的官方文档看看。]]></content>
      <categories>
        <category>书写格式</category>
        <category>Typora</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的简单命令]]></title>
    <url>%2F2019%2F07%2F25%2Fhexo%E7%9A%84%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[介绍了Hexo的一些简单命令。 hexo s启动本地服务器，用于预览主题。默认地址： http://localhost:4000/hexo s 是 hexo server 的缩写，命令效果一致；预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果。 hexo new “学习笔记”新建一篇标题为 学习笔记 的文章，因为标题里有空格，所以加上了引号。文章标题可以在对应 md 文件里改，新建时标题可以写的简单些。 hexo d自动生成网站静态文件，并部署到设定的仓库。hexo d 是 hexo deploy 的缩写，命令效果一致。 hexo clean清除缓存文件 db.json 和已生成的静态文件 public 。网站显示异常时可以执行这条命令试试。 hexo g生成网站静态文件到默认设置的 public 文件夹。便于查看网站生成的静态文件或者手动部署网站；如果使用自动部署，不需要先执行该命令；hexo g 是 hexo generate 的缩写，命令效果一致。 hexo new page aboutme新建一个标题为 aboutme 的页面，默认链接地址为 主页地址/aboutme/标题可以为中文，但一般习惯用英文；页面标题和文章一样可以随意修改；页面不会出现在首页文章列表和归档中，也不支持设置分类和标签。 参考文献https://www.bilibili.com/video/av44544186https://blog.csdn.net/dxxzst/article/details/76135935]]></content>
      <categories>
        <category>命令格式</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
